<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2020-04-24T02:05:39+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>《极客时间》 微服务架构核心20讲</title>
      <link href="http://localhost:4000/time-geekbang-microservice-core20/"/>
      <pubDate>2020-02-09T03:22:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/time-geekbang-microservice-core20</guid>
      <content:encoded><![CDATA[<p>极客时间学习笔记， 微服务架构核心20讲</p>

<p>作者：杨波　（拍拍贷框架研发部总监，资深架构师，微服务技术专家）</p>

<p><a href="https://time.geekbang.org/course/intro/66">微服务架构核心20讲 https://time.geekbang.org/course/intro/66</a></p>

<h2 id="1-什么是微服务架构">1 什么是微服务架构</h2>
<hr />
<p>微服务是一种架构风格（如MVC）　</p>

<p>微服务的六个特点：　</p>
<ul>
  <li>一组小的服务</li>
  <li>独立的进程</li>
  <li>轻量级通信</li>
  <li>基于业务能务</li>
  <li>独立部署</li>
  <li>无集中式管理 （这里指的是可以用不同的技术栈，不同的存储）</li>
</ul>

<p>微服框架的定义者马丁福勒：他的一篇博客：</p>

<p><a href="https://www.martinfowler.com/articles/microservices.html">马丁福勒的文章 https://www.martinfowler.com/articles/microservices.htm</a></p>

<p><strong>微服务定义</strong></p>

<p>基于有界上下文的　松散耦合面向服务的架构。</p>

<h2 id="２架构师如何权衡微服务的利弊">２　架构师如何权衡微服务的利弊</h2>
<hr />
<p>开发者的一个重要职责就是权衡</p>

<p>利:</p>

<ul>
  <li>强模块化边界</li>
  <li>可独立部署</li>
  <li>技术多样性</li>
</ul>

<p>弊:</p>
<ul>
  <li>分布式系统复杂性</li>
  <li>最终一致性</li>
  <li>运维复杂性</li>
  <li>测试复杂性</li>
</ul>

<p>分布式系统带来的一个挑战就是取终一致性。</p>

<h2 id="３康威法则和微服务给架构师怎样的启示">３　康威法则和微服务给架构师怎样的启示</h2>
<hr />

<p>设计系统的组织，其产生的架构设计等价于组织间的沟通结构。</p>

<p>其实就是要规避，多个团队去支持一个服务模块。应该拆解成一个团队支持一个小服务，多个小服务组织成一个大服务（或系统）。</p>

<h2 id="４企业应该在什么时候开始考虑引入微服务">４　企业应该在什么时候开始考虑引入微服务</h2>
<hr />

<p>微服务的适用性:</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_4.png" alt="" /></p>

<p>Monolth 单块服务</p>

<p>Microservice 微服务</p>

<p>微服务 有基础模块和平台的要求，所以企业刚开始时微服务并不能有高的生产力。</p>

<p>所以一般以单块服务开始。适用于小企业，微服务更加适合于中大型企业。</p>

<p>中间的交点，就是企业要考虑从单块服务切换成微服务的时候了。</p>

<p>业务模块的复杂性已经达到某个点了。 点的把控要架构师应该思考的问题、一般100人的团队可以考虑了这个问题了。</p>

<p>一般业务开始以单块服务优先。如果研发效率开始下降了。再做优化，向微服方向转变。</p>

<p>如果一开始就以微服开始，可能在设计上会更复杂。</p>

<p>架构是演化出来的。</p>

<p>不可能一步到位， 所以一般是单块优先原则，然后不断迭代，不断的微服化。</p>

<h2 id="5-什么样组织架构更适合微服务">5 什么样组织架构更适合微服务</h2>
<hr />

<p>组织架构：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_5_1.png" alt="" /></p>

<p>左边是比较传统的组织架构。产品从左到右流程走，可能出现的问题，反馈比较慢，对业务支持比较慢。沟通成本比较大。</p>

<p>右边是比较合适微服务的组织架构， 每一个团队（基于微服务的跨职能的团队），有开发，有产品，有测试，团队都支持自己的微服务。交付的产口是平台，对外提供API
接口支持多样的业务。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_5_2.png" alt="" /></p>

<p>在团队内做内部循环。端对端的开发。</p>

<p>谁开发的，谁构建，谁支持。</p>

<h2 id="6-如何理解阿里巴巴提出的微服务">6 如何理解阿里巴巴提出的微服务</h2>
<hr />

<p>中台战略和微服务的关系
下图：一线互联网主流的组织架构。 微服的标准的参考架构。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_6.png" alt="" /></p>

<p>业务中台和技术中台 统称为大中台。支撑业务前台。中台越强大，前台越发展越快。</p>

<p>PaaS 和 核心业务层是和微服务相关的。这一些基本都可以用微服务来实现。</p>

<p>IaaS：Infrastructure-as-a-Service（基础设施即服务）</p>

<p>PaaS：Platform-as-a-Service（平台即服务）</p>

<h2 id="7-如何给出一个清晰简洁的服务分层方式">7 如何给出一个清晰简洁的服务分层方式</h2>
<hr />

<p>大致的服务分层图：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_7.png" alt="" /></p>

<p>SOA  Service-Oriented Architecture  （面向服务的架构）</p>

<p>基础服务：　也有其他的说法。如：核心领域服务、中间层服务、公共服务。</p>

<p>聚合服务：　对基础服务的聚全和裁剪，以达到满足业务的需求，提供给外部调用。　</p>

<h2 id="８微服务总体技术架构体系是怎么设计的">８　微服务总体技术架构体系是怎么设计的</h2>
<hr />

<p>微服务总体架构体系图：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_8.png" alt="" /></p>

<ul>
  <li>接入层：　外部和内部接入，主要把流量接入进来，做负载均衡。</li>
  <li>网关层：　反向路由，限流，安全，跨横切面的功能。　　</li>
  <li>业务服务层：　可分为：聚合服务，基础服务。</li>
  <li>支撑服务： 后台服务。</li>
  <li>平台服务： 可以是一些管理系统。</li>
  <li>基础设施　由运维团队运维。　</li>
</ul>

<p>网关层、业务服务层、支撑服务、平台服务。 这四层可以和微服务相关的，</p>

<h2 id="9-微服务最经典的三种服务发现机制">9 微服务最经典的三种服务发现机制</h2>
<hr />

<p>消息者应该怎么去发现生产者。三者主流的模式：</p>

<p>1 通过DNS 访问LB，LB（负载均衡）。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_9_1.png" alt="" /></p>

<p>2 　LB功能放到Consumer内， service 注册到 Service Registry上。有定时心跳发到注册中收，Consumer  定期的同步 Service Registry的信息。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_9_2.png" alt="" /></p>

<p>3 结全前面两种方式， 在Consumer的主机上也布置一个LB。 LB会定期同步Service Registry的信息。 运维成本比较高一点。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_9_3.png" alt="" /></p>

<h2 id="10-微服务-api-服务网关一原理">10 微服务 API 服务网关（一）原理</h2>
<hr />

<p>API　Gateway</p>

<p>屏蔽掉服务内部的逻辑，希望外部访问看到是统一的接口。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_10_1.png" alt="" /></p>

<p>下面这个图 接入网关的前面有一层LB（负载均衡）如果是网关可以是无状态的，这样方便扩展，单点挂掉时，可以摘除。对系统的稳定性很重要。</p>

<h5 id="网关主要的功能">网关主要的功能</h5>
<ul>
  <li>反向路由  将外部的请求换成内部调用。</li>
  <li>认证安全 防刷 防爬虫。</li>
  <li>限流熔断 处理可能会突发流量。</li>
  <li>日志监控  进行访问访问审计，监控流量。</li>
</ul>

<p>一般不要把过多的业务逻辑写在网关当中。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_10_2.png" alt="" /></p>

<h2 id="11-服务-api-服务网关二开源网关-zuul">11 服务 API 服务网关（二）开源网关 Zuul</h2>
<hr />

<p>核心:  Servlet 和 Fitter Runner 
过滤器：  前置过滤器，  路由过滤器，后置过滤器</p>

<p>过滤器开发，可以通过脚本开发。开发完后上传到过滤器目录中， 被扫描后加到Filtter Runner中。</p>

<p>各个Fitte 共享数据通过 Request Context 来实现。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_11_1.png" alt="" /></p>

<p>过滤链的流程：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_11_2.png" alt="" /></p>

<p>前置路由过滤器</p>

<p>路由过滤器</p>

<p>后置路由过滤器</p>

<h2 id="12-跟-netflix-学习微服务路由发现体系">12 跟 Netflix 学习微服务路由发现体系</h2>
<hr />

<p>netflix 有两个比较重要的支撑服务</p>

<ul>
  <li>服务注册中心  Eureka</li>
  <li>网关 zuul</li>
</ul>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_12.png" alt="" /></p>

<h2 id="13-集中式配置中心的作用和原理是什么">13 集中式配置中心的作用和原理是什么</h2>
<hr />

<p>为什么要引入配置中心呢？
　
小企业一般是写在配置文件中的，不方便管理。响应比较慢。无法审计。配置中心可能解决这些问题。</p>

<p>什么可做配置呢？</p>

<ul>
  <li>业务开关</li>
  <li>调用/响应超时</li>
  <li>限流</li>
  <li>连接字符串</li>
  <li>动态参数</li>
</ul>

<p>Svr 更新配置有两种方式 拉和推。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_13_1.png" alt="" /></p>

<p>携程的Apollo配置中心:</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_13_2.png" alt="" /></p>

<p>github : https://github.com/ctripcorp/apollo</p>

<h2 id="14-微服务通讯方式-rpc-vs-rest">14 微服务通讯方式 RPC vs REST</h2>
<hr />
<p>RPC：Remote Procedure Call 远程过程调用</p>

<p>REST ：Restful</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_14.png" alt="" /></p>

<h2 id="15-微服务框架需要考虑哪些治理环节">15 微服务框架需要考虑哪些治理环节</h2>
<hr />

<p>一个公司的微服务多了，就要需要考虑治理。</p>

<p>软负载： 蓝绿发布， 灰度发布</p>

<p>Metrics: 服务的调用量， 耗时监控。</p>

<p>调用链埋点： 方便快速定位问题，</p>

<p>契约生成代码： 定义结构体可自动生成json格式， vscode 有插件。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_15.png" alt="" /></p>

<p>阿里巴巴微服务治理生态：Dubbo 	http://dubbo.apache.org/en-us/</p>

<h2 id="16-微服务监控系统分层和监控架构">16 微服务监控系统分层和监控架构</h2>
<hr />

<p>五个层次的监控</p>

<ul>
  <li>基础设施监控</li>
  <li>系统层监控</li>
  <li>应用层监控 url sevice mysql cache 可用率，性能， qps</li>
  <li>业务层监控 核心指标监控 登录注册</li>
  <li>端用户体验监控</li>
</ul>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_16_1.png" alt="" /></p>

<p>日志 监控  对应Elasticsearch<br />
metrics 监控
健康检查
调用链监控
告警系统</p>

<p>比较典型的监控架构，大部分公司的流程</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_16_2.png" alt="" /></p>

<p>比较大的队列用kafka 。</p>

<p>Nagios 健康检测工具。</p>

<p>ELK　ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。</p>

<h2 id="17-微服务的调用链监控该如何选型">17 微服务的调用链监控该如何选型</h2>
<hr />

<p>调用链的监控　谷歌2010年提出来的。　</p>

<p>通过 Span来跟踪， RootSpan  ChildSpan  跨进程时  会有Trace di + parant span id</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_17_1.png" alt="" /></p>

<p>三个主流调用链监控系统的比较：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_17_2.png" alt="" /></p>

<h2 id="18-微服务的容错限流是如何工作的">18 微服务的容错限流是如何工作的</h2>
<hr />

<p>Netfiix  Hystrix 具有熔断 隔离 限流 降级的功能 。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_18.png" alt="" /></p>

<p>说明：</p>

<ul>
  <li>3 Cirult OPen 判断是否可以熔断， 是则执行 getFAllBack() 降级处理函数</li>
  <li>5 run() 超时 也执行降级处理函数。</li>
  <li>6 不成功也 执行处理函数 。</li>
  <li>Calculate Cirult Health 就是在正常执行成功后计算是否需要熔断。</li>
</ul>

<h2 id="19-docker-容器部署技术--持续交付流水线">19 Docker 容器部署技术 &amp; 持续交付流水线</h2>
<hr />

<p>docker 容器治理就是解决：环境不一致的问题。把依赖的所有包都打在镜像中。</p>

<p>统一、标准化的交付流水线。</p>

<p>UAT 环境： User Acceptance Test （用户验收测试）</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_19_1.png" alt="" /></p>

<p>发布模式： 蓝绿布置，灰度发布（金丝雀发布）。</p>

<p>金丝雀发布 滚动发布：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_19_2.png" alt="" /></p>

<h2 id="20-容器集群调度和基于容器的发布体系">20 容器集群调度和基于容器的发布体系</h2>
<hr />

<p>资源调度框架 Mesos 架构</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_20_1.png" alt="" /></p>

<p>基于容器的云发布体系</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_20_2.png" alt="" /></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 条件变量 sync.Cond</title>
      <link href="http://localhost:4000/timegeekbang-go-syncCond/"/>
      <pubDate>2019-03-28T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-syncCond</guid>
      <content:encoded><![CDATA[<p>条件变量是和互斥锁一起使用的。
条件变量是和互斥锁一起使用的。</p>

<p>条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。</p>

<p>条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。</p>

<p>这里有一个疑问：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">mailbox</span><span class="x"> </span><span class="kt">uint8</span><span class="x">
</span><span class="k">var</span><span class="x"> </span><span class="n">lock</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span><span class="x">
</span><span class="n">sendCond</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span><span class="x">
</span><span class="n">recvCond</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="n">lock</span><span class="o">.</span><span class="n">RLocker</span><span class="p">())</span><span class="x">
</span></code></pre></div></div>

<p>endCond := sync.NewCond(&amp;lock)和recvCond := sync.NewCond(lock.RLocker())</p>

<p>传入的一个是 &amp;lock 另一个是 lock.RLocker() 为什么？</p>

<p><strong>条件变量的Wait方法做了什么？</strong></p>

<p>条件变量的Wait方法主要做了四件事。</p>

<p>1　把调用它的 goroutine（也就是当前的 goroutine）加入到当前条件变量的通知队列中。</p>

<p>2　解锁当前的条件变量基于的那个互斥锁。</p>

<p>3　让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 goroutine 就会阻塞在调用这个Wait方法的那行代码上。</p>

<p>4　如果通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的goroutine 就会继续执行后面的代码了。</p>

<p><strong>条件变量的Signal方法和Broadcast方法有哪些异同？</strong></p>

<p>条件变量的Signal方法和Broadcast方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 goroutine，而后者的通知却会唤醒所有为此等待的 goroutine。</p>

<p>扩展 ：https://blog.csdn.net/wentyoon/article/details/81174288</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 互斥锁 sync.Mutex与sync.RWMutex</title>
      <link href="http://localhost:4000/timegeekbang-go-syncMutex/"/>
      <pubDate>2019-03-27T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-syncMutex</guid>
      <content:encoded><![CDATA[<p>一个互斥锁可以被 用来保护一个临界区或一组相关临界区。保证在同一时刻只有一个Goroutine处于该临界区之内</p>

<p>为了兑现这保证上，每当goroutine 想进入临界区时，都要先对它进行锁定 ，离开时临界区时都要及时地对它进行解锁。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
</span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writer</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
 </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"error: %s [%d]"</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">,</span><span class="x"> </span><span class="n">id</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
</span></code></pre></div></div>

<p><strong>使用互斥锁时有哪 些注意事项：</strong></p>

<p>1 不要重复锁定互斥锁。</p>

<p>2 不要忘记解锁互斥锁，必要时用 defer 语句</p>

<p>3 不要对沿未锁定或者已经解锁的互斥锁解锁</p>

<p>4 不要在多个函数之前直接传递互斥锁</p>

<p>死锁时抛出的panic是属于致使错误，都是无法被恢复的，调用recover函数对它们起不了任何作用。</p>

<p>互斥锁是开箱即用的。sysnc.Mutex类型 是一个结构体类型，属于值类型中的一种，把它传给一个函数、将它从函数中返回，把它赋给其他变量。让它进入 某个通道都会导致它的副本的产生。
它们是独立的，都是不同的互斥锁。</p>

<p><strong>读写锁与互斥锁有哪 异同？</strong></p>

<p>sync.RWMute类型的值代表。 都是开箱即用。 它是把对共享资源的“读操作”和“写操作”区别对待。</p>

<p>比互斥锁有列加细腻的访问控制。</p>

<p>一个读写锁中实际上包含了两个锁，即：读锁和写锁。sync.RWMutex类型中的Lock方法和Unlock方法分别用于对写锁进行锁定和解锁，而它的RLock方法和RUnlock方法则分别用于对读锁进行锁定和解锁。</p>

<p><strong>另外，对于同一个读写锁来说有如下规则：</strong></p>

<p>1 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的 goroutine。</p>

<p>2 在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的 goroutine</p>

<p>3 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goroutine。</p>

<p>4 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的goroutine。</p>

<p>换一个角度来说，对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行。</p>

<p>go 语言代码  实例：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
    </span><span class="s">"bytes"</span><span class="x">
    </span><span class="s">"errors"</span><span class="x">
    </span><span class="s">"fmt"</span><span class="x">
    </span><span class="s">"io"</span><span class="x">
    </span><span class="s">"log"</span><span class="x">
    </span><span class="s">"sync"</span><span class="x">
    </span><span class="s">"time"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="c">// singleHandler 代表单次处理函数的类型。</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">singleHandler</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x">

</span><span class="c">// handlerConfig 代表处理流程配置的类型。</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">handlerConfig</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">handler</span><span class="x">   </span><span class="n">singleHandler</span><span class="x"> </span><span class="c">// 单次处理函数。</span><span class="x">
    </span><span class="n">goNum</span><span class="x">     </span><span class="kt">int</span><span class="x">           </span><span class="c">// 需要启用的goroutine的数量。</span><span class="x">
    </span><span class="n">number</span><span class="x">    </span><span class="kt">int</span><span class="x">           </span><span class="c">// 单个goroutine中的处理次数。</span><span class="x">
    </span><span class="n">interval</span><span class="x">  </span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="x"> </span><span class="c">// 单个goroutine中的处理间隔时间。</span><span class="x">
    </span><span class="n">counter</span><span class="x">   </span><span class="kt">int</span><span class="x">           </span><span class="c">// 数据量计数器，以字节为单位。</span><span class="x">
    </span><span class="n">counterMu</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="x">    </span><span class="c">// 数据量计数器专用的互斥锁。</span><span class="x">

</span><span class="p">}</span><span class="x">

</span><span class="c">// count 会增加计数器的值，并会返回增加后的计数。</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">hc</span><span class="x"> </span><span class="o">*</span><span class="n">handlerConfig</span><span class="p">)</span><span class="x"> </span><span class="n">count</span><span class="p">(</span><span class="n">increment</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">hc</span><span class="o">.</span><span class="n">counterMu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">hc</span><span class="o">.</span><span class="n">counterMu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
    </span><span class="n">hc</span><span class="o">.</span><span class="n">counter</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="n">increment</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">hc</span><span class="o">.</span><span class="n">counter</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// mu 代表以下流程要使用的互斥锁。</span><span class="x">
    </span><span class="c">// 在下面的函数中直接使用即可，不要传递。</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">mu</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="x">

    </span><span class="c">// genWriter 代表的是用于生成写入函数的函数。</span><span class="x">
    </span><span class="n">genWriter</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">writer</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">Writer</span><span class="p">)</span><span class="x"> </span><span class="n">singleHandler</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="c">// 准备数据。</span><span class="x">
            </span><span class="n">data</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span><span class="x">
                </span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">StampNano</span><span class="p">))</span><span class="x">
            </span><span class="c">// 写入数据。</span><span class="x">
            </span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
            </span><span class="n">n</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">writer</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="x">
            </span><span class="k">return</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// genReader 代表的是用于生成读取函数的函数。</span><span class="x">
    </span><span class="n">genReader</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">reader</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span><span class="x"> </span><span class="n">singleHandler</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">buffer</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reader</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span><span class="x">
            </span><span class="k">if</span><span class="x"> </span><span class="o">!</span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"unsupported reader"</span><span class="p">)</span><span class="x">
                </span><span class="k">return</span><span class="x">
            </span><span class="p">}</span><span class="x">
            </span><span class="c">// 读取数据。</span><span class="x">
            </span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
            </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">buffer</span><span class="o">.</span><span class="n">ReadString</span><span class="p">(</span><span class="sc">'\t'</span><span class="p">)</span><span class="x">
            </span><span class="n">n</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="x">
            </span><span class="k">return</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// buffer 代表缓冲区。</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">buffer</span><span class="x"> </span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="x">

    </span><span class="c">// 数据写入配置。</span><span class="x">
    </span><span class="n">writingConfig</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">handlerConfig</span><span class="p">{</span><span class="x">
        </span><span class="n">handler</span><span class="o">:</span><span class="x">  </span><span class="n">genWriter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">),</span><span class="x">
        </span><span class="n">goNum</span><span class="o">:</span><span class="x">    </span><span class="m">5</span><span class="p">,</span><span class="x">
        </span><span class="n">number</span><span class="o">:</span><span class="x">   </span><span class="m">4</span><span class="p">,</span><span class="x">
        </span><span class="n">interval</span><span class="o">:</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="m">100</span><span class="p">,</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="c">// 数据读取配置。</span><span class="x">
    </span><span class="n">readingConfig</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">handlerConfig</span><span class="p">{</span><span class="x">
        </span><span class="n">handler</span><span class="o">:</span><span class="x">  </span><span class="n">genReader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">),</span><span class="x">
        </span><span class="n">goNum</span><span class="o">:</span><span class="x">    </span><span class="m">10</span><span class="p">,</span><span class="x">
        </span><span class="n">number</span><span class="o">:</span><span class="x">   </span><span class="m">2</span><span class="p">,</span><span class="x">
        </span><span class="n">interval</span><span class="o">:</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="m">100</span><span class="p">,</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// sign 代表信号的通道。</span><span class="x">
    </span><span class="n">sign</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="k">struct</span><span class="p">{},</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="o">+</span><span class="n">readingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="p">)</span><span class="x">

    </span><span class="c">// 启用多个goroutine对缓冲区进行多次数据写入。</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">sign</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="k">struct</span><span class="p">{}{}</span><span class="x">
            </span><span class="p">}()</span><span class="x">
            </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">number</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">writingConfig</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span><span class="x">
                </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">handler</span><span class="p">()</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"writer [%d-%d]: error: %s"</span><span class="p">,</span><span class="x">
                        </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x">
                    </span><span class="k">continue</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="n">total</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="x">
                </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"writer [%d-%d]: %s (total: %d)"</span><span class="p">,</span><span class="x">
                    </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">total</span><span class="p">)</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}(</span><span class="n">i</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// 启用多个goroutine对缓冲区进行多次数据读取。</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">sign</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="k">struct</span><span class="p">{}{}</span><span class="x">
            </span><span class="p">}()</span><span class="x">
            </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">number</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">readingConfig</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span><span class="x">
                </span><span class="k">var</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="x">
                </span><span class="k">var</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="x">
                </span><span class="k">var</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="x">
                </span><span class="k">for</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">handler</span><span class="p">()</span><span class="x">
                    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="o">||</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">EOF</span><span class="x"> </span><span class="p">{</span><span class="x">
                        </span><span class="k">break</span><span class="x">
                    </span><span class="p">}</span><span class="x">
                    </span><span class="c">// 如果读比写快（读时会发生EOF错误），那就等一会儿再读。</span><span class="x">
                    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">readingConfig</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"reader [%d-%d]: error: %s"</span><span class="p">,</span><span class="x">
                        </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x">
                    </span><span class="k">continue</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="n">total</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="x">
                </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"reader [%d-%d]: %s (total: %d)"</span><span class="p">,</span><span class="x">
                    </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">total</span><span class="p">)</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}(</span><span class="n">i</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// signNumber 代表需要接收的信号的数量。</span><span class="x">
    </span><span class="n">signNumber</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="x">
    </span><span class="c">// 等待上面启用的所有goroutine的运行全部结束。</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">signNumber</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="o">&lt;-</span><span class="n">sign</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 原子操作</title>
      <link href="http://localhost:4000/timegeekbang-go-sync-atomic/"/>
      <pubDate>2019-03-26T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-sync-atomic</guid>
      <content:encoded><![CDATA[<p>在众多的同步工具中，真正能够保证原子性执行的只有原子操作（atomic operation）。原子操作在进行的过程中是不允许中断的。在底层，这会由 CPU 提供芯片级别的支持。</p>

<p><strong>sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？</strong></p>

<p>sync/atomic包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。</p>

<p><strong>第一个衍生问题 ：</strong>我们都知道，传入这些原子操作函数的第一个参数值对应的都应该是那个被操作的值。比如，atomic.AddInt32函数的第一个参数，对应的一定是那个要被增大的整数。可是，这个参数的类型为什么不是int32而是*int32呢？</p>

<p>回答是：因为原子操作函数需要的是被操作值的指针，而不是这个值本身；被传入函数的参数值都会被复制，像这种基本类型的值一旦被.传入函数，就已经与函数外的那个值毫无关系了。</p>

<p>所以，传入值本身没有任何意义。unsafe.Pointer类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向的那个值，所以需要的仍然是指向这个指针值的指针。</p>

<p><strong>第二个衍生问题：</strong> 用于原子加法操作的函数可以做原子减法吗？比如，atomic.AddInt32函数可以用于减小那个被操作的整数值吗？</p>

<p>回答是：当然是可以的。atomic.AddInt32函数的第二个参数代表差量，它的类型是int32，是有符号的。如果我们想做原子减法，那么把这个差量设置为负整数就可以了。</p>

<p>对于atomic.AddUint64函数做原子减法，就不能这么直接了，因为它们的第二个参数的类型分别是uint32和uint64，都是无符号的。所以要做转换 uint32(int32(-3))。如果不这么做的话，可报错。还有一种更加考虑直接的方式可以传入^uint32(-N-1)</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">atomic</span><span class="o">.</span><span class="n">AddUint32</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="kt">uint32</span><span class="p">(</span><span class="kt">int32</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span><span class="x">
</span><span class="c">//或</span><span class="x">
</span><span class="n">atomic</span><span class="o">.</span><span class="n">AddUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="o">^</span><span class="kt">uint32</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

<p><strong>第三个衍生问题：</strong> 比较并交换操作与交换操作相比有什么不同？优势在哪里？</p>

<p>回答是：比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行值的交换。
所谓的交换指的是，把新值赋给变量，并返回变量的旧值。</p>

<p><strong>第四个衍生问题：</strong> 假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，，还有必要使用原子操作吗？</p>

<p>回答是：很有必要。如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。</p>

<p>** 问题：怎样用好sync/atomic.Value?**</p>

<p>atomic.Value类型是开箱即用的，我们声明一个该类型的变量（以下简称原子变量）之后就可以直接使用了。这个类型使用起来很简单，它只有两个指针方法：Store和Load。不过，虽然简单，但还是有一些值得注意的地方的。</p>

<p>1 一旦被真正的使用，就不应该被复制，atomic.Value类型属于结构体类型， 而结构体类型属于值类型。复制时会产生个一完全分离的新值。</p>

<p>2 不能用原子偷走一存储nil</p>

<p>3 向原子值存储的第一个值，决定了它今后能且只能在座哪一个类型的值。即使使用接口类型，然后再存储这个接口的某个实现类型的值，还是不可以的。</p>

<p><strong>使用建议：</strong></p>

<p>1 不要把内部使用的原子值暴露给外界</p>

<p>2 如果不和地不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数让外界间接地信息使用它。注意，这种情况下不要把原子值传递外界，不论是传递原子值本身还是它的指针值。</p>

<p>3 如果通过某个函数可以向内部民的原子值 存储的话，那么就应该在这个函数中先判断被存储值类型的合法性。</p>

<p>4 最好把原子值封装到一个数据类型中，比如结构体类型。</p>

<p>尽量不要向原子值中存储引用类型的值，容易造成安全漏洞。</p>

<p>扩展阅读：https://www.jianshu.com/p/228c119a7d0e</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 程序性能分析基本</title>
      <link href="http://localhost:4000/timegeekbang-go-pprof/"/>
      <pubDate>2019-03-25T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-pprof</guid>
      <content:encoded><![CDATA[<p>Go 语言为程序开发者们提供了丰富的性能分析 API和标准工具。这些主要存在于：</p>

<blockquote>
  <p>1 runtime/pprof</p>

  <p>2 net/http/pprof</p>

  <p>3 runtime/trace</p>
</blockquote>

<p>在 Go 语言中，用于分析程序性能的概要文件有三种，分别是CPU 概要文件（CPU Profile）、内存概要文件（Mem Profile）和阻塞概要文件（Block Profile）。</p>

<p>对于 CPU 概要文件来说，其中的每一段独立的概要信息都记录着，在进行某一次采样的那个时刻，CPU 上正在执行的Go 代码。</p>

<p>而对于内存概要文件，其中的每一段概要信息都记载着，在某个采样时刻，正在执行的 Go 代码以及堆内存的使用情况，这里包含已分配和已释放的字节数量和对象数量。至于阻塞概要文件，其中的每一段概要信息，都代表着 Go 程序中的一个 goroutine 阻塞事件。</p>

<p>这时就可以显现出go tool pprof这个工具的作用了。我们可以通过它进入一个基于命令行的交互式界面，并对指定的概要文件进行查阅。概要文件是protoclo buffer 方式存储的。</p>

<p><strong>怎样设定内存概要信息的采样频率？</strong></p>

<p>只要为<code class="highlighter-rouge">runtime.MemProfileRate</code>变量赋值即可。</p>

<p>这个变量的含义是，平均每分配多少个字节，就对堆内存的使用情况进行一次采样。如果把该变量的值设为0，那么，Go 语言运行时系统就会完全停止对内存概要信息的采样。该变量的缺省值是512 KB，也就是512千字节。</p>

<p>越早设置越好，在main 开始时就设置。之后，需要调用<code class="highlighter-rouge">runtime/pprof</code>包中的<code class="highlighter-rouge">WriteHeapProfile</code>函数。该函数会把收集好的内存概要信息，写到我们指定的写入器中。</p>

<p>注意，我们通过<code class="highlighter-rouge">WriteHeapProfile</code>函数得到的内存概要信息并不是实时的，它是一个快照，是在最近一次的内存垃圾收集工作完成时产生的。如果你想要实时的信息，那么可以调用<code class="highlighter-rouge">runtime.ReadMemStats</code>函数。不过要特别注意，该函数会引起 Go 语言调度器的短暂停顿。</p>

<p><strong>怎样获取到阻塞概要信息？</strong></p>

<p>我们调用runtime包中的<code class="highlighter-rouge">SetBlockProfileRate</code>函数，即可对阻塞概要信息的采样频率进行设定。该函数有一个名叫rate的参数，它是int类型的。</p>

<p>这个参数的含义是，只要发现一个阻塞事件的持续时间达到了多少个纳秒，就可以对其进行采样。如果这个参数的值小于或等于0，那么就意味着 Go 语言运行时系统将会完全停止对阻塞概要信息的采样。</p>

<p>还有一个名叫<code class="highlighter-rouge">blockprofilerate</code>的包级私有变量，它是uint64类型的。这个变量的含义是，只要发现一个阻塞事事件的持续时间跨越了多少个 CPU 时钟周期，就可以对其进行采样。</p>

<p>另一方面，当我们需要获取阻塞概要信息的时候，需要先调用runtime/pprof包中的Lookup函数并传入参数值”block”，从而得到一个*runtime/pprof.Profile类型的值（以下简称Profile值）。在这之后，我们还需要调用这个Profile值的WriteTo方法，以驱使它把概要信息写进我们指定的写入器中。</p>

<p><strong>runtime/pprof.Lookup函数的调用方式是什么？</strong></p>

<p><code class="highlighter-rouge">runtime/pprof.Lookup</code>函数（以下简称Lookup函数）的功能是，提供与给定的名称相对应的概要信息。这个概要信息会由一个Profile值代表。如果该函数返回了一个nil，那么就说明不存在与给定名称对应的概要信息。</p>

<p><code class="highlighter-rouge">runtime/pprof</code>包已经为我们预先定义了 6 个概要名称。它们对应的概要信息收集方法和输出方法也都已经准备好了。我们直接拿来使用就可以了。</p>

<p>它们是：<code class="highlighter-rouge">goroutine、heap、allocs、threadcreate、block和mutex</code>。</p>

<p><strong>问题 4：如何为基于 HTTP 协议的网络服务添加性能分析接口？</strong></p>

<p>这个问题说起来还是很简单的。这是因为我们在一般情况下只要在程序中导入net/http/pprof代码包就可以了，就像这样：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="s">"net/http/pprof"</span><span class="x">
</span></code></pre></div></div>
<p>然后，启动网络服务并开始监听，比如：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">"localhost:8082"</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 sync.WaitGroup和sync.Once</title>
      <link href="http://localhost:4000/timegeekbang-go-synWaitGroup/"/>
      <pubDate>2019-03-25T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-synWaitGroup</guid>
      <content:encoded><![CDATA[<p>sync.WaitGroup类型（以下简称WaitGroup类型）是开箱即用的，也是并发安全的。同时，它一旦被真正使用就不能被复制了。</p>

<p>WaitGroup类型拥有三个指针方法：Add、Done和Wait。你可以想象该类型中有一个计数器，它的默认值是0。我们可以通过调用该类型值的Add方法来增加，或者减少这个计数器的值。</p>

<p>一般情况下，我会用这个方法来记录需要等待的 goroutine 的数量。相对应的，这个类型的Done方法，用于对其所属值中计数器的值进行减一操作。我们可以在需要等待的 goroutine 中，通过defer语句调用它。</p>

<p>而此类型的Wait方法的功能是，阻塞当前的 goroutine，直到其所属值中的计数器归零。如果在该方法被调用的时候，那个计数器的值就是0，那么它将不会做任何事情。</p>

<p>sync.WaitGroup类型值中计数器的值可以小于0吗？</p>

<p>这里的典型回答是：不可以。</p>

<p>另外，你可能已经知道，WaitGroup值是可以被复用的，但需要保证其计数周期的完整性。这里的计数周期指的是这样一个过程：该值中的计数器值由0变为了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了0。</p>

<p>也就是说，只要计数器的值始于0又归为0，就可以被视为一个计数周期。在一个此类值的生命周期中，它可以经历任意多个计数周期。但是，只有在它走完当前的计数周期之后，才能够开始下一个计数周期。</p>

<p><img src="/assets/timegeekbang/go-sync.png" alt="" /></p>

<p>不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行。换句话说，要杜绝对同一个WaitGroup值的两种操作的并发执行。</p>

<p>问题：sync.Once类型值的Do方法是怎么保证只执行参数函数一次的？
与sync.WaitGroup类型一样，sync.Once类型（以下简称Once类型）也属于结构体类型，同样也是开箱即用和并发安全的。由于这个类型中包含了一个sync.Mutex类型的字段，所以，复制该类型的值也会导致功能的失效。</p>

<p>扩展：https://www.cnblogs.com/linyihai/p/10285437.html</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>源码阅读中一个特殊注释说明</title>
      <link href="http://localhost:4000/sourcecode-comment/"/>
      <pubDate>2018-09-17T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/sourcecode-comment</guid>
      <content:encoded><![CDATA[<p><strong>TODO: + 说明：</strong></p>

<p>如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</p>

<p><strong>FIXME: + 说明：</strong>
如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p>

<p><strong>XXX: + 说明：</strong>
如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go的竞争检测</title>
      <link href="http://localhost:4000/go-check-race/"/>
      <pubDate>2018-03-02T04:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-check-race</guid>
      <content:encoded><![CDATA[<p><code class="highlighter-rouge">go run -race</code> 或者 <code class="highlighter-rouge">go build -race</code> 来进行竞争检测。</p>

<p>golang语言内部大概的实现就是同时开启多个goroutine执行同一个命令，并且纪录每个变量的状态。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="p">(</span><span class="x">
    </span><span class="s">"time"</span><span class="x">
    </span><span class="s">"fmt"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="x">
    </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(){</span><span class="x">
        </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">2</span><span class="x">
    </span><span class="p">}()</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">3</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"a is "</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="p">)</span><span class="x">

    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>这个程序可以看出变量a出现了竞争。</p>

<p>在windows下执行</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go run: <span class="nt">-race</span> and <span class="nt">-msan</span> are only supported on linux/amd64, freebsd/amd64, darwin
/amd64 and windows/amd64
</code></pre></div></div>

<p>在linux下执行</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="x"> </span><span class="n">is</span><span class="x">  </span><span class="m">3</span><span class="x">
</span><span class="o">==================</span><span class="x">
</span><span class="n">WARNING</span><span class="o">:</span><span class="x"> </span><span class="n">DATA</span><span class="x"> </span><span class="n">RACE</span><span class="x">
</span><span class="n">Write</span><span class="x"> </span><span class="n">at</span><span class="x"> </span><span class="m">0x00c4200140a8</span><span class="x"> </span><span class="n">by</span><span class="x"> </span><span class="n">goroutine</span><span class="x"> </span><span class="m">6</span><span class="o">:</span><span class="x">
  </span><span class="n">main</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">func1</span><span class="p">()</span><span class="x">
      </span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">race</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">11</span><span class="x"> </span><span class="o">+</span><span class="m">0x3b</span><span class="x">

</span><span class="n">Previous</span><span class="x"> </span><span class="n">write</span><span class="x"> </span><span class="n">at</span><span class="x"> </span><span class="m">0x00c4200140a8</span><span class="x"> </span><span class="n">by</span><span class="x"> </span><span class="n">main</span><span class="x"> </span><span class="n">goroutine</span><span class="o">:</span><span class="x">
  </span><span class="n">main</span><span class="o">.</span><span class="n">main</span><span class="p">()</span><span class="x">
      </span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">race</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">13</span><span class="x"> </span><span class="o">+</span><span class="m">0x8e</span><span class="x">

</span><span class="n">Goroutine</span><span class="x"> </span><span class="m">6</span><span class="x"> </span><span class="p">(</span><span class="n">running</span><span class="p">)</span><span class="x"> </span><span class="n">created</span><span class="x"> </span><span class="n">at</span><span class="o">:</span><span class="x">
  </span><span class="n">main</span><span class="o">.</span><span class="n">main</span><span class="p">()</span><span class="x">
      </span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">race</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">10</span><span class="x"> </span><span class="o">+</span><span class="m">0x7d</span><span class="x">
</span><span class="o">==================</span><span class="x">
</span><span class="n">Found</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="n">race</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="n">exit</span><span class="x"> </span><span class="n">status</span><span class="x"> </span><span class="m">66</span><span class="x">
</span></code></pre></div></div>
<p><strong>13行 出现变量竞争。</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go build 时的错误分析</title>
      <link href="http://localhost:4000/go-build-error/"/>
      <pubDate>2018-03-01T19:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-build-error</guid>
      <content:encoded><![CDATA[<p>go build 程序时，如果出现：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>warning: building out-of-date packages:

runtime/pprof

testing

regexp/syntax

regexp

installing these packages with <span class="s1">'go test -i'</span> will speed future tests.
</code></pre></div></div>

<p>那么就是说明下面的包已经有修改过了，但是没有重新install</p>

<p>如果有标准的包过期，使用go install -a -v std来进行更新</p>

<p>如果是自定义的包过期，重新调用go install</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go gdb 编译</title>
      <link href="http://localhost:4000/go-gdb/"/>
      <pubDate>2018-03-01T18:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-gdb</guid>
      <content:encoded><![CDATA[<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go build <span class="nt">-gcflags</span> <span class="s2">"-N -l"</span> demo.go
</code></pre></div></div>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
