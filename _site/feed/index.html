<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2018-09-05T23:33:32+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>muduo笔记 第五章 高效的多线程日志</title>
      <link href="http://localhost:4000/muduo-5-threads-log/"/>
      <pubDate>2018-01-04T04:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-5- threads-log</guid>
      <content:encoded><![CDATA[<p><strong>“日志（logging）”有两个意思:</strong></p>

<p>1.诊断日志（diagnostic log） 　 即log4j、logback、slf4j、glog、g2log、log4cxx、log4cpp、log4cplus、Pantheios、ezlogger等常用日志库提供的日志功能。</p>

<p>2.交易日志（transaction log） 　即数据库的write-ahead log 1 、文件系统的journaling 2 等，用于记录状态变更，通过回放日志可以逐步恢复每一次修改之后的状态。</p>

<p>本章的”日志”是前一个意思，即文本的、供人阅读的日志，通常用于故障诊断和追踪（trace） ，也可用于性能分析。</p>

<p>日志通常是分布式系统中事故调查时的唯一线索，用来追寻蛛丝马迹，查出元凶。</p>

<p>在服务端编程中，日志是必不可少的，在生产环境中应该做到”Log Everything All The Time” 。对于关键进程，日志通常要记录:</p>

<ul>
  <li>收到的每条内部消息的id（还可以包括关键字段、长度、hash等）；</li>
  <li>收到的每条外部消息的全文；</li>
  <li>发出的每条消息的全文，每条消息都有全局唯一的id；</li>
  <li>关键内部状态的变更，等等。</li>
</ul>

<h4 id="c日志库的前端大体上有两种api风格">C++日志库的前端大体上有两种API风格：</h4>

<p>C/Java的<code class="highlighter-rouge">printf(fmt, ...)</code>风格，例如 <code class="highlighter-rouge">log_info("Received %d bytes from %s", len, getClientName().c_str());</code></p>

<p>C++的<code class="highlighter-rouge">stream &lt;&lt;</code> 风格，例如 <code class="highlighter-rouge">LOG_INFO &lt;&lt; "Received " &lt;&lt; len &lt;&lt; " bytes from " &lt;&lt; getClientName();</code></p>

<p>muduo日志库是C++ stream风格的另一个好处是当输出的日志级别高于语句的日志级别时，打印日志是个空操作, 运行时开销接近零。
比方说当日志级别为WARNING时，<code class="highlighter-rouge">LOG_INFO &lt;&lt;</code>是空操作，这个语句根本不会调用<code class="highlighter-rouge">std::string getClientName()</code>函数，减小了开销。而printf风格不易做到这一点。</p>

<p>可以看这篇文章 <a href="http://www.drdobbs.com/cpp/logging-in-c/201804215">Logging In C++</a></p>

<h4 id="性能需求">性能需求</h4>

<p>编写Linux服务端程序的时候，我们需要一个高效的日志库。只有日志库足够高效，程序员才敢在代码中输出足够多的诊断信息，减小运维难度，提升效率。</p>

<p>高效性体现在几方面：</p>

<ul>
  <li>每秒写几千上万条日志的时候没有明显的性能损失。</li>
  <li>能应对一个进程产生大量日志数据的场景，例如1GB/min。</li>
  <li>不阻塞正常的执行流程。</li>
  <li>在多线程程序中，不造成争用（contention）。</li>
</ul>

<p>这里列举一些具体的性能指标，考虑往普通7200rpm SATA硬盘写日志文件的情况：</p>

<p>磁盘带宽约是110MB/s，日志库应该能瞬时写满这个带宽（不必持续太久）。</p>

<p>假如每条日志消息的平均长度是110字节，这意味着1秒要写100万条日志。</p>

<p>关于日志之前写过另一篇。可以看<a href="http://blog.xyecho.com/model-log/">日志模块</a>.</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>muduo笔记 第四章 c++多线程系统编程精要</title>
      <link href="http://localhost:4000/muduo-4-threads/"/>
      <pubDate>2018-01-04T04:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-4- threads</guid>
      <content:encoded><![CDATA[<p>学习多线程编程面临的最大的思维方式的转变有两点：</p>

<ul>
  <li>当前线程可能随时会被切换出去，或者说被抢占（preempt）了。</li>
  <li>多线程程序中事件的发生顺序不再有全局统一的先后关系 1 。</li>
</ul>

<h4 id="基本线程原语的选用">基本线程原语的选用</h4>

<p>POSIX threads的函数有110多个，真正常用的不过十几个。而且在C++程序中通常会有更为易用的wrapper，不会直接调用Pthreads函数。这11个最基本的Pthreads函数是：</p>

<ul>
  <li>2个：线程的创建和等待结束（join）。封装为muduo::Thread。</li>
  <li>4个：mutex的创建、销毁、加锁、解锁。封装为muduo::MutexLock。</li>
  <li>5个：条件变量的创建、销毁、等待、通知、广播。封装为muduo::Condition。</li>
</ul>

<p>这些封装class都很直截了当，加起来也就一两百行代码，却已经构成了多线程编程的全部必备原语。用这三样东西（thread、mutex、condition）可以完成任何多线程编程任务。</p>

<h4 id="cc系统库的线程安全性">c/c++系统库的线程安全性</h4>

<p>c++11宣言了一个线程库。（std::thread）
对于标准而言，关键的不是定义线程库，而是规定内存模型（memory model）。特别是规定一个线程对某个共享变量的修改何时能被其他线程看到，这称为内存序（memory ordering）或者内存能见度（memory visibility）。</p>

<p><strong>[这句话有三个名词：内存模型，内存有序，内存能见度。可以查找这方面的资料。]</strong></p>

<p>编写线程安全程序的一个难点在于线程安全是不可组合的（composable），一个函数foo()调用了两个线程安全的函数，而这个foo()函数本身很可能不是线程安全的。即便现在大多数glibc库函数是线程安全的，我们也不能像写单线程程序那样编写代码。</p>

<p>C++的标准库容器和std::string都不是线程安全的，只有std::allocator保证是线程安全的。一方面的原因是为了避免不必要的性能开销，另一方面的原因是单个成员函数的线程安全并不具备可组合性（composable）</p>

<h4 id="linux上的线程标识">Linux上的线程标识</h4>

<p>pthread_t并不适合用作程序中对线程的标识符。 pthread_t不一定是一个数值类型（整数或指针），也有可能是一个结构体</p>

<p>无法打印输出pthread_t，因为不知道其确切类型。也就没法在日志中用它表示当前线程的id。</p>

<p>无法比较pthread_t的大小或计算其hash值，因此无法用作关联容器的key。</p>

<p>无法定义一个非法的pthread_t值，用来表示绝对不可能存在的线程id，因此MutexLock class没有办法有效判断当前线程是否已经持有本锁。</p>

<p>pthread_t值只在进程内有意义，与操作系统的任务调度之间无法建立有效关联。比方说在/proc文件系统中找不到pthread_t对应的task。</p>

<p>在Linux上，我建议使用gettid(2)系统调用的返回值作为线程id，这么做的好处有：</p>

<p>它的类型是pid_t，其值通常是一个小整数 13 ，便于在日志中输出。</p>

<p>在现代Linux中，它直接表示内核的任务调度id，因此在/proc文件系统中可以轻易找到对应项：/proc/tid或/prod/pid/task/tid。</p>

<p>在其他系统工具中也容易定位到具体某一个线程，例如在top(1)中我们可以按线程列出任务，然后找出CPU使用率最高的线程id，再根据程序日志判断到底哪一个线程在耗用CPU。</p>

<p>任何时刻都是全局唯一的，并且由于Linux分配新pid采用递增轮回办法，短时间内启动的多个线程也会具有不同的线程id。</p>

<p>0是非法值，因为操作系统第一个进程init的pid是1。</p>

<h4 id="线程的创建与销毁的守则">线程的创建与销毁的守则</h4>

<p>线程的创建比销毁要容易得多，只需要遵循几条简单的原则：</p>

<ul>
  <li>程序库不应该在未提前告知的情况下创建自己的“背景线程”。</li>
  <li>尽量用相同的方式创建线程，例如muduo::Thread。</li>
  <li>在进入main()函数之前不应该启动线程。 ·程序中线程的创建最好能在初始化阶段全部完成。（C++保证在进入main()之前完成全局对象 ）</li>
</ul>

<h4 id="线程的销毁有几种方式-">线程的销毁有几种方式 ：</h4>

<ul>
  <li>自然死亡。从线程主函数返回，线程正常退出。</li>
  <li>非正常死亡。从线程主函数抛出异常或线程触发segfault信号等非法操作 。</li>
  <li>自杀。在线程中调用pthread_exit()来立刻退出线程。</li>
  <li>他杀。其他线程调用pthread_cancel()来强制终止某个线程。</li>
</ul>

<h4 id="善用__thread关键字">善用__thread关键字</h4>

<p>__thread使用规则27：只能用于修饰POD类型，不能修饰class类型， 因为无法自动调用构造函数和析构函数。__thread可以用于修饰全局变量、函数内的静态变量，但是不能用于修饰函数的局部变量或者class的普通成员变量。另外，__thread变量的初始化只能用编译期常量。</p>

<p>例如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">__thread</span> <span class="n">string</span> <span class="n">t_obj1</span><span class="p">(</span><span class="s">"Chen Shou"</span><span class="p">);</span>    <span class="c1">// 错误 不能对象的构造函数</span>
<span class="kr">__thread</span> <span class="n">string</span> <span class="o">*</span> <span class="n">t_obj2</span><span class="o">=</span> <span class="n">new</span> <span class="n">string</span><span class="p">;</span>   <span class="c1">// 错误 初始化必须用编译期常量</span>
<span class="kr">__thread</span> <span class="n">string</span> <span class="o">*</span> <span class="n">t_obj3</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>         <span class="c1">// 正常 但是需要手工初始化并销毁对象</span>

</code></pre></div></div>
<p>__thread变量是每个线程有一份独立实体，各个线程的变量值互不干扰。除了这个主要用途， 它还可以修饰那些”值可能会变，带有全局性，但是又不值得用全局锁保护”的变量。muduo代码中用到了 好几处__thread，简单列举如下：</p>

<ul>
  <li>muduo/base/Logging.cc 缓存最近一条日志时间的年月日时分秒，如果一秒之内输出多条日志，可避免重复格式化。另外，muduo::strerror_tl把strerror_r(3)做成如同strerror(3)一样好用，而且是线程安全的。</li>
  <li>muduo/base/ProcessINfo.cc 用线程局部变量来简化<code class="highlighter-rouge">::scandir(3)</code>的使用。</li>
  <li>muduo/base/Thread.cc 缓存每个线程的id。</li>
  <li>用于判断当前线程是否只有一个EventLoop对象。</li>
</ul>

<h4 id="多线程与io">多线程与IO</h4>

<p>为了简单起见，我认为多线程程序应该遵循的原则是：每个文件描述符只由一个线程操作，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种race condition。 一个线程可以操作多个文件描述符， 但一个线程不能操作别的线程拥有的文件描述符。 这一点不难做到， muduo网络库已经把这些细节封装了。</p>

<h4 id="raii与fork">RAII与fork()</h4>

<p>通常我们会用RAII手法来管理以上种类的资源(加锁解锁、创建销毁定时器等等).</p>

<p>但是在fork()出来的子进程中不一定正常工作，因为资源在fork()时已经被释放了。比方说用RAII技法封装timer_create()/timer_delete()，在子进程中析构函数调用timer_delete()可能会出错。</p>

<p>因为试图释放一个不存在的资源。或者更糟糕地把其他对象持有的timer给释放了（如果碰巧新建的timer_t与之重复的话）。</p>

<h4 id="多线程与fork">多线程与fork()</h4>

<p>fork()是单线程的产物。当有了多线程之后，fork()就变得有一些不适应了。</p>

<p>fork()一般不能在多线程程序中调用 ，因为Linux的fork()只克隆当前线程的thread of control，不克隆其他线程。</p>

<p>fork()之后，除了当前线程之外，其他线程都消失了。也就是说不能一下子fork()出一个和父进程一样的多线程子进程。</p>

<p>Linux没有forkall()这样的系统调用，forkall()其实也是很难办的（从语意上），因为其他线程可能等在condition。</p>

<p>所以最好不要在多线程当中调用fork(),除非你调用后马上调用exec()。彻底断了子进程和父进程的关系。</p>

<h4 id="多线程与signal">多线程与signal</h4>

<p>在多线程程序中， 使用signal的第一原则是不要使用signal。</p>

<p>关于多线程与signal关系。可以看<a href="http://blog.xyecho.com/linux-signal/">linux signal and threads</a></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>muduo笔记 第三章 多线程服务器的适用场合与常用编程模型</title>
      <link href="http://localhost:4000/muduo-3-threads/"/>
      <pubDate>2018-01-04T03:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-3- threads</guid>
      <content:encoded><![CDATA[<p>“网络应用程序” 的基本功能可以简单归纳为”收到数据，算一算，再发出去”。</p>

<h4 id="单线程服务器的常用编程模型">单线程服务器的常用编程模型</h4>

<p>在高性能的网络程序中，使用得最为广泛的是“non-blocking IO＋IO multiplexing”这种模型，即Reactor模式。</p>

<ul>
  <li>lighttpd，单线程服务器。（Nginx与之类似，每个工作进程有一个event loop。）</li>
  <li>libevent，libev。</li>
  <li>ACE，Poco C++ libraries。</li>
  <li>Java NIO，包括Apache Mina和Netty。</li>
  <li>POE（Perl）。</li>
  <li>Twisted（Python）。</li>
</ul>

<p>在”non-blocking IO＋IO multiplexing”这种模型中，程序的基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑：</p>

<p><img src="/assets/muduo/3-threads.png" alt="" /></p>

<p><strong>gethostbyname(3)是阻塞的，对陌生域名解析的耗时可长达数秒。</strong></p>

<p>基于事件驱动的编程模型也有其本质的缺点，它要求事件回调函数必须是非阻塞的。对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护。现代的语言有一些应对方法（例如coroutine 协程），但是本书只关注C++这种传统语言，因此就不展开讨论了。<strong>[后继可以看看协程方面技术和GO的]</strong></p>

<h4 id="多线程服务器的常用编程模型">多线程服务器的常用编程模型</h4>

<h5 id="1-one-loop-per-thread">1 One loop per thread</h5>

<p>此种模型下，程序里的每个IO线程有一个event loop（或者叫Reactor），用于处理读写和定时事件（无论周期性的还是单次的）。</p>

<p>这种方式的好处是：</p>

<ul>
  <li>线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁。</li>
  <li>可以很方便地在线程间调配负载。</li>
  <li>IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发。</li>
</ul>

<h5 id="2-线程池">2 线程池</h5>

<h5 id="3-推荐的服务模式">3 推荐的服务模式</h5>

<p>推荐的C++多线程服务端编程模式为：one (event) loop per thread+ thread pool。</p>

<h5 id="4-进程间通信只用tcp">4 进程间通信只用TCP</h5>

<p>Linux下进程间通信（IPC）的方式数不胜数，有：匿名管道（pipe）、具名管道（FIFO）、POSIX消息队列、共享内存、信号（signals），Sockets。其实贵精不贵多，认真用熟其中几种就可以。之所以选择socket是因为它可以跨主机，具有伸缩性。另外：</p>

<p>1.程序上意外退出， 不会组系统留下垃圾，程序重启之后比较容易地恢复。</p>

<p>2.port是独占，可以防止程序重复启动，避免造成意料之外的结果。</p>

<p>3.当一个进程崩溃了，操作系统会关闭连接，另一个进程可立刻感知。，可快速处理。（有心跳的情况）</p>

<p>4.还可以跨语言。</p>

<p>5.会涉及用字节流方式通信。会有marshal/unmarshal的开销。</p>

<p>6.用tcp的好处。容易定位分布式系统中的服务之前的依赖关系，<code class="highlighter-rouge">netstat -tpna | grep :port</code> 二通过接收和发送队列的长度也较容易定位网络 或程序故障。</p>

<p>在正常运行的时候，netstat打印的Recv-Q和Send-Q都应该接近0，或者在0附近摆动。</p>

<p>如果Recv-Q保持不变或持续增加，则通常意味着服务进程的处理速度变慢，可能发生了死锁或阻塞。</p>

<p>如果Send-Q保持不变或持续增加，有可能是对方服务器太忙、来不及处理，也有可能是网络中间某个路由器或交换机故障造成丢包，甚至对方服务器掉线，</p>

<p>这些因素都可能表现为数据发送不出去。通过持续监控Recv-Q和Send-Q就能及早预警性能或可用性故障。以下是服务端线程阻塞造成Recv-Q和客户端Send-Q激增的例子。</p>

<h4 id="多线程服务的适用应用">多线程服务的适用应用</h4>

<p>开发服务端程序的一个基本任务是处理并发连接，现在服务端网络编程处理并发连接主要有两种方式：</p>

<p>当”线程”很廉价时，一台机器上可以创建远高于CPU数目的”线程”。这时一个线程只处理一个TCP连接（甚至半个），通常使用阻塞IO（至少看起来如此）。例如，Python gevent、Go goroutine、</p>

<p>Erlang actor。这里的”线程”由语言的runtime自行调度，与操作系统线程不是一回事。（也就是说协程做并发是可以用阻塞IO的）</p>

<p>当线程很宝贵时，一台机器上只能创建与CPU数目相当的线程。这时一个线程要处理多个TCP连接上的IO，通常使用非阻塞IO和IO multiplexing。例如，libevent、muduo、Netty。这是原生线程，能被操作系统的任务调度器看见。</p>

<h4 id="必须用单线程的场合">必须用单线程的场合</h4>

<p>有两种场合必须使用单线程：</p>

<ul>
  <li>程序可能会fork</li>
  <li>限制程序的CPU占用率</li>
</ul>

<h5 id="单线程程序的优缺点">单线程程序的优缺点：</h5>

<p>单线程程序的优势：简单。程序的结构一般可是一个基于IO multiplexing的event loop。或者直接用阻塞IO。event loop也有一个明显的缺点：非抢占的。</p>

<p>多线程没有什么绝对意义上的性能优势。 这句话是说，如果用很少的CPU负载就能让IO跑满，或者用很少的IO流量就能让CPU跑满，那么多线程没啥用处。</p>

<p>多线程的适用场景是：提高响应速度，让IO和”计算”相互重叠，降低latency。虽然多线程不能提高绝对性能，但能提高平均响应性能。</p>

<h4 id="线程的分类">线程的分类</h4>

<p>一个多线程服务程序中的线程大致可分为3类：</p>

<p>1.IO线程，这类线程的主循环是IO multiplexing，阻塞地等在select/poll/epoll_wait系统调用上。这类线程也处理定时事件。当然它的功能不止IO，有些简单计算也可以放入其中，比如消息的编码或解码。</p>

<p>2.计算线程，这类线程的主循环是blockingqueue，阻塞地等在conditionvariable上。这类线程一般位于thread pool中。这种线程通常不涉及IO，一般要避免任何阻塞操作。</p>

<p>3.第三方库所用的线程，比如logging，又比如database connection。</p>

<h4 id="linux-能同时启动多少个线程">Linux 能同时启动多少个线程</h4>

]]></content:encoded>
    </item>
    
    <item>
      <title>muduo笔记 第二章 线程同步精要</title>
      <link href="http://localhost:4000/muduo-2-threads/"/>
      <pubDate>2018-01-04T02:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-2- threads</guid>
      <content:encoded><![CDATA[<h4 id="二-不要用读写锁和信号量">二 不要用读写锁和信号量</h4>

<p>理由是什么？</p>

<h5 id="读写锁">读写锁</h5>

<p>1.在后期的维护阶段，程序员可能在读的状态(read lock)写入共享数据。</p>

<p>2.从性能方面，读写锁并没有比mutex高效多少。如果临界区很小，锁竞争不是很激烈。mutex可能会更好。</p>

<p>3.通常read lock是可重入。writer lock是不可重入。但是为了防止writer饥饿，writer lock通常会阻塞后来的reader lock，因此reader lock在重入的时候可能死锁。</p>

<h5 id="信号量">信号量</h5>

<p>1.条件变量配合互斥器可以完全替代信号量。</p>

<p>2.信号量的另一个问题在于它有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。</p>

<p>3.信号量允许多个线程同时进入临界区。</p>

<h4 id="三线程安全的singleton实现">三　线程安全的Singleton实现</h4>

<p>一开始一度认为double checked locking是王道。但后来有人指出由于乱序执行的影响，DCL是靠不住的。</p>

<p>在实践中运用pthread_once就可以了。c++11 中用std::call_once （pthread_once单例模式）</p>

<h4 id="四sleep3不是同步原语">四　sleep(3)不是同步原语</h4>
<p>sleep()/usleep()/nanosleep()只能出现在测试代码中，比如写单元测试的时候 ；或者用于有意延长临界区，加速复现死锁的情况。</p>

<p>sleep不具备memory barrier（内存屏障）语义，它不能保证内存的可见性。</p>

<p>在程序的正常执行中，如果需要等待一段已知的时间，应该往event loop里注册一个timer，然后在timer的回调函数里接着干活，因为线程是个珍贵的共享资源，不能轻易浪费（阻塞也是浪费）。如果等待某个事件发生，那么应该采用条件变量或IO事件回调，不能用sleep来轮询。</p>

<p>如果多线程的安全性和效率要靠代码主动调用sleep来保证，这显然是设计出了问题。等待某个事件发生，正确的做法是用select()等价物或Condition，抑或（更理想地）高层同步工具；在用户态做轮询（polling）是低效的。</p>

<h4 id="五总结">五　总结</h4>

<p>线程同步的原则</p>

<ul>
  <li>尽量用高层同步设施（线程池、队列、倒计时）</li>
  <li>使用普通互斥器和条件变量完成剩余的同步任务，</li>
  <li>采用RAII惯用手法（idiom）和Scoped Locking。</li>
</ul>

<p>用好这几样东西，基本上就能应付多线程服务端开发的各种场合。或许有人会觉得性能没有发挥到极致。我认为，应该先把程序写正确（并尽量保持清晰和简单），然后再考虑性能优化，如果确实还有必要优化的话。这在多线程下仍然成立。让一个正确的程序变快，远比”让一个快的程序变正确”容易得多。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>muduo笔记 第一章 线程安全的对象生命期管理</title>
      <link href="http://localhost:4000/muduo-1-threads/"/>
      <pubDate>2018-01-04T00:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-1- threads</guid>
      <content:encoded><![CDATA[<h4 id="11当析构函数遇到多线程">1.1　当析构函数遇到多线程</h4>

<p>C++要求程序员自己管理对象的生命期，这在多线程环境下显得尤为困难。当一个对象能被多个线程同时看到时，那么对象的销毁时机就会变得模糊不清，可能出现多种竞态条件（race condition）：
在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数？</p>

<p>如何保证在执行成员函数期间，对象不会在另一个线程被析构？</p>

<p>在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？</p>

<p>解决这些race condition是C++多线程编程面临的基本问题。本文试图以shared_ptr一劳永逸地解决这些问题，减轻C++多线程编程的精神负担。</p>

<h5 id="111线程安全的定义">1.1.1　线程安全的定义</h5>

<p>依据[JCP]，一个线程安全的class应当满足以下三个条件：</p>

<ul>
  <li>多个线程同时访问时，其表现出正确的行为。</li>
  <li>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织（interleaving）。</li>
  <li>调用端代码无须额外的同步或其他协调动作。</li>
</ul>

<p>依据这个定义，C++标准库里的大多数class都不是线程安全的，包括std:: string、std::vector、std::map等，因为这些class通常需要在外部加锁才能供多个线程同时访问。</p>

<h4 id="12对象的创建很简单">1.2　对象的创建很简单</h4>

<p>对象构造要做到线程安全，唯一的要求是在构造期间不要泄露this指针，即</p>

<ul>
  <li>不要在构造函数中注册任何回调；</li>
  <li>也不要在构造函数中把this传给跨线程的对象；</li>
  <li>即便在构造函数的最后一行也不行。</li>
</ul>

<p>之所以这样规定，是因为在构造函数执行期间对象还没有完成初始化，如果this被泄露（escape）给了其他对象（其自身创建的子对象除外），那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果。</p>

<h4 id="13销毁太难">1.3　销毁太难</h4>

<p>成员函数用来保护临界区的互斥器本身必须是有效的。而析构函数破坏了这一假设，它会把mutex成员变量销毁掉。</p>

<h4 id="14线程安全的observer有多难">1.4　线程安全的Observer有多难</h4>

<p>那么似乎一个简单的解决办法是：只创建不销毁。程序使用一个对象池来暂存用过的对象，下次申请新对象时，如果对象池里有存货，就重复利用现有的对象，否则就新建一个。对象用完了，不是直接释放掉，而是放回池子里。这个办法当然有其自身的很多缺点，但至少能避免访问失效对象的情况发生。（这一种就是很常用的对象池）</p>

<p><strong>这种山寨办法的问题有：</strong></p>

<ul>
  <li>对象池的线程安全，如何安全地、完整地把对象放回池子里，防止出现“部分放回”的竞态？（线程A认为对象x已经放回了，线程B认为对象x还活着。）</li>
  <li>全局共享数据引发的lock contention，这个集中化的对象池会不会把多线程并发的操作串行化？</li>
  <li>如果共享对象的类型不止一种，那么是重复实现对象池还是使用类模板？ ·会不会造成内存泄漏与分片？因为对象池占用的内存只增不减，而且多个对象池不能共享内存（想想为何）。</li>
</ul>

<h4 id="16神器shared_ptrweak_ptr">1.6　神器shared_ptr/weak_ptr</h4>

<p><code class="highlighter-rouge">shared_ptr</code>控制对象的生命期。shared_ptr是强引用（想象成用铁丝绑住堆上的对象），只要有一个指向x对象的shared_ptr存在，该x对象就不会析构。当指向对象x的最后一个shared_ptr析构或reset()的时候，x保证会被销毁。</p>

<p><code class="highlighter-rouge">weak_ptr</code>不控制对象的生命期，但是它知道对象是否还活着（想象成用棉线轻轻拴住堆上的对象）。如果对象还活着，那么它可以提升（promote）为有效的shared_ptr；如果对象已经死了，提升会失败，返回一个空的shared_ptr。“提升／lock()”行为是线程安全的。</p>

<p>shared_ptr/weak_ptr的“计数”在主流平台上是原子操作，没有用锁，性能不俗。</p>

<p>shared_ptr/weak_ptr的线程安全级别与std::string和STL容器一样，后面还会讲。</p>

<h4 id="17插曲系统地避免各种指针错误">1.7　插曲：系统地避免各种指针错误</h4>

<p>C++里可能出现的内存问题大致有这么几个方面：</p>

<ul>
  <li>缓冲区溢出（buffer overrun）。</li>
  <li>空悬指针／野指针。</li>
  <li>重复释放（double delete）。</li>
  <li>内存泄漏（memory leak）。</li>
  <li>不配对的new[]/delete。</li>
  <li>内存碎片（memory fragmentation）。</li>
</ul>

<p>正确使用智能指针能很轻易地解决前面5个问题，解决第6个问题需要别的思路，</p>

<ul>
  <li>缓冲区溢出：用std::vector<char>/std::string或自己编写Buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。</char></li>
  <li>空悬指针／野指针：用shared_ptr/weak_ptr，这正是本章的主题。</li>
  <li>重复释放：用scoped_ptr，只在对象析构的时候释放一次。</li>
  <li>内存泄漏：用scoped_ptr，对象析构的时候自动释放内存。</li>
  <li>不配对的new[]/delete：把new[]统统替换为std::vector/scoped_array。</li>
</ul>

<h4 id="19再论shared_ptr的线程安全">1.9　再论shared_ptr的线程安全</h4>

<p>虽然我们借shared_ptr来实现线程安全的对象释放，但是shared_ptr本身不是100％线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为shared_ptr有两个数据成员，读写操作不能原子化。</p>

<p>根据文档 11 ，shared_ptr的线程安全级别和内建类型、标准库容器、std::string一样，即： ·一个shared_ptr对象实体可被多个线程同时读取；</p>

<ul>
  <li>两个shared_ptr对象实体可以被两个线程同时写入，”析构”算写操作；</li>
  <li>如果要从多个线程读写同一个shared_ptr对象，那么需要加锁。</li>
</ul>

<p>请注意，以上是shared_ptr对象本身的线程安全级别，不是它管理的对象的线程安全级别。</p>

<p>要在多个线程中同时访问同一个shared_ptr，正确的做法是用mutex保护。</p>

<h3 id="110shared_ptr技术与陷阱">1.10　shared_ptr技术与陷阱</h3>

<ol>
  <li>一个出错的可能是boost::bind，因为boost::bind会把实参拷贝一份，如果参数是个shared_ptr，那么对象的生命期就不会短于boost::function对象：</li>
  <li>函数参数 因为要修改引用计数（而且拷贝的时候通常要加锁），shared_ptr的拷贝开销比拷贝原始指针要高，但是需要拷贝的时候并不多。多数情况下它可以以const reference方式传递，一个线程只需要在最外层函数有一个实体对象，之后都可以用const reference来使用这个shared_ptr。</li>
</ol>

<p>遵照这个规则，基本上不会遇到反复拷贝shared_ptr导致的性能问题。另外由于pFoo是栈上对象，不可能被别的线程看到，那么读取始终是线程安全的。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>stl set 笔记</title>
      <link href="http://localhost:4000/stl-set/"/>
      <pubDate>2017-04-02T06:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/stl-set</guid>
      <content:encoded><![CDATA[<p>1.map和set都封闭了二叉树。所以set中的元素是有惟一性的。</p>

<p>2.set multiset map multimap内部采用的都是红黑树。</p>

<p>3.在set中查找 是使用地二分查找。logn。 效率很高。</p>

<p>4.set元素中排序的。</p>

<p>5.set对象的创建方式有5种。</p>

<ul>
  <li>创建空的set对象，元素类型为int set<int> sl;</int></li>
  <li>创建空的set对象，元素类型cahr <em>, 比较函数对象（即排序准则）为自定义 set&lt;const char</em> ， strLess&gt; s2(strLess);</li>
  <li>利用set对象S1,拷贝生成set对象S2；set<int>s2(s1);</int></li>
  <li>用迭代区间[&amp;first, &amp;laist)rn所指的元素，创建一个set对象。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span>  <span class="n">iArray</span><span class="p">[]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">19</span> <span class="p">);</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s4</span><span class="p">(</span><span class="n">iArray</span><span class="p">,</span> <span class="n">iArray</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>

</code></pre></div></div>

<ul>
  <li>用迭代区间[&amp;first, &amp;laist)rn所指的元素，及比较函数对象strLess, 创建一个set对象。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">szArray</span><span class="p">[]</span> <span class="o">=</span> <span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"dog"</span><span class="p">,</span> <span class="s">"bird"</span><span class="p">)</span> <span class="p">;</span>
   <span class="n">set</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">strLess</span><span class="o">&gt;</span> <span class="n">s5</span><span class="p">(</span><span class="n">szArray</span><span class="p">,</span> <span class="n">szArray</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">strLess</span><span class="p">());</span>
</code></pre></div></div>

<p>6.元素插入的3种方式。</p>

<ul>
  <li>插入value，返回pair 配对对象，可能根据，secod判断是否插入成功。（value不能与set容器内元素重复）</li>
  <li>在pos位置之前插入value，返回新元素的位置，但不一琮能插入成功。</li>
  <li>将换代区间[&amp;first, &amp;last) 内所有元素，插入到set容器。</li>
</ul>

<p>7.元素删除的4种方式。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">size_type</span> <span class="n">erase</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>      <span class="c1">// 移除set容器内元素值为value的所有元素。返回移除的元素个数。</span>
<span class="kt">void</span> <span class="n">erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">)</span>            <span class="c1">// 移除pos位置上的元素，无返回值。</span>
<span class="kt">void</span> <span class="n">earse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">last</span><span class="p">)</span>  <span class="c1">// 移除迭代区间[&amp;first, &amp;last)内的元素，无返回值。</span>
<span class="kt">void</span> <span class="n">clear</span><span class="p">()</span>                <span class="c1">// 移除set容器内所有元素。</span>
</code></pre></div></div>

<p>8.元素查找的2种方式</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">count</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1">// 返回set对象内元素值为value的元素个数。</span>
<span class="n">iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1">// 返回value所在位置，找不到value将返回end()。</span>
</code></pre></div></div>

<p>9.其他set中的常用方法。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">begin</span><span class="p">()</span>    <span class="c1">// 返回set容器的第一个元素</span>
<span class="n">end</span><span class="p">()</span>      <span class="c1">// 返回set窗口的最后一个元素</span>
<span class="n">clear</span><span class="p">()</span>    <span class="c1">// 删除set容器中的所有元素</span>
<span class="n">empty</span><span class="p">()</span>    <span class="c1">// 判断set是否空空 </span>
<span class="n">max_size</span><span class="p">()</span> <span class="c1">// 返回set容器可能包含的元素最大个数</span>
<span class="n">size</span><span class="p">()</span>     <span class="c1">// 返回当前set容器中的元素个数</span>
<span class="n">rbegin</span><span class="p">()</span>   <span class="c1">// 返回set窗口的最后一个元素</span>
<span class="n">rend</span><span class="p">()</span>     <span class="c1">// 返回set容器的第一个元素</span>
</code></pre></div></div>

<h5 id="注">[注]</h5>

<p>1.auto pos = setOder,find(tmp); 得到 *pos 是 const 类型，不能改变。 要用<code class="highlighter-rouge">const_cast</code>做强制转换。</p>

<p>工作中遇到过的代码（手游排行模块）</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>    <span class="n">_stTopListOrder</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">getSortType</span><span class="p">()</span> <span class="o">=</span> <span class="n">stSortType</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">_pos</span> <span class="o">=</span> <span class="n">m_setTopListOrder</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">_pos</span> <span class="o">==</span> <span class="n">m_setTopListOrder</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>  <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">uOrder</span> <span class="o">=</span> <span class="n">uOrder</span><span class="p">;</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">uOldOrder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_setTopListOrder</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="n">_stTopListOrder</span><span class="o">&amp;</span> <span class="n">stOrder</span> <span class="o">=</span> <span class="o">*</span><span class="n">_pos</span><span class="p">;</span>
		<span class="k">const_cast</span><span class="o">&lt;</span><span class="n">_stTopListOrder</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">stOrder</span><span class="p">).</span><span class="n">uOldOrder</span> <span class="o">=</span> <span class="n">stOrder</span><span class="p">.</span><span class="n">uOrder</span><span class="p">;</span>
		<span class="k">const_cast</span><span class="o">&lt;</span><span class="n">_stTopListOrder</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">stOrder</span><span class="p">).</span><span class="n">uOrder</span> <span class="o">=</span> <span class="n">uOrder</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>2.如果set要循环删除 最好是先把迭代器拿出来后，再++</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m_setDevelopSkill</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">m_setDevelopSkill</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="k">auto</span> <span class="n">_pos</span> <span class="o">=</span> <span class="n">it</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 先拿出迭代器 </span>

		<span class="n">_stFactionSkill</span><span class="o">*</span> <span class="n">pSkill</span> <span class="o">=</span> <span class="n">skill</span><span class="p">(</span><span class="o">*</span><span class="n">_pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pSkill</span> <span class="o">||</span> <span class="n">pSkill</span><span class="o">-&gt;</span><span class="n">eState</span><span class="o">!=</span><span class="n">FactionSkillState_Develop_ing</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">m_setDevelopSkill</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">_pos</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uint32</span> <span class="n">uPastTime</span>		<span class="o">=</span> <span class="n">uCurTime</span> <span class="o">-</span> <span class="n">pSkill</span><span class="o">-&gt;</span><span class="n">uDevelopLastTime</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">uPastTime</span> <span class="o">&gt;=</span> <span class="n">pSkill</span><span class="o">-&gt;</span><span class="n">uDevelopLeftTime</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">pSkill</span><span class="o">-&gt;</span><span class="n">eState</span>				<span class="o">=</span> <span class="n">FactionSkillState_Normal</span><span class="p">;</span>
			<span class="n">pSkill</span><span class="o">-&gt;</span><span class="n">uDevelopLeftTime</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pSkill</span><span class="o">-&gt;</span><span class="n">uDevelopLastTime</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">++</span><span class="n">pSkill</span><span class="o">-&gt;</span><span class="n">uLevel</span><span class="p">;</span>
			<span class="n">m_setDevelopSkill</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">_pos</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">pSkill</span><span class="o">-&gt;</span><span class="n">uDevelopLeftTime</span>	<span class="o">-=</span> <span class="n">uPastTime</span><span class="p">;</span>
			<span class="n">pSkill</span><span class="o">-&gt;</span><span class="n">uDevelopLastTime</span>	<span class="o">=</span> <span class="n">uCurTime</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>stl map 笔记</title>
      <link href="http://localhost:4000/stl-map/"/>
      <pubDate>2017-04-02T06:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/stl-map</guid>
      <content:encoded><![CDATA[<p>1.map 内部自建一个红黑树（一种非严格意义上的平衡二叉树）。
2.map会自动按key值排序（从小到大）。所以，map的key类型一定要支持&lt;操作符, 但这个是可以自定义的。
3.查找的复杂度基本是Log(n)。</p>

<h4 id="一-map-的插入">一 map 的插入</h4>

<p>有三种 插入方式。</p>
<ul>
  <li>用insert函数插入pair数据。mapStudent.insert(pair&lt;int, string&gt;(1, “student_one”));</li>
  <li>用insert函数插入value_type数据。mapStudent.insert(map&lt;int, string&gt;::value_type (2, “student_two”));</li>
  <li>用数组的方式插入数据。mapStudent[3] = “student_three”;</li>
</ul>

<h5 id="注">[注]</h5>
<p>当用第一种和第二种方式插入时，如果已经存在，会返回错误。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pair</span><span class="o">&lt;</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">bool</span><span class="o">&gt;</span> <span class="n">insert_pair</span> <span class="o">=</span> <span class="n">mapStudent</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"student_one"</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">insert_pair</span><span class="p">,</span><span class="n">second</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>  <span class="c1">// 失败</span>
</code></pre></div></div>

<p>当用第三种方式插入时，如果已经存在，则直接覆盖掉。</p>

<h4 id="二-map的查找">二 map的查找</h4>

<p>查找有两种方式</p>
<ul>
  <li>用count判定关键字是否出现。由于map的key不可能出现重复，所以，要么返回1 要么返回0。一个缺点是，无法找到位置。</li>
  <li>用find函数定位数据出现的位置。返回一个迭代器。没有找到时返回一个等于end()的迭代器。</li>
</ul>

<h4 id="三-map的删除">三 map的删除</h4>

<p>用erase访求可以删除 map中的元素。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>   <span class="c1">// 删除k元素，返回size_type是表示删除的个数。</span>
<span class="n">map</span><span class="p">,</span><span class="n">erase</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>    <span class="c1">// 删除迭代器p所指的元素。p必须是真实存在的元素，不能等于end()。</span>
<span class="n">map</span><span class="p">,</span><span class="n">erase</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>  <span class="c1">// 删除一段范围的元素， 范围由迭代器对b和e标记。这种方式应该比较少见吧。</span>
</code></pre></div></div>
<h5 id="注-1">[注]</h5>
<p>map在遍历删除时，有一个地方要注意的。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">mapStudent</span><span class="p">,</span><span class="n">end</span><span class="p">();)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">iter</span><span class="p">).</span><span class="n">second</span> <span class="o">==</span> <span class="s">"student_one"</span><span class="p">)</span>
    <span class="p">{</span> 
        <span class="n">mapStudent</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="o">++</span><span class="p">);</span>  
    <span class="p">}</span>
   <span class="k">else</span>
   <span class="p">{</span>
        <span class="o">++</span><span class="n">iter</span><span class="p">;</span>
   <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>
<p>mapStudent,erase(iter++); 中的iter++，不是erase(iter)， 然后iter++。因为iter指针被erase之后就失效了，不能再iter++; 也不能erase(++iter)这样就不是删iter原来指向的元素了。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>stl binary stree 笔记</title>
      <link href="http://localhost:4000/stl-binary_tree/"/>
      <pubDate>2017-04-02T06:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/stl-binary_tree</guid>
      <content:encoded><![CDATA[<p>二叉查找树，也称有序二叉树，或已排二叉，是指一棵空树或者具有下列性质的二叉树。</p>

<ul>
  <li>若任意节点的左子树不空，则左子树上的所有结点的值均小于它的根结点的值。</li>
  <li>若任意节占的左子树不空，则右子树上的所有结点的值均大于它的根结点的值 。</li>
  <li>任意节点的左右子树也分别为二叉树，</li>
  <li>没有键值相等的节点。</li>
</ul>

<p>二叉树的查找操作的执行时间为O(lg n)。 但二叉树是可能会退化为只有N节点为的线性链后，则这些操作的最坏情况是O(n)。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>stl vector 笔记</title>
      <link href="http://localhost:4000/stl-vector/"/>
      <pubDate>2017-04-02T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/stl-vector</guid>
      <content:encoded><![CDATA[<p>vector 是线性容器。</p>

<p>它的元素是严格按照线性序列排序，存储在一连续的存储空间中。这也是意味着不仅可以用使用迭代器，还可以使用指针的偏移方式访问。
vector的优点如下：</p>
<ul>
  <li>可以使用下标访问个别的元素。</li>
  <li>迭代器可以按照不同的方式遍历容器</li>
  <li>可以在窗口在末尾增加或删除元素。</li>
</ul>

<p>1、虽然窗口在在自动处理容量 的大小时会消耗更多的内存，但是容器能和数组一样的性能，而且能很好的地调整存储空间大小。</p>

<p>2、和其他标准的顺序容器相比， vector能更有效访问窗口在内的元素和末尾添加和删除元素，而在其他的位置添加和删除元素，vector则不及其他顺序容器。</p>

<p>3、在迭代器和引用 的也不比list支持的好。</p>

<p>4、 容器的大小和窗口在的容量是有区别的，大小是元素的，容量是分配的内存大小。大小vector::size() ，容量是vector::capacity()</p>

<p>5、可用for_echo() 遍历。如： for_echo(ivetor.begin(), ivector.end(), print) //print是回调函数   void print(int n );</p>

<p>6、<algorithm>中的sort函数，对象是vector。</algorithm></p>

<p>7、vector 查找，std::find(vector.begin(), vector.end(), 3)</p>

<p>8、vector 删除，有两种方式 erase()指定位置  或pop_back()最后一个。</p>

<p>9、当进行添加是，可以用insert()或push_bask()，当容量不够时，会触发动态扩容，此时，它的性能会下降，所以，一般要先预估vector的大小，先vector::reserver()。避免出现动态扩容。</p>

<p>10、使用“交换技巧”来修整vector过剩的空间/内存。vector<int>(ivec).swap(ivec)。vector<int>(ivec)建立一个临时 的vector，它是ivec的一个拷贝。vector的拷贝构造函数只分配拷贝的元素所需要的大小。</int></int></p>

<p>11、用swap方法强行释放vector所点内存.。这个地方应该怎么解释？</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tmplate</span><span class="o">&lt;</span> <span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">clearVector</span><span class="p">(</span> <span class="n">vector</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span> <span class="p">)</span>
<span class="p">{</span>
     <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vtTemp</span><span class="p">;</span>
     <span class="n">vtTemp</span><span class="p">,</span><span class="n">swap</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">;</span> 
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

</code></pre></div></div>
<p>或  vector<int>().swap(v)
或 v.swap(vector<int>());
或 {     std::vector<int> tmp = v; v.swap(tmp); }　　//大括号让tmp退出｛｝时自动析构。</int></int></int></p>

<p>[注]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 关于vector删除的问题。有一些地方要注意。遍历一个vector找到对应的元素删除的正常做法。
 for (auto iter = vector.begin(); iter != vector.end(); iter++)
 {
      if (*iter == 3 )   vector.ease(iter);
｝
1）这个代码有一个严重的错误。当ease(iter)后，iter就成了一个野指针。再对它iter++,就会有问题。
2）正常 的做法。
     vector&lt;int&gt;::iterator iter=vec.begin();
     for (; iter!= vec.end();)
    {
           iter = vec,erase(iter); 
    }
   else
   { 
        ++iter;
   }
</code></pre></div></div>

<p>对于容器的删除都要小心。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>stl string 笔记</title>
      <link href="http://localhost:4000/stl-string/"/>
      <pubDate>2017-04-01T22:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/stl-string</guid>
      <content:encoded><![CDATA[<p>1.string.h和cstring都不是string类的头文件，这两个头文件 主要地定义C语言铅笔字符趾操作的一些方法 ，譬如strlen()、strcpy()等。string.h是C语言的头文件格式，而cstring是C++风格的头文件，但是和<string.h>是一样的，它的目的是为了和C语言兼容。</string.h></p>

<p>2.string的一道面试题。很编写一个类string的7个函数。（后补）</p>

<p>3.C++字符串和C字符串的转换</p>

<p>C++提供了的由C++字符 串转换成对应的C字符串的方法是使用data()、c_str()和copy()来实现。</p>

<p>其中，data()以字符数据 的形式返回 字符串内容，但并不添加 ‘\0’；c_str()返回一以’\0’结尾的字符数组；而copy()则把字符 串的内容复制或写入既有的c_string或字符数组内，需要注意是，c++字符串并以不’\0’结尾。</p>

<p>c_str()语句可以生成一个 const char *  指针，江脂向空字符 的数组。这个数组的数据 是临时的， 当有一个改变这数据的成员函数被调用后，其中的数据就会失效。因此要么现用现转换，要么把它的数据复制到用户自己可以管理 的内在中后再转换。</p>

<p>4.string和int的类型转换</p>

<p>（1） int转string的方法。</p>

<p>可以用snprintf()。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">snprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div></div>
<p>（2）string 转int的方法</p>

<p>可以用 strtol， strtoll，strtoul，或strtoull函数。</p>

<p>5.string 其他常用成员函数</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">;</span>             <span class="c1">// 返回当前容量（即string 中不必增加内在即可存的元素个数）</span>
<span class="kt">int</span> <span class="n">max_size</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>               <span class="c1">// 返回string对象中可存放的最大字符串的长度</span>
<span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">;</span>                 <span class="c1">// 返回当前字符串的大小 </span>
<span class="kt">int</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>                <span class="c1">// 返回当前字符串的长度</span>
<span class="kt">int</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>                 <span class="c1">// 当前字符串是否为空</span>
<span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">;</span>      <span class="c1">// 把字符串当前大小为为len，并用字符c填充不足的部分。</span>
</code></pre></div></div>

<p>6、 string的size()和length()的结果是一样的。</p>

<p>length是因为沿用C语言的习惯而保留下来的，string类最初只有length，引入STL之后，为了兼容又加入了size，它是作为STL容器的属性存在的，便于符合STL的接口规则，以便用于STL的算法。string类的size()/length()方法返回的是字节数，不管是否有汉字。</p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
