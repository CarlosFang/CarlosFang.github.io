<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://blog.xyecho.com/feed/" rel="self" />
    <link href="http://blog.xyecho.com" />
    <lastBuildDate>2017-03-29T23:40:45+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>多个git帐号的提交</title>
      <link href="http://blog.xyecho.com/github-mult-account/"/>
      <pubDate>2017-03-21T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/github-mult-account</guid>
      <content:encoded><![CDATA[<p>由于我同时使用了github和云码。所以必须同时配置两个git帐号。</p>

<p>我的所在的环境是windows. （想必linux下也是如此）</p>

<p>先cd 到C:\Users\xxxx.ssh下。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>ssh-keygen -t rsa -C <span class="s2">"youremail@xx.com"</span>  

Generating public/private rsa key pair.
Enter file <span class="k">in </span>which to save the key <span class="o">(</span>/c/Users/xxxx/.ssh/id_rsa<span class="o">)</span>: ym
Enter passphrase <span class="o">(</span>empty <span class="k">for </span>no passphrase<span class="o">)</span>:
Enter same passphrase again:
Your identification has been saved <span class="k">in </span>ym.
Your public key has been saved <span class="k">in </span>ym.pub.

</code></pre>
</div>
<p>要在Enter file in which to save the key (/c/Users/xxxx/.ssh/id_rsa)后输入你的文件名。</p>

<p>在C:\Users\xxxx.ssh下：(xxxx为用户名)</p>

<p>创建一个config文件，（注意没有后缀）</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>Host github.com  
    HostName github.com  
    PreferredAuthentications publickey  
    IdentityFile ~/.ssh/id_rsa  
  
Host git.oschina.net 
    HostName git.oschina.net  
    PreferredAuthentications publickey  
    IdentityFile ~/.ssh/ym 

</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua metatables 元表</title>
      <link href="http://blog.xyecho.com/lua-metatables/"/>
      <pubDate>2017-03-16T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/lua-metatables</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>Metatables 允许我们改变 table 的行为，例如，使用 Metatables 我们可以定义 Lua 如
何计算两个 table 的相加操作 a+b。</p>
</blockquote>

<p>这种方式很类似于C++中对运算符的重载。</p>

<p>Lua 中的每一个表都可以有它自己的 Metatable。一般情况下 Lua默认创建一个不带 metatable 的新表。</p>

<p>用getmetatable(table) 可以获取这个表的Metatable。</p>

<p>用setmetatable(table, metatable) 对一个表设置Metatable。</p>

<p>metatable 算术运算符域名 有__add(加)、__mul(乘)、__sub(减)、__div(除)、__unm(负)、__pow(幂)，我们也可以定义__concat 定义连接行为。</p>

<p>metatable 关系运算符 ：__eq（等于），__lt（小于） ，和__le（小于等于）。</p>

<p>Lua 选择 metamethod 的原则：如果第一个参数存在带有__add 域的 metatable，Lua
使用它作为 metamethod，和第二个参数无关；
否则第二个参数存在带有__add 域的 metatable， Lua 使用它作为 metamethod 否则报
错。</p>

<p>如果想保护你的集合使其使用者既看不到也不能修改 metatables。可以
对 metatable 设置了__metatable 的值， getmetatable 将返回这个域的值，而调用 setmetatable
将会出错：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">Set</span><span class="p">.</span><span class="n">mt</span><span class="p">.</span><span class="n">__metatable</span> <span class="o">=</span> <span class="s2">"not your business"</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="n">new</span><span class="p">{}</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">getmetatable</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c1">--&gt; not your business</span>
<span class="nb">setmetatable</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="p">{})</span>
<span class="n">stdin</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">change</span> <span class="n">protected</span> <span class="n">metatable</span>
</code></pre>
</div>

<p>table访问的元方法： 字段: __index __newindex</p>

<p>__index:  查询：访问表中不存的字段  rawget(t, i)</p>

<p>__newindex： 更新：向表中不存在索引赋值  rawswt(t, k, v)</p>

<p>有默认值的表:</p>

<p>在一个普通的表中任何域的默认值都是 nil。很容易通过 metatables 来改变默认值：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">setDefault</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span><span class="n">__index</span> <span class="o">=</span> <span class="k">function</span> <span class="p">()</span> <span class="k">return</span> <span class="n">d</span> <span class="k">end</span><span class="p">}</span>
	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">tab</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">20</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tab</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tab</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="c1">--&gt; 10 nil</span>

<span class="n">setDefault</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tab</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tab</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="c1">--&gt; 10 0</span>
</code></pre>
</div>

<p>监控表:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="c1">-- create private index</span>
<span class="kd">local</span> <span class="n">index</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1">-- create metatable</span>
<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__index</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">"*access to element "</span> <span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="c1">-- access the original table</span>
	<span class="k">end</span>

	<span class="n">__newindex</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">"*update of element "</span> <span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">..</span> <span class="s2">" to "</span><span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
		<span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="c1">-- update original table</span>
	<span class="k">end</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">track</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>

	<span class="kd">local</span> <span class="n">proxy</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">proxy</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">proxy</span>
<span class="k">end</span>
</code></pre>
</div>

<p>只读表:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="k">function</span> <span class="nf">readOnly</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">proxy</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">-- create metatable</span>
	<span class="n">__index</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span>
	<span class="n">__newindex</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="nb">error</span><span class="p">(</span><span class="s2">"attempt to update a read-only table"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">end</span>
	<span class="p">}</span>
	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">proxy</span>
<span class="k">end</span>

<span class="n">days</span> <span class="o">=</span> <span class="n">readOnly</span><span class="p">{</span><span class="s2">"Sunday"</span><span class="p">,</span> <span class="s2">"Monday"</span><span class="p">,</span> <span class="s2">"Tuesday"</span><span class="p">,</span> <span class="s2">"Wednesday"</span><span class="p">,</span>
<span class="s2">"Thursday"</span><span class="p">,</span> <span class="s2">"Friday"</span><span class="p">,</span> <span class="s2">"Saturday"</span><span class="p">}</span>


<span class="nb">print</span><span class="p">(</span><span class="n">days</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">--&gt; Sunday</span>
<span class="n">days</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Noday"</span>
<span class="c1">-- stdin:1: attempt to update a read-only table</span>

</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 协程</title>
      <link href="http://blog.xyecho.com/lua-coroutine/"/>
      <pubDate>2017-03-16T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/lua-coroutine</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>协同程序（coroutine）与多线程情况下的线程比较类似：有自己的堆栈，自己的局
部变量，有自己的指令指针，但是和其他协同程序共享全局变量等很多信息。线程和协
同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线
程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这
个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
</blockquote>

<p>宏观上可能看成是比线程更小的执行单位。但本质上，它是线程管理下的单位。这就是上面所说的在任一指定时刻只有一个协同程序在运行。是一种多任务方式。</p>

<h3 id="协同的基础">协同的基础</h3>

<p>lua 提供对应一些协程的函数。如 create() status() resume() 等等。</p>

<p>创建一个协程create()</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"hello world!"</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">co</span><span class="p">)</span> 
</code></pre>
</div>

<p>查看状态，可用status</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span><span class="p">(</span><span class="nb">coroutine.status</span><span class="p">(</span><span class="n">co</span><span class="p">))</span> <span class="c1">--&gt; suspended</span>
</code></pre>
</div>

<p>协同有三个状态：挂起态、运行态、停止态。</p>

<p>让一个协程从挂起状变为运行态</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">)</span>
</code></pre>
</div>

<p>让一个协程挂起，可用yield()</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span> <span class="k">do</span>
	<span class="nb">print</span><span class="p">(</span><span class="s2">"co"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="nb">coroutine.yield</span><span class="p">()</span>
	<span class="k">end</span>
<span class="k">end</span><span class="p">)</span>
</code></pre>
</div>
<p>在程序使用resume后，协程被激活。</p>

<p>看 resume-yield 可以相互交换数据。</p>

<p>1 非对称的情况：</p>

<p>resume 把参数传入协程里。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"co"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
<span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">--&gt; co 1 2 3</span>
</code></pre>
</div>

<p>2 对称的情况：</p>

<p>yield 会把值返还给resume。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">--&gt; true 30 10</span>
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 异常与错误</title>
      <link href="http://blog.xyecho.com/lua-error/"/>
      <pubDate>2017-03-16T01:31:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/lua-error</guid>
      <content:encoded><![CDATA[<h3 id="assert">assert</h3>

<p>Lua 提供了专门的内置函数 assert 来完成错误的检测的功能。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span> <span class="s2">"enter a number:"</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">assert</span><span class="p">(</span><span class="nb">io.read</span><span class="p">(</span><span class="s2">"*number"</span><span class="p">),</span> <span class="s2">"invalid input"</span><span class="p">)</span>
</code></pre>
</div>

<p>assert 首先检查第一个参数是否返回错误，如果不返回错误 assert 简单的返回，否则assert 以第二个参数抛出错误信息。第二个参数是可选的。</p>

<p>当函数遇到异常有两个基本的动作：返回错误代码或者抛出错误。这两种方式选择
哪一种没有固定的规则，但有一般的原则：容易避免的异常应该抛出错误否则返回错误
代码。</p>

<h3 id="异常和错误处理">异常和错误处理</h3>

<p>在 Lua 中需要处理错误，需要使用 pcall 函数封装你的代码。
用法如下：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="nb">pcall</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="k">then</span>
	<span class="c1">-- no errors while running `foo'</span>
<span class="o">...</span>
<span class="k">else</span>
<span class="c1">-- `foo' raised an error: take appropriate actions</span>
<span class="o">...</span>
<span class="k">end</span>

</code></pre>
</div>
<p>foo 为检测的函数。</p>

<p>用做匿名函数则是：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="k">if</span> <span class="nb">pcall</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="o">...</span> <span class="k">end</span><span class="p">)</span> <span class="k">then</span> <span class="o">...</span>
<span class="k">else</span> <span class="o">...</span>

</code></pre>
</div>
<p>pcall 在保护模式下调用他的第一个参数并运行，因此可以捕获所有的异常和错误。
如果没有异常和错误，pcall 返回 true 和调用返回的任何值；否则返回 nil 加错误信息。</p>

<h4 id="错误信息和回跟踪tracebacks">错误信息和回跟踪（Tracebacks）</h4>

<p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展看（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。</p>

<p>debug库提供了两个通用的错误处理函数:</p>
<ul>
  <li>debug.debug：提供一个Lua提示符，让用户来价差错误的原因</li>
  <li>debug.traceback：根据调用桟来构建一个扩展的错误消息。</li>
</ul>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">xpcall</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="nb">error</span><span class="p">(</span><span class="s1">'error..'</span><span class="p">)</span> <span class="k">end</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="nb">print</span><span class="p">(</span><span class="nb">debug.traceback</span><span class="p">())</span> <span class="k">end</span><span class="p">,</span> <span class="mi">33</span><span class="p">)</span>
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>lua 函数</title>
      <link href="http://blog.xyecho.com/lua-function/"/>
      <pubDate>2017-03-15T19:16:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/lua-function</guid>
      <content:encoded><![CDATA[<p>lua的函数有必要记录可能也就是 可变参数, 后面的命名参数和多个返回值和python基本一样。</p>

<h3 id="可变参数">可变参数</h3>

<p>Lua 函数可以接受可变数目的参数，和 C 语言类似在函数参数列表中使用三点（…）
表示函数有可变的参数。Lua 将函数的参数放在一个叫 arg 的表中，除了参数以外，arg
表中还有一个域 n 表示参数的个数。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">g</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="k">end</span>

<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">nil</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span>
<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span>
<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">;</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">}</span>

</code></pre>
</div>
<p>Lua 的函数还一些特性和C不一样的是：它和其他值（数值、字符串）一样，函数可以被存放在变
量中，也可以存放在表中，可以作为函数的参数，还可以作为函数的返回值。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span> <span class="o">=</span> <span class="nb">math.sin</span> <span class="c1">-- `print' now refers to the sine function</span>
<span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">(</span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">--&gt; 0.841470</span>
</code></pre>
</div>

<p>如函数被嵌套的函数里，它可以访问他外部函数中的变量。这一特性强大编程能力。</p>

<p>另一个特征是：匿名函数。</p>

<p>用表达式创建函数：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">foo</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="k">end</span>
</code></pre>
</div>

<h3 id="闭包">闭包</h3>

<p>当一个函数内部嵌套另一个函数定义时，内部的函数体可以访问外部的函数的局部变量，这种特征我们称作词法定界。虽然这看起来很清楚，事实并非如此，词法定界加上第一类函数在编程语言里是一个功能强大的概念，很少语言提供这种支持。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">newCounter</span><span class="p">()</span>
	<span class="kd">local</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">return</span> <span class="k">function</span><span class="p">()</span> <span class="c1">-- anonymous function</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">i</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">newCounter</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 2</span>

</code></pre>
</div>
<p>i不是全局变量也不是局部变量，我们称作外部的局部变量（external local variable）或者 upvalue。</p>

<p>匿名函数使用 upvalue i 保存他的计数，当我们调用匿名函数的时候 i 已经超出了作用范围，因为创建 i 的函数 newCounter 已经返回了。然而 Lua 用闭包的思想正确处理了这种情况。简单的说闭包是一个函数加上它可以正确访问的 upvalues。如果我们再次调
用 newCounter，将创建一个新的局部变量 i，因此我们得到了一个作用在新的变量 i 上的
新闭包。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">c2</span> <span class="o">=</span> <span class="n">newCounter</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c2</span><span class="p">())</span> <span class="c1">--&gt; 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c2</span><span class="p">())</span> <span class="c1">--&gt; 2</span>

</code></pre>
</div>
<p>技术上来讲，闭包指值而不是指函数，函数仅仅是闭包的一个原型声明；尽管如此，
在不会导致混淆的情况下我们继续使用术语函数代指闭包。</p>

<p>闭包在上下文环境中提供很有用的功能，如高级函数（sort）的参数；作为函数嵌套的函数（newCounter）。这一机制使得我们可以在 Lua 的函数世界里组合出奇幻的编程技术。闭包也可用在回调函数中。</p>

<h3 id="全局函数和局部函数">全局函数和局部函数</h3>

<p>局部函数就是在函数前加一个 local。</p>

<p>局部函数的两种方式：</p>

<ol>
  <li>方式一</li>
</ol>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="n">f</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">end</span>
<span class="kd">local</span> <span class="n">g</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">f</span><span class="p">()</span> <span class="c1">-- external local `f' is visible here</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre>
</div>

<ol>
  <li>方式二</li>
</ol>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="k">function</span> <span class="nf">f</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>有一点需要注意的是在声明递归局部函数的方式。
要提前定义local。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="kd">local</span> <span class="n">fact</span>
<span class="n">fact</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<h3 id="尾调用proper-tail-calls">尾调用（Proper Tail Calls）</h3>

<p>尾调用是一种类似在函数结尾的 goto 调用，当函数最后一个动作是调用另外一个函
数时，我们称这种调用尾调用。例如：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>g 的调用是尾调用。</p>

<p>例子中 f 调用 g 后不会再做任何事情，这种情况下当被调用函数 g 结束时程序不需
要返回到调用者 f；所以尾调用之后程序不需要在栈中保留关于调用者的任何信息。</p>

<p>如下三种不是尾调函数.</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="n">r</span> <span class="n">eturn</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">-- must do the addition</span>
<span class="k">return</span> <span class="n">x</span> <span class="ow">or</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1">-- must adjust to 1 result</span>
<span class="k">return</span> <span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">-- must adjust to 1 result</span>
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 学习初步记录</title>
      <link href="http://blog.xyecho.com/lua-first-learn/"/>
      <pubDate>2017-03-15T04:27:03+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/lua-first-learn</guid>
      <content:encoded><![CDATA[<p>1 Lua 是动态类型语言，变量不要类型定义。 Lua 中有 8 个基本类型分别为： nil、 boolean、number、string、userdata、function、thread 和 table。函数 type 可以测试给定变量或者值
的类型。</p>

<p>2 Lua 中特殊的类型，他只有一个值：nil；一个全局变量没有被赋值以前默认值为 nil；
给全局变量负 nil 可以删除该变量。</p>

<p>3 Booleans 两个取值 false 和 true。但要注意 Lua 中所有的值都可以作为条件。在控制结构的条
件中除了 false 和 nil 为假，其他值都为真。所以 Lua 认为 0 和空串都是真。</p>

<p>4 Lua 中字符串是不可以修改的， 你可以创建一个新的变量存放你要的字符串。 还可以使用[[…]]表示字符串。</p>

<p>5 Lua 会自动在 string 和 numbers 之间自动进行类型转换，当一个字符串使用算术操作符时，string 就会被转成数字。
尽管字符串和数字可以自动转换，但两者是不同的，像 10 == “10”这样的比较永远
都是错的。</p>

<p>6 <code class="highlighter-rouge">..</code>在 Lua 中是字符串连接符，当在一个数字后面写..时，必须加上空格以防止被解释错。</p>

<p>7 函数是第一类值（和其他变量相同），意味着函数可以存储在变量中，可以作为函数的参数，也可以作为函数的返回值。</p>

<p>8 Lua 比较数字按传统的数字大小进行，比较字符串按字母的顺序进行，但是字母顺序依赖于本地环境。</p>

<p>9 Lua list的下标是从1开始的。</p>

<p>10 使用 local 创建一个局部变量，与全局变量不同，局部变量只在被声明的那个代码块内有效。代码块：指一个控制结构内，一个函数体，或者一个 chunk（变量被声明的那个文件或者文本串）</p>

<p>11 当函数只有一个参数并且这个参数是字符串或者表构造的时候，()是可选的。</p>

<p>12 Lua有闭包的用法。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>防盗链技术</title>
      <link href="http://blog.xyecho.com/web-referers/"/>
      <pubDate>2017-03-10T05:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/web-referers</guid>
      <content:encoded><![CDATA[<p>在《增长黑客》这个本书上，看到一个例子。作者用curl 在网上抓取了一个网站上用户的头像。这个网站对于图片的静态链接没有做防盗链。
以前有过这种开发。也疑惑过这种问题。
今天就了解一下什么是防盗链吧。</p>

<p>防盗链的定义：
此内容不在自己服务器上，而通过技术手段，绕过别人放广告有利益的最终页，直接在自己的有广告有利益的页面上向最终用户提供此内容。 常常是一些名不见经传的 小网站来盗取一些有实力的大网站的地址（比如一些音乐、图片、软件的下载地址）然后放置在自己的网站中，通过这种方法盗取大网站的空间和流量。</p>

<p>通俗的讲：就是你提供给自己的网站的静态链接。别人一样可能无条件用。图片，音频，文件，别人可以下载得到。</p>

<p>这个技术的本质就在于http上。表头字体有一个叫referer的。这个字段的作用是：当浏览器访问web服务器时，一般会带上referer，告诉服务器我是从哪个页面链接过来的。所以，我们可用检测这个链接是不是我们自己的服务器上的，如果不是，那可能就是别人来盗链接的了，就应该阻止掉。</p>

<h4 id="nginx防盗链的配置">nginx防盗链的配置</h4>
<p>1、nginx针对文件类型的防盗链配置方法：</p>
<div class="language-sh highlighter-rouge"><pre class="highlight"><code>　　location ~<span class="k">*</span> <span class="se">\.</span><span class="o">(</span>gif|jpg|png|swf|flv|bmp<span class="o">)</span><span class="nv">$ </span><span class="o">{</span>
　　valid_referers none blocked <span class="k">*</span>.php100.com php100.com;
　　if <span class="o">(</span><span class="nv">$invalid_referer</span><span class="o">)</span> <span class="o">{</span>
　　     <span class="c">#rewrite ^/ http://www.php100.com/403.html;</span>
　　     <span class="k">return </span>403;
　　     <span class="o">}</span>     
　　<span class="o">}</span>
</code></pre>
</div>

<p>这种方法是在server或者location段中加入：valid_referers none blocked，其中none表示空的来路，也就是直接访问，比如直接在浏览器打开一个文件，blocked表示被防火墙标记过的来路，*.php100.com表示所有子域名。</p>

<p>2、nginx针对文件目录的防盗链配置方法：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>　　location /img/ <span class="o">{</span>
　　     root /data/img/;
　　     valid_referers none blocked <span class="k">*</span>.php100.com php100.com;

　　     <span class="k">if</span> <span class="o">(</span><span class="nv">$invalid_referer</span><span class="o">)</span> <span class="o">{</span>
　　          rewrite ^/ http://www.php100.com/error.gif;
　　          <span class="c">#return 403;</span>
　　     <span class="o">}</span>     
　　<span class="o">}</span>
</code></pre>
</div>

<p>如果不是用nginx，就要自己去解析表头然后做出判断。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>用valgrind做一次性能分析</title>
      <link href="http://blog.xyecho.com/valgrind-code-analysis/"/>
      <pubDate>2017-02-09T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/valgrind-code-analysis</guid>
      <content:encoded><![CDATA[<p>有一次用valgrind对代码的热点进行分析。发现有一个函数的被调用百分比比较高。</p>

<p>关键的函数是CGameBuffMgr::process()</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">CGameBuffMgr</span><span class="o">::</span><span class="n">process</span> <span class="p">(</span><span class="n">uint64</span> <span class="n">uTick</span><span class="p">,</span><span class="n">uint64</span> <span class="n">uTime</span><span class="p">,</span><span class="n">uint32</span> <span class="n">uSecond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">m_uProcessTick</span> <span class="o">&gt;</span> <span class="n">uTick</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">m_uProcessTick</span><span class="p">)</span>
		<span class="n">m_uProcessTick</span> <span class="o">=</span> <span class="n">uTick</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">POOL_BUFF</span><span class="o">::</span><span class="n">iterator</span> <span class="n">_pos</span><span class="p">;</span>
	<span class="n">m_poolBuff</span><span class="p">.</span><span class="n">getHead</span><span class="p">(</span><span class="n">_pos</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m_poolBuff</span><span class="p">.</span><span class="n">isTail</span><span class="p">(</span><span class="n">_pos</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">CGameBuff</span><span class="o">*</span>	<span class="n">pBuff</span> <span class="o">=</span> <span class="n">m_poolBuff</span><span class="p">.</span><span class="n">getNext</span><span class="p">(</span><span class="n">_pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pBuff</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">pBuff</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">(</span><span class="n">uTick</span><span class="p">,</span><span class="n">uTime</span><span class="p">,</span><span class="n">uSecond</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pBuff</span><span class="o">-&gt;</span><span class="n">isDelete</span><span class="p">())</span>
			<span class="n">delBuff</span><span class="p">(</span><span class="n">pBuff</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>process是由定时器调起，所以比较多是正常的。</p>

<p>用 valgrind 做代码性能分析。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>/usr/bin/valgrind --tool<span class="o">=</span>callgrind  --trace-children<span class="o">=</span>yes  /data/game_server/game_server
</code></pre>
</div>

<p>得到：callgrind.out.6578 文件。再用 kcachegrind进行分析。如下：</p>

<p><img src="/assets/code-analysis/valgrind-stl-1.png" alt="" /></p>

<p>CGameBuffMgr::process中的 getHead消耗比较大。感觉可能有问题。</p>

<p>而getHead是这样的：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_ValType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">COUNT</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span>	<span class="n">CMemoryPool</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">_ValType</span><span class="p">,</span><span class="n">COUNT</span><span class="o">&gt;::</span><span class="n">getHead</span><span class="p">(</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">try</span>
	<span class="p">{</span>
		<span class="c1">//CCritLocker lock(m_csLock);
</span>		<span class="n">pos</span> <span class="o">=</span> <span class="n">m_UseList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(...)</span>
	<span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>
<p>getHead中只是对 hash_map进行begin操作。
从图上看hash_map的begin消耗也很大。问题可能出在这个地方。</p>

<p><img src="/assets/code-analysis/valgrind-stl-12.png" alt="" /></p>

<p>在 <a href="http://blog.csdn.net/tototony/article/details/5689882">http://blog.csdn.net/tototony/article/details/5689882</a>这篇文章中，可以了解一些hash_map的原理。
begin() 为了获得第一个元素，就在hashtable表中遍历，hashtale就是一个vector。
所以说 一调用begin(), 说是遍历hashtable</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">iterator</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">begin</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">_M_buckets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">__n</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="n">_M_buckets</span><span class="p">[</span><span class="n">__n</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">_M_buckets</span><span class="p">[</span><span class="n">__n</span><span class="p">],</span> <span class="k">this</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">end</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>找到了就返回，找到就会遍历完整个hashtable表，再返回end()。
我想这就是为什么hash_map中的 begin() 效率不行的原因吧。</p>

<p>最后，就动手把hash_map改成了map　stl中的map其实就是红黑树。
改动后 重新跑一下valgrind。 得到如下图。已经没有getHead了。</p>

<p><img src="/assets/code-analysis/valgrind-stl-2.png" alt="" /></p>

<p>所以，如果要用到遍历的应尽量避免用hash_map。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>日志模块</title>
      <link href="http://blog.xyecho.com/model-log/"/>
      <pubDate>2016-12-15T17:23:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/model-log</guid>
      <content:encoded><![CDATA[<p>系统的开发，日志模块的是必不可少的。特别对于业务逻辑层的来说，有日志输出，很方便跟踪逻辑大概情况。但是对于底层的核心模块来说，日志输出反而成了累赘。日志的输出同样占有I/O。再者，对于底层的逻辑，一般都是比较复杂，核心。暴露出来也没必要。业务逻辑层同样没有必要去了解它。所以，一般的做法是：底层出错，返回错误编码。由上一层记录就OK了。</p>

<p>日志模块一般可以分为 print/note、 debug、 warn、error。人个觉得这四个层次就够了。当然，也可多增加几个，例如，trac。我曾经用于特别的调试，只是一些非必现的问题调试，把日志输出到这层，方便查找。</p>

<p>对于这四层，是分开几个文件，还是在同一个文件中？ 其实这两种方式我都用过。这些年的经验，感觉写到同一个文件中，比较分四个文件要好。理由是很清楚的知道日志输出的前后时间顺序。当然分开成几个日志文件输出，也是有办法按时间查看的，只要用linux的一些工具手段而已。分开成几个文件的好处，就是一看就知道是否有错误输出了。同一个文件，只能在文件中查到才知道。</p>

<p>无论是 apache,还是nignx，日志的输出都是分层，配置不同层次的，只有高于或等于它的才能被输出。当然，我们设计时也可以直接指定层次print、warn、error。</p>

<p>有日志输出，就意味着有日志文件的管理。如文件大小、文件命名、所在目录、如何清理。
一般，我的做法是日志文件的大小设计成可配置。在相关的配置文件中指定。
二，日志文件的命名，我是按模块名来命名（即进程名）。或加上日期或日期在体现在目录上。
三，所在目录，我选择是把所有的日志放到同一个Log目录下，千万别把分别放到不同模块的目录里面。这样做的好处是：我们可以系统中划出一个分区来，专门存放日志，和服务的进程分离开。这样做的理由是：如果日志输出过来，把硬盘空间爆了，不会影响到服务的运行。
四，对清理， 我没有体现在于日志模块里，而是用计划任务做定时清理。</p>

<p>日志模块应该有可配置性。 一般有：
路径、文件大小、模块名、输出层次、</p>

<p>日志的输出涉及到I/O。所以对效率是有一定的影响的。 必竞这是定文件的。有一个很不错的设计：就是日志写到队列（用共享内存实现 的）然后由专门的日志进程（logsvr）输出到文件中。这样日志输出就不会有I/O阻塞了，提高一些效率。</p>

<p>下一回，把日志的模块整理好，分析一下。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>余华-活着</title>
      <link href="http://blog.xyecho.com/alive/"/>
      <pubDate>2016-10-15T17:23:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://blog.xyecho.com/alive</guid>
      <content:encoded><![CDATA[<p>这本书是从微博上看网友介绍的，还是朋友介绍的，我也不记得了。在kindle上看有已经购买。应该是一次买了后，忘记了看了。这两天上下班在地铁上，就把它给看了。</p>

<p>书里的主人公叫福贵。一个旧社会里的有钱人的少爷。年少时就一个败家子。按他妈的说法是上梁不正下梁歪。因为他老子年轻也也是败家子，败了家里的一百多亩田地。后来开窍了，好好的在经营自己的田地。他就边上厕所也会跑到自家的田地，可是就是肥水不流外人田的吧。老子还是蛮希望福贵能光大门楣的。结果还是一败家子。把他没败完的另一百多亩也败完了。</p>

<p>最后他爸把所有的田契和房契都让人换成了铜钱，整整三大担。让福贵自己挑去还赌债。福贵把肩膀都磨破了。才知道祖辈挣下这些钱不知要累死多少人。他自己挑都快累死了。这时才知道他老子为什么不要银元要铜钱。
破产后，他们只能去住茅草屋。没多久福贵的老子在拉屎的时候死了。家里能卖的东西也都卖光了。福贵只能去租田来种，可他是个就个少爷。可怜了他的老妈和老婆。
话说他老婆也是个好女人。一个城里米行的小姐，也读过书。嫁给一个败家子。最后再怎么受苦也跟定他了。 在福贵去城里为他妈找大夫时，他被国民党抓了壮丁。一去就是五年，幸好没有死，被共产党俘虏后放了。到家时，他妈死了，大女儿在生病时聋哑啊。小儿子也不认识他了。</p>

<p>然后，解放了，新中国成立了， 三反三反，大跃进，砸锅炼钢，文化大革命。开始了生产大队的大食堂的生活，最后没粮食了，食堂解散了，大伙都没有吃的。只能挖树根，然后说着要相信政府，相信党。可队长每一次都是空手而回的。大伙开始去乞讨，福贵的老婆说要去城里看望老父，其实就是去乞讨。却真的在街上碰到了父亲。（真想知道他们当时的场景）老父给她从自己的牙缝里省下的来小米。她高兴的回到家，福贵去不敢开社，因为知道一开灶全村都知道了。福贵要确认村里没有人才敢开灶。这让我想我爸说过一件。有一次，我开玩笑的对他说，如果中国经济真的不行了。我们是不是家里存点什么东西啊。他说：没什么用， 全村都没有，就我们家有，也是存不了的。想到爸之前的意思，他是不是以前就经历过这样的事。</p>

<p>儿子在医院给他输血时，被抽空死了。聋哑女儿好不容易嫁了个好人歪头。却在难产也死了。老婆却一直在生病，在女儿死后三个月也死了。儿子女子都死了，她没什么好操心的了。她死后也有福贵料理后事。而福贵的后事也有他的外孙。所以她死得安心。接下来的，是他的女婿歪头也在工地出意外死了，留下了外孙和他相依为命。可最后，边他的外孙也在吃豆撑死了。在福贵年迈时，他所有的亲人都死了。</p>

<p>他在床边放十块钱，全村的人都知道，那是给替他收尸的人的。他存了几年的钱，想为他外孙买头牛。却在看到别人宰杀一头老牛时，心生怜悯。买了一头老牛。村里人都是这牛活不过四五年，可他却不在意，他觉得自己的自己应该活不了那么久。</p>

<p>写得比较朴素简单，文字很简单。但福贵的命却是很悲剧的。不过，过他福贵自己讲出来的人生却没有悲剧的感觉。可能这就是《活着》想表达的东西吧。</p>

<p>最后想说的，那真个操蛋的年代 。</p>

<p>– 深圳 北站</p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
