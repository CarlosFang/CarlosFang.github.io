<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2017-03-16T21:36:37+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>lua metatables 元表</title>
      <link href="http://localhost:4000/lua-metatables/"/>
      <pubDate>2017-03-16T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-metatables</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>Metatables 允许我们改变 table 的行为，例如，使用 Metatables 我们可以定义 Lua 如
何计算两个 table 的相加操作 a+b。</p>
</blockquote>

<p>这种方式很类似于C++中对运算符的重载。</p>

<p>Lua 中的每一个表都可以有它自己的 Metatable。一般情况下 Lua默认创建一个不带 metatable 的新表。</p>

<p>用getmetatable(table) 可以获取这个表的Metatable。</p>

<p>用setmetatable(table, metatable) 对一个表设置Metatable。</p>

<p>metatable 算术运算符域名 有__add(加)、__mul(乘)、__sub(减)、__div(除)、__unm(负)、__pow(幂)，我们也可以定义__concat 定义连接行为。</p>

<p>metatable 关系运算符 ：__eq（等于），__lt（小于） ，和__le（小于等于）。</p>

<p>Lua 选择 metamethod 的原则：如果第一个参数存在带有__add 域的 metatable，Lua
使用它作为 metamethod，和第二个参数无关；
否则第二个参数存在带有__add 域的 metatable， Lua 使用它作为 metamethod 否则报
错。</p>

<p>如果想保护你的集合使其使用者既看不到也不能修改 metatables。可以
对 metatable 设置了__metatable 的值， getmetatable 将返回这个域的值，而调用 setmetatable
将会出错：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">Set</span><span class="p">.</span><span class="n">mt</span><span class="p">.</span><span class="n">__metatable</span> <span class="o">=</span> <span class="s2">"not your business"</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="n">new</span><span class="p">{}</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">getmetatable</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c1">--&gt; not your business</span>
<span class="nb">setmetatable</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="p">{})</span>
<span class="n">stdin</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">change</span> <span class="n">protected</span> <span class="n">metatable</span>
</code></pre>
</div>

<p>table访问的元方法： 字段: __index __newindex</p>

<p>__index:  查询：访问表中不存的字段  rawget(t, i)</p>

<p>__newindex： 更新：向表中不存在索引赋值  rawswt(t, k, v)</p>

<p>有默认值的表:</p>

<p>在一个普通的表中任何域的默认值都是 nil。很容易通过 metatables 来改变默认值：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">setDefault</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span><span class="n">__index</span> <span class="o">=</span> <span class="k">function</span> <span class="p">()</span> <span class="k">return</span> <span class="n">d</span> <span class="k">end</span><span class="p">}</span>
	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">tab</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">20</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tab</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tab</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="c1">--&gt; 10 nil</span>

<span class="n">setDefault</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tab</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tab</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="c1">--&gt; 10 0</span>
</code></pre>
</div>

<p>监控表:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="c1">-- create private index</span>
<span class="kd">local</span> <span class="n">index</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1">-- create metatable</span>
<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__index</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">"*access to element "</span> <span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="c1">-- access the original table</span>
	<span class="k">end</span>

	<span class="n">__newindex</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">"*update of element "</span> <span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">..</span> <span class="s2">" to "</span><span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
		<span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="c1">-- update original table</span>
	<span class="k">end</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">track</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>

	<span class="kd">local</span> <span class="n">proxy</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">proxy</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">proxy</span>
<span class="k">end</span>
</code></pre>
</div>

<p>只读表:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="k">function</span> <span class="nf">readOnly</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">proxy</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">-- create metatable</span>
	<span class="n">__index</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span>
	<span class="n">__newindex</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="nb">error</span><span class="p">(</span><span class="s2">"attempt to update a read-only table"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">end</span>
	<span class="p">}</span>
	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">proxy</span>
<span class="k">end</span>

<span class="n">days</span> <span class="o">=</span> <span class="n">readOnly</span><span class="p">{</span><span class="s2">"Sunday"</span><span class="p">,</span> <span class="s2">"Monday"</span><span class="p">,</span> <span class="s2">"Tuesday"</span><span class="p">,</span> <span class="s2">"Wednesday"</span><span class="p">,</span>
<span class="s2">"Thursday"</span><span class="p">,</span> <span class="s2">"Friday"</span><span class="p">,</span> <span class="s2">"Saturday"</span><span class="p">}</span>


<span class="nb">print</span><span class="p">(</span><span class="n">days</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">--&gt; Sunday</span>
<span class="n">days</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Noday"</span>
<span class="c1">-- stdin:1: attempt to update a read-only table</span>

</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 协程</title>
      <link href="http://localhost:4000/lua-coroutine/"/>
      <pubDate>2017-03-16T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-coroutine</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>协同程序（coroutine）与多线程情况下的线程比较类似：有自己的堆栈，自己的局
部变量，有自己的指令指针，但是和其他协同程序共享全局变量等很多信息。线程和协
同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线
程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这
个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
</blockquote>

<p>宏观上可能看成是比线程更小的执行单位。但本质上，它是线程管理下的单位。这就是上面所说的在任一指定时刻只有一个协同程序在运行。是一种多任务方式。</p>

<h3 id="协同的基础">协同的基础</h3>

<p>lua 提供对应一些协程的函数。如 create() status() resume() 等等。</p>

<p>创建一个协程create()</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"hello world!"</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">co</span><span class="p">)</span> 
</code></pre>
</div>

<p>查看状态，可用status</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span><span class="p">(</span><span class="nb">coroutine.status</span><span class="p">(</span><span class="n">co</span><span class="p">))</span> <span class="c1">--&gt; suspended</span>
</code></pre>
</div>

<p>协同有三个状态：挂起态、运行态、停止态。</p>

<p>让一个协程从挂起状变为运行态</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">)</span>
</code></pre>
</div>

<p>让一个协程挂起，可用yield()</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span> <span class="k">do</span>
	<span class="nb">print</span><span class="p">(</span><span class="s2">"co"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="nb">coroutine.yield</span><span class="p">()</span>
	<span class="k">end</span>
<span class="k">end</span><span class="p">)</span>
</code></pre>
</div>
<p>在程序使用resume后，协程被激活。</p>

<p>看 resume-yield 可以相互交换数据。</p>

<p>1 非对称的情况：</p>

<p>resume 把参数传入协程里。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"co"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
<span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">--&gt; co 1 2 3</span>
</code></pre>
</div>

<p>2 对称的情况：</p>

<p>yield 会把值返还给resume。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">--&gt; true 30 10</span>
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 异常与错误</title>
      <link href="http://localhost:4000/lua-error/"/>
      <pubDate>2017-03-16T01:31:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-error</guid>
      <content:encoded><![CDATA[<h3 id="assert">assert</h3>

<p>Lua 提供了专门的内置函数 assert 来完成错误的检测的功能。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span> <span class="s2">"enter a number:"</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">assert</span><span class="p">(</span><span class="nb">io.read</span><span class="p">(</span><span class="s2">"*number"</span><span class="p">),</span> <span class="s2">"invalid input"</span><span class="p">)</span>
</code></pre>
</div>

<p>assert 首先检查第一个参数是否返回错误，如果不返回错误 assert 简单的返回，否则assert 以第二个参数抛出错误信息。第二个参数是可选的。</p>

<p>当函数遇到异常有两个基本的动作：返回错误代码或者抛出错误。这两种方式选择
哪一种没有固定的规则，但有一般的原则：容易避免的异常应该抛出错误否则返回错误
代码。</p>

<h3 id="异常和错误处理">异常和错误处理</h3>

<p>在 Lua 中需要处理错误，需要使用 pcall 函数封装你的代码。
用法如下：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="nb">pcall</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="k">then</span>
	<span class="c1">-- no errors while running `foo'</span>
<span class="o">...</span>
<span class="k">else</span>
<span class="c1">-- `foo' raised an error: take appropriate actions</span>
<span class="o">...</span>
<span class="k">end</span>

</code></pre>
</div>
<p>foo 为检测的函数。</p>

<p>用做匿名函数则是：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="k">if</span> <span class="nb">pcall</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="o">...</span> <span class="k">end</span><span class="p">)</span> <span class="k">then</span> <span class="o">...</span>
<span class="k">else</span> <span class="o">...</span>

</code></pre>
</div>
<p>pcall 在保护模式下调用他的第一个参数并运行，因此可以捕获所有的异常和错误。
如果没有异常和错误，pcall 返回 true 和调用返回的任何值；否则返回 nil 加错误信息。</p>

<h4 id="错误信息和回跟踪tracebacks">错误信息和回跟踪（Tracebacks）</h4>

<p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展看（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。</p>

<p>debug库提供了两个通用的错误处理函数:</p>
<ul>
  <li>debug.debug：提供一个Lua提示符，让用户来价差错误的原因</li>
  <li>debug.traceback：根据调用桟来构建一个扩展的错误消息。</li>
</ul>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">xpcall</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="nb">error</span><span class="p">(</span><span class="s1">'error..'</span><span class="p">)</span> <span class="k">end</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="nb">print</span><span class="p">(</span><span class="nb">debug.traceback</span><span class="p">())</span> <span class="k">end</span><span class="p">,</span> <span class="mi">33</span><span class="p">)</span>
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>lua 函数</title>
      <link href="http://localhost:4000/lua-function/"/>
      <pubDate>2017-03-15T19:16:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-function</guid>
      <content:encoded><![CDATA[<p>lua的函数有必要记录可能也就是 可变参数, 后面的命名参数和多个返回值和python基本一样。</p>

<h3 id="可变参数">可变参数</h3>

<p>Lua 函数可以接受可变数目的参数，和 C 语言类似在函数参数列表中使用三点（…）
表示函数有可变的参数。Lua 将函数的参数放在一个叫 arg 的表中，除了参数以外，arg
表中还有一个域 n 表示参数的个数。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">g</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="k">end</span>

<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">nil</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span>
<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span>
<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">;</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">}</span>

</code></pre>
</div>
<p>Lua 的函数还一些特性和C不一样的是：它和其他值（数值、字符串）一样，函数可以被存放在变
量中，也可以存放在表中，可以作为函数的参数，还可以作为函数的返回值。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span> <span class="o">=</span> <span class="nb">math.sin</span> <span class="c1">-- `print' now refers to the sine function</span>
<span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">(</span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">--&gt; 0.841470</span>
</code></pre>
</div>

<p>如函数被嵌套的函数里，它可以访问他外部函数中的变量。这一特性强大编程能力。</p>

<p>另一个特征是：匿名函数。</p>

<p>用表达式创建函数：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">foo</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="k">end</span>
</code></pre>
</div>

<h3 id="闭包">闭包</h3>

<p>当一个函数内部嵌套另一个函数定义时，内部的函数体可以访问外部的函数的局部变量，这种特征我们称作词法定界。虽然这看起来很清楚，事实并非如此，词法定界加上第一类函数在编程语言里是一个功能强大的概念，很少语言提供这种支持。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">newCounter</span><span class="p">()</span>
	<span class="kd">local</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">return</span> <span class="k">function</span><span class="p">()</span> <span class="c1">-- anonymous function</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">i</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">newCounter</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 2</span>

</code></pre>
</div>
<p>i不是全局变量也不是局部变量，我们称作外部的局部变量（external local variable）或者 upvalue。</p>

<p>匿名函数使用 upvalue i 保存他的计数，当我们调用匿名函数的时候 i 已经超出了作用范围，因为创建 i 的函数 newCounter 已经返回了。然而 Lua 用闭包的思想正确处理了这种情况。简单的说闭包是一个函数加上它可以正确访问的 upvalues。如果我们再次调
用 newCounter，将创建一个新的局部变量 i，因此我们得到了一个作用在新的变量 i 上的
新闭包。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">c2</span> <span class="o">=</span> <span class="n">newCounter</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c2</span><span class="p">())</span> <span class="c1">--&gt; 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c2</span><span class="p">())</span> <span class="c1">--&gt; 2</span>

</code></pre>
</div>
<p>技术上来讲，闭包指值而不是指函数，函数仅仅是闭包的一个原型声明；尽管如此，
在不会导致混淆的情况下我们继续使用术语函数代指闭包。</p>

<p>闭包在上下文环境中提供很有用的功能，如高级函数（sort）的参数；作为函数嵌套的函数（newCounter）。这一机制使得我们可以在 Lua 的函数世界里组合出奇幻的编程技术。闭包也可用在回调函数中。</p>

<h3 id="全局函数和局部函数">全局函数和局部函数</h3>

<p>局部函数就是在函数前加一个 local。</p>

<p>局部函数的两种方式：</p>

<ol>
  <li>方式一</li>
</ol>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="n">f</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">end</span>
<span class="kd">local</span> <span class="n">g</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">f</span><span class="p">()</span> <span class="c1">-- external local `f' is visible here</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre>
</div>

<ol>
  <li>方式二</li>
</ol>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="k">function</span> <span class="nf">f</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>有一点需要注意的是在声明递归局部函数的方式。
要提前定义local。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="kd">local</span> <span class="n">fact</span>
<span class="n">fact</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<h3 id="尾调用proper-tail-calls">尾调用（Proper Tail Calls）</h3>

<p>尾调用是一种类似在函数结尾的 goto 调用，当函数最后一个动作是调用另外一个函
数时，我们称这种调用尾调用。例如：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>g 的调用是尾调用。</p>

<p>例子中 f 调用 g 后不会再做任何事情，这种情况下当被调用函数 g 结束时程序不需
要返回到调用者 f；所以尾调用之后程序不需要在栈中保留关于调用者的任何信息。</p>

<p>如下三种不是尾调函数.</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="n">r</span> <span class="n">eturn</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">-- must do the addition</span>
<span class="k">return</span> <span class="n">x</span> <span class="ow">or</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1">-- must adjust to 1 result</span>
<span class="k">return</span> <span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">-- must adjust to 1 result</span>
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>日志模块</title>
      <link href="http://localhost:4000/model-log/"/>
      <pubDate>2016-12-15T17:23:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/model-log</guid>
      <content:encoded><![CDATA[<p>系统的开发，日志模块的是必不可少的。特别对于业务逻辑层的来说，有日志输出，很方便跟踪逻辑大概情况。但是对于底层的核心模块来说，日志输出反而成了累赘。日志的输出同样占有I/O。再者，对于底层的逻辑，一般都是比较复杂，核心。暴露出来也没必要。业务逻辑层同样没有必要去了解它。所以，一般的做法是：底层出错，返回错误编码。由上一层记录就OK了。</p>

<p>日志模块一般可以分为 print/note、 debug、 warn、error。人个觉得这四个层次就够了。当然，也可多增加几个，例如，trac。我曾经用于特别的调试，只是一些非必现的问题调试，把日志输出到这层，方便查找。</p>

<p>对于这四层，是分开几个文件，还是在同一个文件中？ 其实这两种方式我都用过。这些年的经验，感觉写到同一个文件中，比较分四个文件要好。理由是很清楚的知道日志输出的前后时间顺序。当然分开成几个日志文件输出，也是有办法按时间查看的，只要用linux的一些工具手段而已。分开成几个文件的好处，就是一看就知道是否有错误输出了。同一个文件，只能在文件中查到才知道。</p>

<p>无论是 apache,还是nignx，日志的输出都是分层，配置不同层次的，只有高于或等于它的才能被输出。当然，我们设计时也可以直接指定层次print、warn、error。</p>

<p>有日志输出，就意味着有日志文件的管理。如文件大小、文件命名、所在目录、如何清理。
一般，我的做法是日志文件的大小设计成可配置。在相关的配置文件中指定。
二，日志文件的命名，我是按模块名来命名（即进程名）。或加上日期或日期在体现在目录上。
三，所在目录，我选择是把所有的日志放到同一个Log目录下，千万别把分别放到不同模块的目录里面。这样做的好处是：我们可以系统中划出一个分区来，专门存放日志，和服务的进程分离开。这样做的理由是：如果日志输出过来，把硬盘空间爆了，不会影响到服务的运行。
四，对清理， 我没有体现在于日志模块里，而是用计划任务做定时清理。</p>

<p>日志模块应该有可配置性。 一般有：
路径、文件大小、模块名、输出层次、</p>

<p>日志的输出涉及到I/O。所以对效率是有一定的影响的。 必竞这是定文件的。有一个很不错的设计：就是日志写到队列（用共享内存实现 的）然后由专门的日志进程（logsvr）输出到文件中。这样日志输出就不会有I/O阻塞了，提高一些效率。</p>

<p>下一回，把日志的模块整理好，分析一下。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>余华-活着</title>
      <link href="http://localhost:4000/alive/"/>
      <pubDate>2016-10-15T17:23:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/alive</guid>
      <content:encoded><![CDATA[<p>这本书是从微博上看网友介绍的，还是朋友介绍的，我也不记得了。在kindle上看有已经购买。应该是一次买了后，忘记了看了。这两天上下班在地铁上，就把它给看了。</p>

<p>书里的主人公叫福贵。一个旧社会里的有钱人的少爷。年少时就一个败家子。按他妈的说法是上梁不正下梁歪。因为他老子年轻也也是败家子，败了家里的一百多亩田地。后来开窍了，好好的在经营自己的田地。他就边上厕所也会跑到自家的田地，可是就是肥水不流外人田的吧。老子还是蛮希望福贵能光大门楣的。结果还是一败家子。把他没败完的另一百多亩也败完了。</p>

<p>最后他爸把所有的田契和房契都让人换成了铜钱，整整三大担。让福贵自己挑去还赌债。福贵把肩膀都磨破了。才知道祖辈挣下这些钱不知要累死多少人。他自己挑都快累死了。这时才知道他老子为什么不要银元要铜钱。
破产后，他们只能去住茅草屋。没多久福贵的老子在拉屎的时候死了。家里能卖的东西也都卖光了。福贵只能去租田来种，可他是个就个少爷。可怜了他的老妈和老婆。
话说他老婆也是个好女人。一个城里米行的小姐，也读过书。嫁给一个败家子。最后再怎么受苦也跟定他了。 在福贵去城里为他妈找大夫时，他被国民党抓了壮丁。一去就是五年，幸好没有死，被共产党俘虏后放了。到家时，他妈死了，大女儿在生病时聋哑啊。小儿子也不认识他了。</p>

<p>然后，解放了，新中国成立了， 三反三反，大跃进，砸锅炼钢，文化大革命。开始了生产大队的大食堂的生活，最后没粮食了，食堂解散了，大伙都没有吃的。只能挖树根，然后说着要相信政府，相信党。可队长每一次都是空手而回的。大伙开始去乞讨，福贵的老婆说要去城里看望老父，其实就是去乞讨。却真的在街上碰到了父亲。（真想知道他们当时的场景）老父给她从自己的牙缝里省下的来小米。她高兴的回到家，福贵去不敢开社，因为知道一开灶全村都知道了。福贵要确认村里没有人才敢开灶。这让我想我爸说过一件。有一次，我开玩笑的对他说，如果中国经济真的不行了。我们是不是家里存点什么东西啊。他说：没什么用， 全村都没有，就我们家有，也是存不了的。想到爸之前的意思，他是不是以前就经历过这样的事。</p>

<p>儿子在医院给他输血时，被抽空死了。聋哑女儿好不容易嫁了个好人歪头。却在难产也死了。老婆却一直在生病，在女儿死后三个月也死了。儿子女子都死了，她没什么好操心的了。她死后也有福贵料理后事。而福贵的后事也有他的外孙。所以她死得安心。接下来的，是他的女婿歪头也在工地出意外死了，留下了外孙和他相依为命。可最后，边他的外孙也在吃豆撑死了。在福贵年迈时，他所有的亲人都死了。</p>

<p>他在床边放十块钱，全村的人都知道，那是给替他收尸的人的。他存了几年的钱，想为他外孙买头牛。却在看到别人宰杀一头老牛时，心生怜悯。买了一头老牛。村里人都是这牛活不过四五年，可他却不在意，他觉得自己的自己应该活不了那么久。</p>

<p>写得比较朴素简单，文字很简单。但福贵的命却是很悲剧的。不过，过他福贵自己讲出来的人生却没有悲剧的感觉。可能这就是《活着》想表达的东西吧。</p>

<p>最后想说的，那真个操蛋的年代 。</p>

<p>– 深圳 北站</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>libevent 初步分析</title>
      <link href="http://localhost:4000/libevent-base/"/>
      <pubDate>2016-07-16T01:32:03+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/libevent-base</guid>
      <content:encoded><![CDATA[<h3 id="一-reactor模式">一 reactor模式</h3>

<p>整个libevent本身就是一个reactor。reactor翻译成反应堆，是一种事件驱动机制。libevent，底层所运用的就是例epoll这样的一些模型。</p>

<p>应用程序一般都要在reactor注册回调函数。当事件被触发时，回调函数会被调用。这些事件可能是I/O读写， 定时器和信号。</p>

<p>reactor模型：必备的几个组件：事件源、reactor框架、多路利用机制和事件处理函数。</p>

<p><strong>事件源：</strong></p>

<p>Linux上是文件描述符， win下的socket 或 handle.</p>

<p><strong>event demultipexer (事件多路分发机制)：</strong></p>

<p>linux下如：epoll、 select、kqueue、devpoll</p>

<p>当有事件到达时， event demultiplexer会发出通知。这时相关的事件就成了就绪状态。libevent会在非阻塞的情况下进行处理。</p>

<p>libevent用 eventtop对 select epoll poll 等进行了封闭，形成统一的接口。</p>

<p><strong>reactor 反应器：</strong></p>

<p>reactor是事件管理接口。内部使用 event demultiplexer 注册、注销事件；并运行事件循环，
当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。对应到 libevent 中，就是 event_base 结构体。</p>

<p><strong>事件处理流程图：</strong></p>

<p>1）首先应用程序准备并初始化 event，设置好事件类型和回调函数；</p>

<p>2）向 libevent 添加该事件 event。对于定时事件， libevent 使用一个小根堆管理， key 为超
时时间；对于 Signal 和 I/O 事件， libevent 将其放入到等待链表（ wait list）中，这是一
个双向链表结构；</p>

<p>3） 程序调用 event_base_dispatch()系列函数进入无限循环，等待事件，以 select()函数为例；
每次循环前 libevent 会检查定时事件的最小超时时间 tv，根据 tv 设置 select()的最大等
待时间，以便于后面及时处理超时事件；当 select()返回后，首先检查超时事件，然后检查 I/O 事件；</p>

<p><img src="/assets/network/libevent_event_next.png" alt="" /></p>

<h3 id="二--源码文件组织结构">二  源码文件组织结构</h3>

<p>头文件、内部使用的头文件、辅助功能函数、日志、libevent框架、对系统I/O多路复用机制的封装
信号管理、定时事件管理、缓冲区管理、基本数据和基于libevent的两个实用库的向个部分。</p>

<p><strong>头文件</strong></p>

<p>event.h：事件宏定义、接口函数声明，主要结构体event的声明；</p>

<p>xxx-internal.h：内部数据结构和函数，对外不可见，以达到信息隐藏的目的；</p>

<p><strong>libevent框架</strong></p>

<p>event.c：event整体框架的代码实现；</p>

<p>对系统I/O多路复用机制的封装</p>

<ul>
  <li>epoll.c：对epoll的封装；</li>
  <li>select.c：对select的封装；</li>
  <li>devpoll.c：对dev/poll的封装;</li>
  <li>kqueue.c：对kqueue的封装；</li>
</ul>

<p><strong>定时事件管理</strong></p>

<p>min-heap.h：其实就是一个以时间作为key的小根堆结构；</p>

<p><strong>信号管理</strong></p>

<p>signal.c：对信号事件的处理；</p>

<p><strong>辅助功能函数</strong></p>

<p>evutil.h 和evutil.c：一些辅助功能函数，包括创建socket pair和一些时间操作函数：加、减和比较等。</p>

<p><strong>日志</strong></p>

<p>log.h和log.c：log日志函数</p>

<p><strong>缓冲区管理</strong></p>

<p>evbuffer.c和buffer.c：libevent对缓冲区的封装；</p>

<p><strong>基本数据结构</strong></p>

<p>compat\sys下的两个源文件：queue.h是libevent基本数据结构的实现，包括链表，双向链表，队列等；
_libevent_time.h：一些用于时间操作的结构体定义、函数和宏定义；</p>

<p><strong>实用网络库</strong></p>

<p>http和evdns：是基于libevent实现的http服务器和异步dns查询库</p>

<h3 id="三-事件event">三 事件event</h3>

<p>主要的结构体：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event_base</span> <span class="c1">// event最主要的结构，
</span><span class="k">struct</span> <span class="n">eventop</span>    <span class="c1">// 定义backend结构， 通过它定义各个模型，
</span></code></pre>
</div>

<ul>
  <li>ev_events： event关注的事件类型，它可以是以下3种类型：</li>
  <li>I/O事件：  EV_WRITE和EV_READ</li>
  <li>定时事件： EV_TIMEOUT</li>
  <li>信号：     EV_SIGNAL</li>
  <li>辅助选项： EV_PERSIST，表明是一个永久事件</li>
</ul>

<p>ev_next， ev_active_next 和 ev_signal_next 都是双向链表节点指针。</p>

<p>I/O和Signal事件使用了双向链表。</p>

<p>定时事件 使用了小根堆 min_heap_idx.</p>

<p>ev_next 是该I/O事件在链表中的位置，表示是“已注册事件链表”。
ev_signal_next signal事件在signal事件链表中的位置。
ev_active_next libevent将所有的激活事件放入到链表active list中，然后遍历 active list执行调度，ev_active_next就指明了event在active list中的位置。</p>

<p><strong><em>libevent 对 event 的管理</em></strong></p>

<p><img src="/assets/network/libevent_event_managemant.png" alt="" /></p>

<p>事件设置的接口函数</p>

<p>libevent 提供了函数：event_set(), event_base_set(), event_priority_set()。</p>

<p>设置事件 如：I/O事件、 时间事件、信号事件:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">event_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</code></pre>
</div>

<p>设置 event ev 将要注册到的 event_base；</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_base_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">)</span>
</code></pre>
</div>

<p>设置event ev的优先级:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_priority_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pri</span><span class="p">)</span>
</code></pre>
</div>

<h3 id="四-事件处理框架">四 事件处理框架</h3>

<p>事件处理都是围绕着 event_base。</p>

<p>初始化一个 event_base。 本质上是调用了 event_base_new_with_config。</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span> <span class="n">event_init</span><span class="p">()</span>
</code></pre>
</div>

<p>也是 初始化一个 event_base。不同的是 先创建了一个struct event_config。 这个东西是干什么用的还清楚。</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span> <span class="n">event_base_new</span><span class="p">()</span>
</code></pre>
</div>

<p>内部主要调用了 event_add_internal()</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</code></pre>
</div>

<p>内部主要调用了 event_del_internal()</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_base_loop</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loops</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">event_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">);</span>
	
<span class="kt">void</span> <span class="n">event_process_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="五--事件主循环">五  事件主循环</h3>

<p>struct evsig_info // 这个又是干吗的？</p>

<p><strong>I/O和Timer事件的统一</strong></p>

<p>libevent将Timer和Signal事件都统一到了系统的I/O 的demultiplex机制中了，</p>

<p>堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)。而获取最小key值（小根堆）的复杂度为O(1)。</p>

<p><strong>I/O和Signal事件的统一</strong></p>

<p>如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I/O机制，让其返回，然后再统一和I/O事件以及Timer一起处理。</p>

<h3 id="六-集成信号处理">六 集成信号处理</h3>

<p>singal和I/O的事件统一是通过 socket pair的方式实现。（这个方式有点像是管道）</p>

<h3 id="七-io多路复用技术">七 I/O多路复用技术</h3>

<p>libevent根据系统配置和编译选项决定使用哪一种I/O demultiplex机制，而不支持在运行阶段根据配置再次选择。</p>

<h3 id="十一-时间管理">十一 时间管理</h3>

<p>Libevent 本身不是多线程安全的
libevent 库的其他组件提供其他功能，包括缓冲的事件系统（用于缓冲发送到客户端/从客户端接收的数据）以及 HTTP、DNS 和 RPC 系统的核心实现。</p>

<p>可以对比一下 libev</p>

<hr />

<p>参考：<a href="http://pan.baidu.com/s/1hssU5KC"><strong>libevent源码深度剖析.pdf</strong></a></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>redis 配置说明</title>
      <link href="http://localhost:4000/redis-config/"/>
      <pubDate>2015-02-04T23:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/redis-config</guid>
      <content:encoded><![CDATA[<h3 id="redis-支持写的指令">Redis 支持写的指令</h3>
<p>Redis大概的命令如下：</p>

<blockquote>
  <p>set setnx setex append
incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
getset mset msetnx exec sort</p>
</blockquote>

<h3 id="redis-配置">Redis 配置</h3>

<ol>
  <li>redis 配置文件一般是在/etc/redis.conf</li>
  <li>redis官方提供的redis.conf文件，足有700+行，其中100多行为有效配置行，另外的600多行为注释说明。</li>
  <li>redis配置中对单位的大小写不敏感，1GB、1Gb和1gB都是相同的。由此也说明，redis只支持bytes，不支持bit单位。</li>
  <li>redis支持“主配置文件中引入外部配置文件  include /path/to/other.conf</li>
  <li>redis 开头的单位转换：（从配置文件中copy出来）
    <div class="language-sh highlighter-rouge"><pre class="highlight"><code> <span class="c"># 1k =&gt; 1000 bytes</span>
 <span class="c"># 1kb =&gt; 1024 bytes</span>
 <span class="c"># 1m =&gt; 1000000 bytes</span>
 <span class="c"># 1mb =&gt; 1024*1024 bytes</span>
 <span class="c"># 1g =&gt; 1000000000 bytes</span>
 <span class="c"># 1gb =&gt; 1024*1024*1024 bytes</span>
 <span class="c">#</span>
 <span class="c"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span>
</code></pre>
    </div>
  </li>
  <li>redis配置文件被分成了几大块区域:
    <div class="language-sh highlighter-rouge"><pre class="highlight"><code> 1<span class="o">)</span>通用（general）
 2<span class="o">)</span>快照（snapshotting）
 3<span class="o">)</span>复制（replication）
 4<span class="o">)</span>安全（security）
 5<span class="o">)</span>限制（limits<span class="o">)</span>
 6<span class="o">)</span>追加模式（append only mode<span class="o">)</span>
 7<span class="o">)</span>LUA脚本（lua scripting<span class="o">)</span>
 8<span class="o">)</span>慢日志（slow log<span class="o">)</span>
 9<span class="o">)</span>事件通知（event notification）
</code></pre>
    </div>
    <h3 id="通用">通用</h3>
  </li>
</ol>

<p>1 daemon  ： redis 是可以以后台服务运行的。</p>

<p>以daemon形式运行时，redis会生成一个pid文件，默认会生成在/var/run/redis.pid。当然，你可以通过pidfile来指定pid文件生成的位置。</p>

<p>2 pidfile ：配置pid文件路径 pidfile /path/to/redis.pid</p>

<p>3 bind    ：redis会响应本机所有可用网卡的连接请求。当然，redis允许你通过bind配置项来指定要绑定的IP  bind 192.168.1.2 10.8.4.2</p>

<p>4 port    ：redis的默认服务端口是6379，你可以通过port配置项来修改。如果端口设置为0的话，redis便不会监听端口了。</p>

<p>5 unixsocket  ：如果redis不监听端口，redis还支持通过unix socket方式来接收请求。 可以通过unixsocket配置项来指定unix socket文件的路径，并通过unixsocketperm来指定文件的权限</p>

<p>6 unixsocketperm : 来指定文件的权限;</p>

<p>7 timeout ： 当一个redis-client一直没有请求发向server端，那么server端有权主动关闭这个连接，可以通过timeout来设置“空闲超时时限”，0表示永不关闭。</p>

<p>8 tcp-keepalive  ：TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒。  假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。  所以关闭一个连接最长需要120秒的时间。如果设置为0，则不会进行保活检测。</p>

<p>9  loglevel ：配置项设置日志等级，共分四级，即debug、verbose、notice、warning。</p>

<p>10 logfile  ：设置日志文件的生成位置。如果设置为空字符串，则redis会将日志输出到标准输出。
 假如你在daemon情况下将日志设置为输出到标准输出，则日志会被写到/dev/null中。</p>

<p>11 databases  ：设置其数据库的总数量，假如你希望一个redis包含16个数据库。 
 数据库的编号将是0到15。默认的数据库是编号为0的数据库。用户可以使用select <DBid>来选择相应的数据库。</DBid></p>

<p>12 syslog-ident   ： 不了解</p>

<p>13 syslog-facility： 不了解</p>

<h3 id="快照-主要涉及的是redis的rdb持久化相关的配置">快照 （主要涉及的是redis的RDB持久化相关的配置）</h3>

<p>1 save <seconds> <changes>  ：让数据保存到磁盘上，即控制RDB快照功能。
如果你想禁用RDB持久化的策略，只要不设置任何save指令就可以，或者给save传入一个空字符串参数也可以达到相同效果　</changes></seconds></p>

<p>如：</p>
<div class="language-sh highlighter-rouge"><pre class="highlight"><code> // --------------------------------------------------------
 <span class="c">#save 900 1     // 表示每15分钟且至少有1个key改变，就触发一次持久化</span>
 <span class="c">#save 300 10    // 表示每5分钟且至少有10个key改变，就触发一次持久化</span>
 <span class="c">#save 60  10000 // 表示每60秒至少有10000个key改变，就触发一次持久化</span>
 <span class="c">#save ""        // 禁用</span>
// --------------------------------------------------------
</code></pre>
</div>

<p>2 stop-writes-on-bgsave-error ： 如果开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求</p>

<p>3 rdbcompression ：是否进行压缩。</p>

<p>4 rdbchecksum  ：是否CRC检验， 如果要有最大性能， 可以关闭，大概消10%的性能。</p>

<p>5 dbfilename  ：快照文件的名称，默认是这样配置的。
6 dir   ： 快照文件存放的路径。比如默认设置就是当前文件夹</p>

<h3 id="复制-就是主从同步功能">复制 （就是主从同步功能）</h3>

<p>1 slaveof <masterip> <masterport> :  通过slaveof配置项可以控制某一个redis作为另一个redis的从服务器，通过指定IP和端口来定位到主redis的位置。</masterport></masterip></p>

<p>一般情况下，我们会建议用户为从redis设置一个不同频率的快照持久化的周期，或者为从redis配置一个不同的服务端口等等。</p>

<p>2 masterauth <master-password>    : 如果主redis设置了验证密码的话（使用requirepass来设置），则在从redis的配置中要使用masterauth来设置校验密码，否则的话，主redis会拒绝从redis的访问请求。</master-password></p>

<p>*当从redis失去了与主redis的连接，或者主从同步正在进行中时，redis该如何处理外部发来的访问请求呢？</p>

<p>这里，从redis可以有两种选择：
   a)如果slave-serve-stale-data设置为yes（默认），则从redis仍会继续响应客户端的读写请求。     <br />
　 b)如果slave-serve-stale-data设置为no，则从redis会对客户端的请求返回“SYNC with master in progress”， 
当然也有例外，当客户端发来INFO请求和SLAVEOF请求，从redis还是会进行处理。</p>

<p>３ 你可以控制一个从redis是否可以接受写请求。将数据直接写入从redis，一般只适用于那些生命周期非常短的数据，因为在主从同步时，这些临时数据就会被清理掉。</p>

<p>自从redis2.6版本之后，默认从redis为只读。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>  <span class="c"># slave-read-only yes </span>
</code></pre>
</div>

<h3 id="安全">安全</h3>

<p>1 requirepass ： 设置密码。 由于redis性能非常高，所以每秒钟可以完成多达15万次的密码尝试，所以你最好设置一个足够复杂的密码，否则很容易被黑客破解
2  rename-command  ： redis允许我们对redis指令进行更名，比如将一些比较危险的命令改个名字，避免被误执行。
 比如可以把CONFIG命令改成一个很复杂的名字，这样可以避免外部的调用，同时还可以满足内部调用的需要：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c89 //  命令重命名
rename-command CONFIG <span class="s2">""</span>                                       //  禁用
</code></pre>
</div>

<h3 id="限制">限制</h3>

<p>1  maxclients ： 设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。
    当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。</p>

<p>2 maxmemory ： 设置redis可以使用的内存量。</p>

<p>一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>

<p>需要注意的一点是，如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，</p>

<p>需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>

<p>3 maxmemory-policy： 内存移除策略。</p>

<p>对于内存移除规则来说，redis提供了多达6种的移除规则。他们是：</p>

<p>1) volatile-lru：使用LRU算法移除过期集合中的key</p>

<p>2) allkeys-lru：使用LRU算法移除key</p>

<p>3) volatile-random：在过期集合中移除随机的key</p>

<p>4) allkeys-random：移除随机的key</p>

<p>5) volatile-ttl：移除那些TTL值最小的key，即那些最近才过期的key。</p>

<p>6) noeviction：不进行移除。针对写操作，只是返回错误信息。</p>

<h3 id="追加模式">追加模式</h3>

<p>1 默认情况下，redis会异步的将数据持久化到磁盘。这种模式在大部分应用程序中已被验证是很有效的。
   但是在一些问题发生时，比如断电，则这种机制可能会导致数分钟的写请求丢失。追加文件（Append Only File）是一种更好的保持数据一致性的方式。</p>

<p>即使当服务器断电时，也仅会有1秒钟的写请求丢失，当redis进程出现问题且操作系统运行正常时，甚至只会丢失一条写请求。
                             　
2  appendonly ：开关   // appendonly　no  关闭追加功能</p>

<p>3 appendfilename　：文件名 // appendfilename  “appendonly.aof”</p>

<p>4 appendfsync  : fsync()调用方式 默认情况下为everysec  // appendfsync everysec</p>

<p>redis支持三种不同的模式：</p>

<p>a) no：不调用fsync()。而是让操作系统自行决定sync的时间。这种模式下，redis的性能会最快。
  b) always：在每次写请求后都调用fsync()。这种模式下，redis会相对较慢，但数据最安全。
  c) everysec：每秒钟调用一次fsync()。这是性能和安全的折衷。</p>

<p>5 当fsync方式设置为always或everysec时，如果后台持久化进程需要执行一个很大的磁盘IO操作，那么redis可能会在fsync()调用时卡住。
  目前尚未修复这个问题，这是因为即使我们在另一个新的线程中去执行fsync()，也会阻塞住同步写调用。</p>

<p>6 为了缓解这个问题，我们可以使用下面的配置项，这样的话，当BGSAVE或BGWRITEAOF运行时，fsync()在主进程中的调用会被阻止。
    这意味着当另一路进程正在对AOF文件进行重构时，redis的持久化功能就失效了，就好像我们设置了“appendsync none”一样。如果你的redis有时延问题，那么请将下面的选项设置为yes。否则请保持no，因为这是保证数据完整性的最安全的选择.</p>
<div class="language-sh highlighter-rouge"><pre class="highlight"><code>no-appendfsync-on-rewrite no   
</code></pre>
</div>
<p>7 只读的从redis并不适合直接暴露给不可信的客户端。为了尽量降低风险，可以使用rename-command指令来将一些可能有破坏力的命令重命名，避免外部直接调用。比如：</p>
<div class="language-sh highlighter-rouge"><pre class="highlight"><code> rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
</code></pre>
</div>

<p>8 repl-ping-slave-period : 从redis会周期性的向主redis发出PING包。你可以通过repl_ping_slave_period指令来控制其周期。默认是10秒。</p>
<div class="language-sh highlighter-rouge"><pre class="highlight"><code> <span class="c"># repl-ping-slave-period 10</span>
</code></pre>
</div>

<p>9  repl-timeout  :  主从之间超时的时限， #repl-timeout 60</p>

<p>在主从同步时，可能在这些情况下会有超时发生：</p>

<p>a)以从redis的角度来看，当有大规模IO传输时。</p>

<p>b)以从redis的角度来看，当数据传输或PING时，主redis超时.</p>

<p>c)以主redis的角度来看，在回复从redis的PING时，从redis超时.</p>

<p>10 repl-disable-tcp-nodelay :  控制在主从同步时是否禁用TCP_NODELAY。如果开启TCP_NODELAY，那么主redis会使用更少的TCP包和更少的带宽来向从redis传输数据。但是这可能会增加一些同步的延迟，大概会达到40毫秒左右。
 如果你关闭了TCP_NODELAY，那么数据同步的延迟时间会降低，但是会消耗更多的带宽。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>    <span class="c"># repl-disable-tcp-nodelay no</span>
</code></pre>
</div>

<p>11  repl-backlog-size :  设置同步队列长度。队列长度（backlog)是主redis中的一个缓冲区，在与从redis断开连接期间，
  主redis会用这个缓冲区来缓存应该发给从redis的数据。这样的话，当从redis重新连接上之后，就不必重新全量同步数据，只需要同步这部分增量数据即可.</p>
<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># repl-backlog-size 1mb</span>
</code></pre>
</div>

<p>12 repl-backlog-ttl :  如果主redis等了一段时间之后，还是无法连接到从redis，那么缓冲队列中的数据将被清理掉。 我们可以设置主redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>  <span class="c"># repl-backlog-ttl 3600  </span>
</code></pre>
</div>

<p>13 slave-priority  : 我们可以给众多的从redis设置优先级，在主redis持续工作不正常的情况，优先级高的从redis将会升级为主redis。
     而编号越小，优先级越高。比如一个主redis有三个从redis，优先级编号分别为10、100、25，那么编号为10的从redis将会被首先选中升级为主redis。 当优先级被设置为0时，这个从redis将永远也不会被选中。默认的优先级为100。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code> <span class="c"># slave-priority 100    </span>
</code></pre>
</div>

<p>14  假如主redis发现有超过M个从redis的连接延时大于N秒，那么主redis就停止接受外来的写请求。
 这是因为从redis一般会每秒钟都向主redis发出PING，而主redis会记录每一个从redis最近一次发来PING的时间点，
 所以主redis能够了解每一个从redis的运行情况。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># min-slaves-to-write 3</span>
<span class="c"># min-slaves-max-lag 10</span>

<span class="c"># 上面这个例子表示，假如有大于等于3个从redis的连接延迟大于10秒，那么主redis就不再接受外部的写请求。</span>
<span class="c"># 上述两个配置中有一个被置为0，则这个特性将被关闭。默认情况下min-slaves-to-write为0，而min-slaves-max-lag为10。</span>
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>redis 基本操作</title>
      <link href="http://localhost:4000/redis-base-operating/"/>
      <pubDate>2015-02-03T19:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/redis-base-operating</guid>
      <content:encoded><![CDATA[<h4 id="redis-数据类型">Redis 数据类型</h4>

<p>Redis支持5种类型的数据类型，它描述如下的:</p>

<p>1 字符串</p>

<p>Redis字符串是字节序列。Redis字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512兆为上限。</p>

<p>2 哈希</p>

<p>Redis的哈希是键值对的集合。
Redis的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象.</p>

<p>3 列表</p>

<p>Redis的列表是简单的字符串列表，排序插入顺序。您可以添加元素到Redis的列表的头部或尾部。
列表的最大长度为 232 - 1 元素（4294967295，每个列表中可容纳超过4十亿的元素）。</p>

<p>4 集合</p>

<p>Redis的集合是字符串的无序集合。在Redis您可以添加，删除和测试文件是否存在，在成员O（1）的时间复杂度。</p>

<p>集合中的元素最大数量为 232 - 1 （4294967295，可容纳超过4十亿元素）。</p>

<p>5 有序集合</p>

<p>Redis的有序集合类似于Redis的集合，字符串不重复的集合。不同的是，一个有序集合的每个成员用分数，以便采取有序set命令，从最小的到最大的成员分数有关。虽然成员具有唯一性，但分数可能会重复。</p>

<h3 id="redis-文件说明">Redis 文件说明</h3>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>find . -type f -executable
./redis-benchmark      // 用于进行redis性能测试的工具

./redis-check-dump     // 用于修复出问题的dump.rdb文件
./redis-cli            // redis的客户端
./redis-server         // redis的服务端
./redis-check-aof      // 用于修复出问题的AOF文件
./redis-sentinel       // 用于集群管理
</code></pre>
</div>

<h3 id="redis-管理">Redis 管理</h3>

<ol>
  <li>服务启动：
    <div class="language-sh highlighter-rouge"><pre class="highlight"><code> ./redis-server ../redis.conf  端口默认为6379
</code></pre>
    </div>
  </li>
  <li>使用客户端：
    <div class="language-sh highlighter-rouge"><pre class="highlight"><code> ./redis-cli
</code></pre>
    </div>
  </li>
  <li>通过客户端来关闭redis服务端
    <div class="language-sh highlighter-rouge"><pre class="highlight"><code> 127.0.0.1:6379&gt; shutdown 
</code></pre>
    </div>
  </li>
  <li>一些注意:
    <ul>
      <li>key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；</li>
      <li>key也不要太短，太短的话，key的可读性会降低；</li>
      <li>在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</li>
      <li>字符串类型的用法就是这么简单，因为是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储。</li>
    </ul>
  </li>
</ol>

<h3 id="redis-持久化">Redis 持久化</h3>

<ol>
  <li>Redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</li>
  <li>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</li>
  <li>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来.在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</li>
  <li>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</li>
  <li>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</li>
  <li>两种方式是可以同时使用的。</li>
</ol>

<h3 id="redis持久化--rdb">Redis持久化 – RDB</h3>

<ol>
  <li>Redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</li>
  <li>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</li>
</ol>

<h3 id="redis持久化---aof">Redis持久化 - AOF</h3>

<ol>
  <li>AOF，英文是Append Only File，即只允许追加不允许改写的文件。</li>
  <li>通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</li>
  <li>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中）.
因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</li>
  <li>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。</li>
  <li>AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，
    <ul>
      <li>即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。</li>
    </ul>
  </li>
  <li>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性.</li>
  <li>AOF的一个好处场景再现，如果有人不小心清了数据库。在AOF文件还没没被重写的情况下， 可以通过停掉Redis修改AOF文件，去掉误操作的语句。重启Redis恢复数据。</li>
  <li>如果出现AOF文件被写坏的情况。可按如下步骤修复：
    a.备份被写坏的AOF文件
    b.运行redis-check-aof –fix进行修复
    c.用diff -u来看下两个文件的差异，确认问题点
    d.重启redis，加载修复后的AOF文件</li>
</ol>

<h3 id="redis-主从同步">Redis 主从同步</h3>

<ol>
  <li>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。</li>
  <li>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</li>
  <li>在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。
  但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。
  如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</li>
</ol>

<ul>
  <li>如何重命名指令？？？</li>
</ul>

<h3 id="redis-同步">Redis 同步</h3>

<ol>
  <li>从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。
  在数据持久化期间，主服务器将执行的写指令都缓存在内存中。</li>
  <li>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。
  这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</li>
</ol>

<h3 id="redis-事务">Redis 事务</h3>

<ol>
  <li>事务是指“一个完整的动作，要么全部执行，要么什么也没有做”。</li>
  <li>四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。
    <ol>
      <li>MULTI用来组装一个事务；</li>
      <li>EXEC用来执行一个事务；</li>
      <li>DISCARD用来取消一个事务；</li>
      <li>WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。</li>
    </ol>
  </li>
</ol>

<p>例子：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>    redis&gt; MULTI         //标记事务开始 
    OK
    redis&gt; INCR user_id //多条命令按顺序入队
    QUEUED
    redis&gt; INCR user_id
    QUEUED
    redis&gt; INCR user_id
    QUEUED
    redis&gt; PING
    QUEUED
    redis&gt; EXEC //执行
    1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> 1
    2<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> 2
    3<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> 3
    4<span class="o">)</span> PONG
</code></pre>
</div>

<ol>
  <li>QUEUED的字样，这表示我们在用MULTI组装事务时，每一个命令都会进入到内存队列中缓存起来，如果出现QUEUED则表示我们这个命令成功插入了缓存队列，在将来执行EXEC时，这些被QUEUED的命令都会被组装成一个事务来执行.</li>
  <li>对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去。
如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况。这时，我们可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。</li>
  <li>两类错误：
    <ul>
      <li>调用EXEC之前的错误。
 有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。</li>
      <li>调用EXEC之后的错误。
  Redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。</li>
    </ul>
  </li>
  <li>WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>redis 查看版本</title>
      <link href="http://localhost:4000/redis-version/"/>
      <pubDate>2015-02-03T19:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/redis-version</guid>
      <content:encoded><![CDATA[<p>查看redis（安装在linux服务器上）的版本</p>

<p>查看redis的版本有两种方式：</p>

<p>方式一</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>redis-server --version 
或 
redis-server -v 
</code></pre>
</div>

<p>得到的结果是：Redis server v=2.6.10 sha=00000000:0 malloc=jemalloc-3.2.0 bits=32</p>

<p>方式二</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>redis-cli --version 
或
redis-cli -v
</code></pre>
</div>

<p>得到的结果是：redis-cli 2.6.10</p>

<p>严格上说：通过　redis-cli 得到的结果应该是redis-cli 的版本，但是 redis-cli 和redis-server　一般都是从同一套源码编译出的。所以应该是一样的。</p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
