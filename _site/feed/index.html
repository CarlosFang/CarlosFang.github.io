<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2017-03-20T00:53:38+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>lua metatables 元表</title>
      <link href="http://localhost:4000/lua-metatables/"/>
      <pubDate>2017-03-16T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-metatables</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>Metatables 允许我们改变 table 的行为，例如，使用 Metatables 我们可以定义 Lua 如
何计算两个 table 的相加操作 a+b。</p>
</blockquote>

<p>这种方式很类似于C++中对运算符的重载。</p>

<p>Lua 中的每一个表都可以有它自己的 Metatable。一般情况下 Lua默认创建一个不带 metatable 的新表。</p>

<p>用getmetatable(table) 可以获取这个表的Metatable。</p>

<p>用setmetatable(table, metatable) 对一个表设置Metatable。</p>

<p>metatable 算术运算符域名 有__add(加)、__mul(乘)、__sub(减)、__div(除)、__unm(负)、__pow(幂)，我们也可以定义__concat 定义连接行为。</p>

<p>metatable 关系运算符 ：__eq（等于），__lt（小于） ，和__le（小于等于）。</p>

<p>Lua 选择 metamethod 的原则：如果第一个参数存在带有__add 域的 metatable，Lua
使用它作为 metamethod，和第二个参数无关；
否则第二个参数存在带有__add 域的 metatable， Lua 使用它作为 metamethod 否则报
错。</p>

<p>如果想保护你的集合使其使用者既看不到也不能修改 metatables。可以
对 metatable 设置了__metatable 的值， getmetatable 将返回这个域的值，而调用 setmetatable
将会出错：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">Set</span><span class="p">.</span><span class="n">mt</span><span class="p">.</span><span class="n">__metatable</span> <span class="o">=</span> <span class="s2">"not your business"</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="n">new</span><span class="p">{}</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">getmetatable</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c1">--&gt; not your business</span>
<span class="nb">setmetatable</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="p">{})</span>
<span class="n">stdin</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">change</span> <span class="n">protected</span> <span class="n">metatable</span>
</code></pre>
</div>

<p>table访问的元方法： 字段: __index __newindex</p>

<p>__index:  查询：访问表中不存的字段  rawget(t, i)</p>

<p>__newindex： 更新：向表中不存在索引赋值  rawswt(t, k, v)</p>

<p>有默认值的表:</p>

<p>在一个普通的表中任何域的默认值都是 nil。很容易通过 metatables 来改变默认值：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">setDefault</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span><span class="n">__index</span> <span class="o">=</span> <span class="k">function</span> <span class="p">()</span> <span class="k">return</span> <span class="n">d</span> <span class="k">end</span><span class="p">}</span>
	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">tab</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">20</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tab</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tab</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="c1">--&gt; 10 nil</span>

<span class="n">setDefault</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tab</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tab</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="c1">--&gt; 10 0</span>
</code></pre>
</div>

<p>监控表:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="c1">-- create private index</span>
<span class="kd">local</span> <span class="n">index</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1">-- create metatable</span>
<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__index</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">"*access to element "</span> <span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="c1">-- access the original table</span>
	<span class="k">end</span>

	<span class="n">__newindex</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">"*update of element "</span> <span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">..</span> <span class="s2">" to "</span><span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
		<span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="c1">-- update original table</span>
	<span class="k">end</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">track</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>

	<span class="kd">local</span> <span class="n">proxy</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">proxy</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">proxy</span>
<span class="k">end</span>
</code></pre>
</div>

<p>只读表:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="k">function</span> <span class="nf">readOnly</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">proxy</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">-- create metatable</span>
	<span class="n">__index</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span>
	<span class="n">__newindex</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="nb">error</span><span class="p">(</span><span class="s2">"attempt to update a read-only table"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">end</span>
	<span class="p">}</span>
	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">proxy</span>
<span class="k">end</span>

<span class="n">days</span> <span class="o">=</span> <span class="n">readOnly</span><span class="p">{</span><span class="s2">"Sunday"</span><span class="p">,</span> <span class="s2">"Monday"</span><span class="p">,</span> <span class="s2">"Tuesday"</span><span class="p">,</span> <span class="s2">"Wednesday"</span><span class="p">,</span>
<span class="s2">"Thursday"</span><span class="p">,</span> <span class="s2">"Friday"</span><span class="p">,</span> <span class="s2">"Saturday"</span><span class="p">}</span>


<span class="nb">print</span><span class="p">(</span><span class="n">days</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">--&gt; Sunday</span>
<span class="n">days</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Noday"</span>
<span class="c1">-- stdin:1: attempt to update a read-only table</span>

</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 协程</title>
      <link href="http://localhost:4000/lua-coroutine/"/>
      <pubDate>2017-03-16T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-coroutine</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>协同程序（coroutine）与多线程情况下的线程比较类似：有自己的堆栈，自己的局
部变量，有自己的指令指针，但是和其他协同程序共享全局变量等很多信息。线程和协
同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线
程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这
个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
</blockquote>

<p>宏观上可能看成是比线程更小的执行单位。但本质上，它是线程管理下的单位。这就是上面所说的在任一指定时刻只有一个协同程序在运行。是一种多任务方式。</p>

<h3 id="协同的基础">协同的基础</h3>

<p>lua 提供对应一些协程的函数。如 create() status() resume() 等等。</p>

<p>创建一个协程create()</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"hello world!"</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">co</span><span class="p">)</span> 
</code></pre>
</div>

<p>查看状态，可用status</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span><span class="p">(</span><span class="nb">coroutine.status</span><span class="p">(</span><span class="n">co</span><span class="p">))</span> <span class="c1">--&gt; suspended</span>
</code></pre>
</div>

<p>协同有三个状态：挂起态、运行态、停止态。</p>

<p>让一个协程从挂起状变为运行态</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">)</span>
</code></pre>
</div>

<p>让一个协程挂起，可用yield()</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span> <span class="k">do</span>
	<span class="nb">print</span><span class="p">(</span><span class="s2">"co"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="nb">coroutine.yield</span><span class="p">()</span>
	<span class="k">end</span>
<span class="k">end</span><span class="p">)</span>
</code></pre>
</div>
<p>在程序使用resume后，协程被激活。</p>

<p>看 resume-yield 可以相互交换数据。</p>

<p>1 非对称的情况：</p>

<p>resume 把参数传入协程里。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"co"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
<span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">--&gt; co 1 2 3</span>
</code></pre>
</div>

<p>2 对称的情况：</p>

<p>yield 会把值返还给resume。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">--&gt; true 30 10</span>
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 异常与错误</title>
      <link href="http://localhost:4000/lua-error/"/>
      <pubDate>2017-03-16T01:31:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-error</guid>
      <content:encoded><![CDATA[<h3 id="assert">assert</h3>

<p>Lua 提供了专门的内置函数 assert 来完成错误的检测的功能。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span> <span class="s2">"enter a number:"</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">assert</span><span class="p">(</span><span class="nb">io.read</span><span class="p">(</span><span class="s2">"*number"</span><span class="p">),</span> <span class="s2">"invalid input"</span><span class="p">)</span>
</code></pre>
</div>

<p>assert 首先检查第一个参数是否返回错误，如果不返回错误 assert 简单的返回，否则assert 以第二个参数抛出错误信息。第二个参数是可选的。</p>

<p>当函数遇到异常有两个基本的动作：返回错误代码或者抛出错误。这两种方式选择
哪一种没有固定的规则，但有一般的原则：容易避免的异常应该抛出错误否则返回错误
代码。</p>

<h3 id="异常和错误处理">异常和错误处理</h3>

<p>在 Lua 中需要处理错误，需要使用 pcall 函数封装你的代码。
用法如下：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="nb">pcall</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="k">then</span>
	<span class="c1">-- no errors while running `foo'</span>
<span class="o">...</span>
<span class="k">else</span>
<span class="c1">-- `foo' raised an error: take appropriate actions</span>
<span class="o">...</span>
<span class="k">end</span>

</code></pre>
</div>
<p>foo 为检测的函数。</p>

<p>用做匿名函数则是：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="k">if</span> <span class="nb">pcall</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="o">...</span> <span class="k">end</span><span class="p">)</span> <span class="k">then</span> <span class="o">...</span>
<span class="k">else</span> <span class="o">...</span>

</code></pre>
</div>
<p>pcall 在保护模式下调用他的第一个参数并运行，因此可以捕获所有的异常和错误。
如果没有异常和错误，pcall 返回 true 和调用返回的任何值；否则返回 nil 加错误信息。</p>

<h4 id="错误信息和回跟踪tracebacks">错误信息和回跟踪（Tracebacks）</h4>

<p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展看（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。</p>

<p>debug库提供了两个通用的错误处理函数:</p>
<ul>
  <li>debug.debug：提供一个Lua提示符，让用户来价差错误的原因</li>
  <li>debug.traceback：根据调用桟来构建一个扩展的错误消息。</li>
</ul>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">xpcall</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="nb">error</span><span class="p">(</span><span class="s1">'error..'</span><span class="p">)</span> <span class="k">end</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="nb">print</span><span class="p">(</span><span class="nb">debug.traceback</span><span class="p">())</span> <span class="k">end</span><span class="p">,</span> <span class="mi">33</span><span class="p">)</span>
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>lua 函数</title>
      <link href="http://localhost:4000/lua-function/"/>
      <pubDate>2017-03-15T19:16:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-function</guid>
      <content:encoded><![CDATA[<p>lua的函数有必要记录可能也就是 可变参数, 后面的命名参数和多个返回值和python基本一样。</p>

<h3 id="可变参数">可变参数</h3>

<p>Lua 函数可以接受可变数目的参数，和 C 语言类似在函数参数列表中使用三点（…）
表示函数有可变的参数。Lua 将函数的参数放在一个叫 arg 的表中，除了参数以外，arg
表中还有一个域 n 表示参数的个数。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">g</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="k">end</span>

<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">nil</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span>
<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span>
<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">;</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">}</span>

</code></pre>
</div>
<p>Lua 的函数还一些特性和C不一样的是：它和其他值（数值、字符串）一样，函数可以被存放在变
量中，也可以存放在表中，可以作为函数的参数，还可以作为函数的返回值。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span> <span class="o">=</span> <span class="nb">math.sin</span> <span class="c1">-- `print' now refers to the sine function</span>
<span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">(</span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">--&gt; 0.841470</span>
</code></pre>
</div>

<p>如函数被嵌套的函数里，它可以访问他外部函数中的变量。这一特性强大编程能力。</p>

<p>另一个特征是：匿名函数。</p>

<p>用表达式创建函数：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">foo</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="k">end</span>
</code></pre>
</div>

<h3 id="闭包">闭包</h3>

<p>当一个函数内部嵌套另一个函数定义时，内部的函数体可以访问外部的函数的局部变量，这种特征我们称作词法定界。虽然这看起来很清楚，事实并非如此，词法定界加上第一类函数在编程语言里是一个功能强大的概念，很少语言提供这种支持。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">newCounter</span><span class="p">()</span>
	<span class="kd">local</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">return</span> <span class="k">function</span><span class="p">()</span> <span class="c1">-- anonymous function</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">i</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">newCounter</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 2</span>

</code></pre>
</div>
<p>i不是全局变量也不是局部变量，我们称作外部的局部变量（external local variable）或者 upvalue。</p>

<p>匿名函数使用 upvalue i 保存他的计数，当我们调用匿名函数的时候 i 已经超出了作用范围，因为创建 i 的函数 newCounter 已经返回了。然而 Lua 用闭包的思想正确处理了这种情况。简单的说闭包是一个函数加上它可以正确访问的 upvalues。如果我们再次调
用 newCounter，将创建一个新的局部变量 i，因此我们得到了一个作用在新的变量 i 上的
新闭包。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">c2</span> <span class="o">=</span> <span class="n">newCounter</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c2</span><span class="p">())</span> <span class="c1">--&gt; 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c2</span><span class="p">())</span> <span class="c1">--&gt; 2</span>

</code></pre>
</div>
<p>技术上来讲，闭包指值而不是指函数，函数仅仅是闭包的一个原型声明；尽管如此，
在不会导致混淆的情况下我们继续使用术语函数代指闭包。</p>

<p>闭包在上下文环境中提供很有用的功能，如高级函数（sort）的参数；作为函数嵌套的函数（newCounter）。这一机制使得我们可以在 Lua 的函数世界里组合出奇幻的编程技术。闭包也可用在回调函数中。</p>

<h3 id="全局函数和局部函数">全局函数和局部函数</h3>

<p>局部函数就是在函数前加一个 local。</p>

<p>局部函数的两种方式：</p>

<ol>
  <li>方式一</li>
</ol>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="n">f</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">end</span>
<span class="kd">local</span> <span class="n">g</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">f</span><span class="p">()</span> <span class="c1">-- external local `f' is visible here</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre>
</div>

<ol>
  <li>方式二</li>
</ol>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="k">function</span> <span class="nf">f</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>有一点需要注意的是在声明递归局部函数的方式。
要提前定义local。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="kd">local</span> <span class="n">fact</span>
<span class="n">fact</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<h3 id="尾调用proper-tail-calls">尾调用（Proper Tail Calls）</h3>

<p>尾调用是一种类似在函数结尾的 goto 调用，当函数最后一个动作是调用另外一个函
数时，我们称这种调用尾调用。例如：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>g 的调用是尾调用。</p>

<p>例子中 f 调用 g 后不会再做任何事情，这种情况下当被调用函数 g 结束时程序不需
要返回到调用者 f；所以尾调用之后程序不需要在栈中保留关于调用者的任何信息。</p>

<p>如下三种不是尾调函数.</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="n">r</span> <span class="n">eturn</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">-- must do the addition</span>
<span class="k">return</span> <span class="n">x</span> <span class="ow">or</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1">-- must adjust to 1 result</span>
<span class="k">return</span> <span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">-- must adjust to 1 result</span>
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 学习初步记录</title>
      <link href="http://localhost:4000/lua-first-learn/"/>
      <pubDate>2017-03-15T04:27:03+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-first-learn</guid>
      <content:encoded><![CDATA[<p>1 Lua 是动态类型语言，变量不要类型定义。 Lua 中有 8 个基本类型分别为： nil、 boolean、number、string、userdata、function、thread 和 table。函数 type 可以测试给定变量或者值
的类型。</p>

<p>2 Lua 中特殊的类型，他只有一个值：nil；一个全局变量没有被赋值以前默认值为 nil；
给全局变量负 nil 可以删除该变量。</p>

<p>3 Booleans 两个取值 false 和 true。但要注意 Lua 中所有的值都可以作为条件。在控制结构的条
件中除了 false 和 nil 为假，其他值都为真。所以 Lua 认为 0 和空串都是真。</p>

<p>4 Lua 中字符串是不可以修改的， 你可以创建一个新的变量存放你要的字符串。 还可以使用[[…]]表示字符串。</p>

<p>5 Lua 会自动在 string 和 numbers 之间自动进行类型转换，当一个字符串使用算术操作符时，string 就会被转成数字。
尽管字符串和数字可以自动转换，但两者是不同的，像 10 == “10”这样的比较永远
都是错的。</p>

<p>6 <code class="highlighter-rouge">..</code>在 Lua 中是字符串连接符，当在一个数字后面写..时，必须加上空格以防止被解释错。</p>

<p>7 函数是第一类值（和其他变量相同），意味着函数可以存储在变量中，可以作为函数的参数，也可以作为函数的返回值。</p>

<p>8 Lua 比较数字按传统的数字大小进行，比较字符串按字母的顺序进行，但是字母顺序依赖于本地环境。</p>

<p>9 Lua list的下标是从1开始的。</p>

<p>10 使用 local 创建一个局部变量，与全局变量不同，局部变量只在被声明的那个代码块内有效。代码块：指一个控制结构内，一个函数体，或者一个 chunk（变量被声明的那个文件或者文本串）</p>

<p>11 当函数只有一个参数并且这个参数是字符串或者表构造的时候，()是可选的。</p>

<p>12 Lua有闭包的用法。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>防盗链技术</title>
      <link href="http://localhost:4000/web-referers/"/>
      <pubDate>2017-03-10T05:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/web-referers</guid>
      <content:encoded><![CDATA[<p>在《增长黑客》这个本书上，看到一个例子。作者用curl 在网上抓取了一个网站上用户的头像。这个网站对于图片的静态链接没有做防盗链。
以前有过这种开发。也疑惑过这种问题。
今天就了解一下什么是防盗链吧。</p>

<p>防盗链的定义：
此内容不在自己服务器上，而通过技术手段，绕过别人放广告有利益的最终页，直接在自己的有广告有利益的页面上向最终用户提供此内容。 常常是一些名不见经传的 小网站来盗取一些有实力的大网站的地址（比如一些音乐、图片、软件的下载地址）然后放置在自己的网站中，通过这种方法盗取大网站的空间和流量。</p>

<p>通俗的讲：就是你提供给自己的网站的静态链接。别人一样可能无条件用。图片，音频，文件，别人可以下载得到。</p>

<p>这个技术的本质就在于http上。表头字体有一个叫referer的。这个字段的作用是：当浏览器访问web服务器时，一般会带上referer，告诉服务器我是从哪个页面链接过来的。所以，我们可用检测这个链接是不是我们自己的服务器上的，如果不是，那可能就是别人来盗链接的了，就应该阻止掉。</p>

<h4 id="nginx防盗链的配置">nginx防盗链的配置</h4>
<p>1、nginx针对文件类型的防盗链配置方法：</p>
<div class="language-sh highlighter-rouge"><pre class="highlight"><code>　　location ~<span class="k">*</span> <span class="se">\.</span><span class="o">(</span>gif|jpg|png|swf|flv|bmp<span class="o">)</span><span class="nv">$ </span><span class="o">{</span>
　　valid_referers none blocked <span class="k">*</span>.php100.com php100.com;
　　if <span class="o">(</span><span class="nv">$invalid_referer</span><span class="o">)</span> <span class="o">{</span>
　　     <span class="c">#rewrite ^/ http://www.php100.com/403.html;</span>
　　     <span class="k">return </span>403;
　　     <span class="o">}</span>     
　　<span class="o">}</span>
</code></pre>
</div>

<p>这种方法是在server或者location段中加入：valid_referers none blocked，其中none表示空的来路，也就是直接访问，比如直接在浏览器打开一个文件，blocked表示被防火墙标记过的来路，*.php100.com表示所有子域名。</p>

<p>2、nginx针对文件目录的防盗链配置方法：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>　　location /img/ <span class="o">{</span>
　　     root /data/img/;
　　     valid_referers none blocked <span class="k">*</span>.php100.com php100.com;

　　     <span class="k">if</span> <span class="o">(</span><span class="nv">$invalid_referer</span><span class="o">)</span> <span class="o">{</span>
　　          rewrite ^/ http://www.php100.com/error.gif;
　　          <span class="c">#return 403;</span>
　　     <span class="o">}</span>     
　　<span class="o">}</span>
</code></pre>
</div>

<p>如果不是用nginx，就要自己去解析表头然后做出判断。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>用valgrind做一次性能分析</title>
      <link href="http://localhost:4000/valgrind-code-analysis/"/>
      <pubDate>2017-02-09T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/valgrind-code-analysis</guid>
      <content:encoded><![CDATA[<p>有一次用valgrind对代码的热点进行分析。发现有一个函数的被调用百分比比较高。</p>

<p>关键的函数是CGameBuffMgr::process()</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">CGameBuffMgr</span><span class="o">::</span><span class="n">process</span> <span class="p">(</span><span class="n">uint64</span> <span class="n">uTick</span><span class="p">,</span><span class="n">uint64</span> <span class="n">uTime</span><span class="p">,</span><span class="n">uint32</span> <span class="n">uSecond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">m_uProcessTick</span> <span class="o">&gt;</span> <span class="n">uTick</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">m_uProcessTick</span><span class="p">)</span>
		<span class="n">m_uProcessTick</span> <span class="o">=</span> <span class="n">uTick</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">POOL_BUFF</span><span class="o">::</span><span class="n">iterator</span> <span class="n">_pos</span><span class="p">;</span>
	<span class="n">m_poolBuff</span><span class="p">.</span><span class="n">getHead</span><span class="p">(</span><span class="n">_pos</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m_poolBuff</span><span class="p">.</span><span class="n">isTail</span><span class="p">(</span><span class="n">_pos</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">CGameBuff</span><span class="o">*</span>	<span class="n">pBuff</span> <span class="o">=</span> <span class="n">m_poolBuff</span><span class="p">.</span><span class="n">getNext</span><span class="p">(</span><span class="n">_pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pBuff</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">pBuff</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">(</span><span class="n">uTick</span><span class="p">,</span><span class="n">uTime</span><span class="p">,</span><span class="n">uSecond</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pBuff</span><span class="o">-&gt;</span><span class="n">isDelete</span><span class="p">())</span>
			<span class="n">delBuff</span><span class="p">(</span><span class="n">pBuff</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>process是由定时器调起，所以比较多是正常的。</p>

<p>用 valgrind 做代码性能分析。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>/usr/bin/valgrind --tool<span class="o">=</span>callgrind  --trace-children<span class="o">=</span>yes  /data/game_server/game_server
</code></pre>
</div>

<p>得到：callgrind.out.6578 文件。再用 kcachegrind进行分析。如下：</p>

<p><img src="/assets/code-analysis/valgrind-stl-1.png" alt="" /></p>

<p>CGameBuffMgr::process中的 getHead消耗比较大。感觉可能有问题。</p>

<p>而getHead是这样的：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_ValType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">COUNT</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span>	<span class="n">CMemoryPool</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">_ValType</span><span class="p">,</span><span class="n">COUNT</span><span class="o">&gt;::</span><span class="n">getHead</span><span class="p">(</span><span class="n">iterator</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">try</span>
	<span class="p">{</span>
		<span class="c1">//CCritLocker lock(m_csLock);
</span>		<span class="n">pos</span> <span class="o">=</span> <span class="n">m_UseList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(...)</span>
	<span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>
<p>getHead中只是对 hash_map进行begin操作。
从图上看hash_map的begin消耗也很大。问题可能出在这个地方。</p>

<p><img src="/assets/code-analysis/valgrind-stl-12.png" alt="" /></p>

<p>在 <a href="http://blog.csdn.net/tototony/article/details/5689882">http://blog.csdn.net/tototony/article/details/5689882</a>这篇文章中，可以了解一些hash_map的原理。
begin() 为了获得第一个元素，就在hashtable表中遍历，hashtale就是一个vector。
所以说 一调用begin(), 说是遍历hashtable</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">iterator</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">begin</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">_M_buckets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">__n</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="n">_M_buckets</span><span class="p">[</span><span class="n">__n</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">_M_buckets</span><span class="p">[</span><span class="n">__n</span><span class="p">],</span> <span class="k">this</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">end</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>找到了就返回，找到就会遍历完整个hashtable表，再返回end()。
我想这就是为什么hash_map中的 begin() 效率不行的原因吧。</p>

<p>最后，就动手把hash_map改成了map　stl中的map其实就是红黑树。
改动后 重新跑一下valgrind。 得到如下图。已经没有getHead了。</p>

<p><img src="/assets/code-analysis/valgrind-stl-2.png" alt="" /></p>

<p>所以，如果要用到遍历的应尽量避免用hash_map。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>日志模块</title>
      <link href="http://localhost:4000/model-log/"/>
      <pubDate>2016-12-15T17:23:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/model-log</guid>
      <content:encoded><![CDATA[<p>系统的开发，日志模块的是必不可少的。特别对于业务逻辑层的来说，有日志输出，很方便跟踪逻辑大概情况。但是对于底层的核心模块来说，日志输出反而成了累赘。日志的输出同样占有I/O。再者，对于底层的逻辑，一般都是比较复杂，核心。暴露出来也没必要。业务逻辑层同样没有必要去了解它。所以，一般的做法是：底层出错，返回错误编码。由上一层记录就OK了。</p>

<p>日志模块一般可以分为 print/note、 debug、 warn、error。人个觉得这四个层次就够了。当然，也可多增加几个，例如，trac。我曾经用于特别的调试，只是一些非必现的问题调试，把日志输出到这层，方便查找。</p>

<p>对于这四层，是分开几个文件，还是在同一个文件中？ 其实这两种方式我都用过。这些年的经验，感觉写到同一个文件中，比较分四个文件要好。理由是很清楚的知道日志输出的前后时间顺序。当然分开成几个日志文件输出，也是有办法按时间查看的，只要用linux的一些工具手段而已。分开成几个文件的好处，就是一看就知道是否有错误输出了。同一个文件，只能在文件中查到才知道。</p>

<p>无论是 apache,还是nignx，日志的输出都是分层，配置不同层次的，只有高于或等于它的才能被输出。当然，我们设计时也可以直接指定层次print、warn、error。</p>

<p>有日志输出，就意味着有日志文件的管理。如文件大小、文件命名、所在目录、如何清理。
一般，我的做法是日志文件的大小设计成可配置。在相关的配置文件中指定。
二，日志文件的命名，我是按模块名来命名（即进程名）。或加上日期或日期在体现在目录上。
三，所在目录，我选择是把所有的日志放到同一个Log目录下，千万别把分别放到不同模块的目录里面。这样做的好处是：我们可以系统中划出一个分区来，专门存放日志，和服务的进程分离开。这样做的理由是：如果日志输出过来，把硬盘空间爆了，不会影响到服务的运行。
四，对清理， 我没有体现在于日志模块里，而是用计划任务做定时清理。</p>

<p>日志模块应该有可配置性。 一般有：
路径、文件大小、模块名、输出层次、</p>

<p>日志的输出涉及到I/O。所以对效率是有一定的影响的。 必竞这是定文件的。有一个很不错的设计：就是日志写到队列（用共享内存实现 的）然后由专门的日志进程（logsvr）输出到文件中。这样日志输出就不会有I/O阻塞了，提高一些效率。</p>

<p>下一回，把日志的模块整理好，分析一下。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>余华-活着</title>
      <link href="http://localhost:4000/alive/"/>
      <pubDate>2016-10-15T17:23:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/alive</guid>
      <content:encoded><![CDATA[<p>这本书是从微博上看网友介绍的，还是朋友介绍的，我也不记得了。在kindle上看有已经购买。应该是一次买了后，忘记了看了。这两天上下班在地铁上，就把它给看了。</p>

<p>书里的主人公叫福贵。一个旧社会里的有钱人的少爷。年少时就一个败家子。按他妈的说法是上梁不正下梁歪。因为他老子年轻也也是败家子，败了家里的一百多亩田地。后来开窍了，好好的在经营自己的田地。他就边上厕所也会跑到自家的田地，可是就是肥水不流外人田的吧。老子还是蛮希望福贵能光大门楣的。结果还是一败家子。把他没败完的另一百多亩也败完了。</p>

<p>最后他爸把所有的田契和房契都让人换成了铜钱，整整三大担。让福贵自己挑去还赌债。福贵把肩膀都磨破了。才知道祖辈挣下这些钱不知要累死多少人。他自己挑都快累死了。这时才知道他老子为什么不要银元要铜钱。
破产后，他们只能去住茅草屋。没多久福贵的老子在拉屎的时候死了。家里能卖的东西也都卖光了。福贵只能去租田来种，可他是个就个少爷。可怜了他的老妈和老婆。
话说他老婆也是个好女人。一个城里米行的小姐，也读过书。嫁给一个败家子。最后再怎么受苦也跟定他了。 在福贵去城里为他妈找大夫时，他被国民党抓了壮丁。一去就是五年，幸好没有死，被共产党俘虏后放了。到家时，他妈死了，大女儿在生病时聋哑啊。小儿子也不认识他了。</p>

<p>然后，解放了，新中国成立了， 三反三反，大跃进，砸锅炼钢，文化大革命。开始了生产大队的大食堂的生活，最后没粮食了，食堂解散了，大伙都没有吃的。只能挖树根，然后说着要相信政府，相信党。可队长每一次都是空手而回的。大伙开始去乞讨，福贵的老婆说要去城里看望老父，其实就是去乞讨。却真的在街上碰到了父亲。（真想知道他们当时的场景）老父给她从自己的牙缝里省下的来小米。她高兴的回到家，福贵去不敢开社，因为知道一开灶全村都知道了。福贵要确认村里没有人才敢开灶。这让我想我爸说过一件。有一次，我开玩笑的对他说，如果中国经济真的不行了。我们是不是家里存点什么东西啊。他说：没什么用， 全村都没有，就我们家有，也是存不了的。想到爸之前的意思，他是不是以前就经历过这样的事。</p>

<p>儿子在医院给他输血时，被抽空死了。聋哑女儿好不容易嫁了个好人歪头。却在难产也死了。老婆却一直在生病，在女儿死后三个月也死了。儿子女子都死了，她没什么好操心的了。她死后也有福贵料理后事。而福贵的后事也有他的外孙。所以她死得安心。接下来的，是他的女婿歪头也在工地出意外死了，留下了外孙和他相依为命。可最后，边他的外孙也在吃豆撑死了。在福贵年迈时，他所有的亲人都死了。</p>

<p>他在床边放十块钱，全村的人都知道，那是给替他收尸的人的。他存了几年的钱，想为他外孙买头牛。却在看到别人宰杀一头老牛时，心生怜悯。买了一头老牛。村里人都是这牛活不过四五年，可他却不在意，他觉得自己的自己应该活不了那么久。</p>

<p>写得比较朴素简单，文字很简单。但福贵的命却是很悲剧的。不过，过他福贵自己讲出来的人生却没有悲剧的感觉。可能这就是《活着》想表达的东西吧。</p>

<p>最后想说的，那真个操蛋的年代 。</p>

<p>– 深圳 北站</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>libevent 初步分析</title>
      <link href="http://localhost:4000/libevent-base/"/>
      <pubDate>2016-07-16T01:32:03+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/libevent-base</guid>
      <content:encoded><![CDATA[<h3 id="一-reactor模式">一 reactor模式</h3>

<p>整个libevent本身就是一个reactor。reactor翻译成反应堆，是一种事件驱动机制。libevent，底层所运用的就是例epoll这样的一些模型。</p>

<p>应用程序一般都要在reactor注册回调函数。当事件被触发时，回调函数会被调用。这些事件可能是I/O读写， 定时器和信号。</p>

<p>reactor模型：必备的几个组件：事件源、reactor框架、多路利用机制和事件处理函数。</p>

<p><strong>事件源：</strong></p>

<p>Linux上是文件描述符， win下的socket 或 handle.</p>

<p><strong>event demultipexer (事件多路分发机制)：</strong></p>

<p>linux下如：epoll、 select、kqueue、devpoll</p>

<p>当有事件到达时， event demultiplexer会发出通知。这时相关的事件就成了就绪状态。libevent会在非阻塞的情况下进行处理。</p>

<p>libevent用 eventtop对 select epoll poll 等进行了封闭，形成统一的接口。</p>

<p><strong>reactor 反应器：</strong></p>

<p>reactor是事件管理接口。内部使用 event demultiplexer 注册、注销事件；并运行事件循环，
当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。对应到 libevent 中，就是 event_base 结构体。</p>

<p><strong>事件处理流程图：</strong></p>

<p>1）首先应用程序准备并初始化 event，设置好事件类型和回调函数；</p>

<p>2）向 libevent 添加该事件 event。对于定时事件， libevent 使用一个小根堆管理， key 为超
时时间；对于 Signal 和 I/O 事件， libevent 将其放入到等待链表（ wait list）中，这是一
个双向链表结构；</p>

<p>3） 程序调用 event_base_dispatch()系列函数进入无限循环，等待事件，以 select()函数为例；
每次循环前 libevent 会检查定时事件的最小超时时间 tv，根据 tv 设置 select()的最大等
待时间，以便于后面及时处理超时事件；当 select()返回后，首先检查超时事件，然后检查 I/O 事件；</p>

<p><img src="/assets/network/libevent_event_next.png" alt="" /></p>

<h3 id="二--源码文件组织结构">二  源码文件组织结构</h3>

<p>头文件、内部使用的头文件、辅助功能函数、日志、libevent框架、对系统I/O多路复用机制的封装
信号管理、定时事件管理、缓冲区管理、基本数据和基于libevent的两个实用库的向个部分。</p>

<p><strong>头文件</strong></p>

<p>event.h：事件宏定义、接口函数声明，主要结构体event的声明；</p>

<p>xxx-internal.h：内部数据结构和函数，对外不可见，以达到信息隐藏的目的；</p>

<p><strong>libevent框架</strong></p>

<p>event.c：event整体框架的代码实现；</p>

<p>对系统I/O多路复用机制的封装</p>

<ul>
  <li>epoll.c：对epoll的封装；</li>
  <li>select.c：对select的封装；</li>
  <li>devpoll.c：对dev/poll的封装;</li>
  <li>kqueue.c：对kqueue的封装；</li>
</ul>

<p><strong>定时事件管理</strong></p>

<p>min-heap.h：其实就是一个以时间作为key的小根堆结构；</p>

<p><strong>信号管理</strong></p>

<p>signal.c：对信号事件的处理；</p>

<p><strong>辅助功能函数</strong></p>

<p>evutil.h 和evutil.c：一些辅助功能函数，包括创建socket pair和一些时间操作函数：加、减和比较等。</p>

<p><strong>日志</strong></p>

<p>log.h和log.c：log日志函数</p>

<p><strong>缓冲区管理</strong></p>

<p>evbuffer.c和buffer.c：libevent对缓冲区的封装；</p>

<p><strong>基本数据结构</strong></p>

<p>compat\sys下的两个源文件：queue.h是libevent基本数据结构的实现，包括链表，双向链表，队列等；
_libevent_time.h：一些用于时间操作的结构体定义、函数和宏定义；</p>

<p><strong>实用网络库</strong></p>

<p>http和evdns：是基于libevent实现的http服务器和异步dns查询库</p>

<h3 id="三-事件event">三 事件event</h3>

<p>主要的结构体：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event_base</span> <span class="c1">// event最主要的结构，
</span><span class="k">struct</span> <span class="n">eventop</span>    <span class="c1">// 定义backend结构， 通过它定义各个模型，
</span></code></pre>
</div>

<ul>
  <li>ev_events： event关注的事件类型，它可以是以下3种类型：</li>
  <li>I/O事件：  EV_WRITE和EV_READ</li>
  <li>定时事件： EV_TIMEOUT</li>
  <li>信号：     EV_SIGNAL</li>
  <li>辅助选项： EV_PERSIST，表明是一个永久事件</li>
</ul>

<p>ev_next， ev_active_next 和 ev_signal_next 都是双向链表节点指针。</p>

<p>I/O和Signal事件使用了双向链表。</p>

<p>定时事件 使用了小根堆 min_heap_idx.</p>

<p>ev_next 是该I/O事件在链表中的位置，表示是“已注册事件链表”。
ev_signal_next signal事件在signal事件链表中的位置。
ev_active_next libevent将所有的激活事件放入到链表active list中，然后遍历 active list执行调度，ev_active_next就指明了event在active list中的位置。</p>

<p><strong><em>libevent 对 event 的管理</em></strong></p>

<p><img src="/assets/network/libevent_event_managemant.png" alt="" /></p>

<p>事件设置的接口函数</p>

<p>libevent 提供了函数：event_set(), event_base_set(), event_priority_set()。</p>

<p>设置事件 如：I/O事件、 时间事件、信号事件:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">event_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</code></pre>
</div>

<p>设置 event ev 将要注册到的 event_base；</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_base_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">)</span>
</code></pre>
</div>

<p>设置event ev的优先级:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_priority_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pri</span><span class="p">)</span>
</code></pre>
</div>

<h3 id="四-事件处理框架">四 事件处理框架</h3>

<p>事件处理都是围绕着 event_base。</p>

<p>初始化一个 event_base。 本质上是调用了 event_base_new_with_config。</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span> <span class="n">event_init</span><span class="p">()</span>
</code></pre>
</div>

<p>也是 初始化一个 event_base。不同的是 先创建了一个struct event_config。 这个东西是干什么用的还清楚。</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span> <span class="n">event_base_new</span><span class="p">()</span>
</code></pre>
</div>

<p>内部主要调用了 event_add_internal()</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</code></pre>
</div>

<p>内部主要调用了 event_del_internal()</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_base_loop</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loops</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">event_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">);</span>
	
<span class="kt">void</span> <span class="n">event_process_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="五--事件主循环">五  事件主循环</h3>

<p>struct evsig_info // 这个又是干吗的？</p>

<p><strong>I/O和Timer事件的统一</strong></p>

<p>libevent将Timer和Signal事件都统一到了系统的I/O 的demultiplex机制中了，</p>

<p>堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)。而获取最小key值（小根堆）的复杂度为O(1)。</p>

<p><strong>I/O和Signal事件的统一</strong></p>

<p>如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I/O机制，让其返回，然后再统一和I/O事件以及Timer一起处理。</p>

<h3 id="六-集成信号处理">六 集成信号处理</h3>

<p>singal和I/O的事件统一是通过 socket pair的方式实现。（这个方式有点像是管道）</p>

<h3 id="七-io多路复用技术">七 I/O多路复用技术</h3>

<p>libevent根据系统配置和编译选项决定使用哪一种I/O demultiplex机制，而不支持在运行阶段根据配置再次选择。</p>

<h3 id="十一-时间管理">十一 时间管理</h3>

<p>Libevent 本身不是多线程安全的
libevent 库的其他组件提供其他功能，包括缓冲的事件系统（用于缓冲发送到客户端/从客户端接收的数据）以及 HTTP、DNS 和 RPC 系统的核心实现。</p>

<p>可以对比一下 libev</p>

<hr />

<p>参考：<a href="http://pan.baidu.com/s/1hssU5KC"><strong>libevent源码深度剖析.pdf</strong></a></p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
