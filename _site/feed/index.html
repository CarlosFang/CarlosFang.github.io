<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2017-03-15T22:36:15+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>lua metatables 元表</title>
      <link href="http://localhost:4000/lua-metatables/"/>
      <pubDate>2017-03-16T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-metatables</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>Metatables 允许我们改变 table 的行为，例如，使用 Metatables 我们可以定义 Lua 如
何计算两个 table 的相加操作 a+b。</p>
</blockquote>

<p>这种方式很类似于C++中对运算符的重载。</p>

<p>Lua 中的每一个表都可以有它自己的 Metatable。一般情况下 Lua默认创建一个不带 metatable 的新表。</p>

<p>用getmetatable(table) 可以获取这个表的Metatable。</p>

<p>用setmetatable(table, metatable) 对一个表设置Metatable。</p>

<p>metatable 算术运算符域名 有__add(加)、__mul(乘)、__sub(减)、__div(除)、__unm(负)、__pow(幂)，我们也可以定义__concat 定义连接行为。</p>

<p>metatable 关系运算符 ：__eq（等于），__lt（小于） ，和__le（小于等于）。</p>

<p>Lua 选择 metamethod 的原则：如果第一个参数存在带有__add 域的 metatable，Lua
使用它作为 metamethod，和第二个参数无关；
否则第二个参数存在带有__add 域的 metatable， Lua 使用它作为 metamethod 否则报
错。</p>

<p>如果想保护你的集合使其使用者既看不到也不能修改 metatables。可以
对 metatable 设置了__metatable 的值， getmetatable 将返回这个域的值，而调用 setmetatable
将会出错：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">Set</span><span class="p">.</span><span class="n">mt</span><span class="p">.</span><span class="n">__metatable</span> <span class="o">=</span> <span class="s2">"not your business"</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="n">new</span><span class="p">{}</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">getmetatable</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span> <span class="c1">--&gt; not your business</span>
<span class="nb">setmetatable</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="p">{})</span>
<span class="n">stdin</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">change</span> <span class="n">protected</span> <span class="n">metatable</span>
</code></pre>
</div>

<p>table访问的元方法： 字段: __index __newindex</p>

<p>__index:  查询：访问表中不存的字段  rawget(t, i)</p>

<p>__newindex： 更新：向表中不存在索引赋值  rawswt(t, k, v)</p>

<p>有默认值的表:</p>

<p>在一个普通的表中任何域的默认值都是 nil。很容易通过 metatables 来改变默认值：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">setDefault</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span><span class="n">__index</span> <span class="o">=</span> <span class="k">function</span> <span class="p">()</span> <span class="k">return</span> <span class="n">d</span> <span class="k">end</span><span class="p">}</span>
	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">tab</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">20</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tab</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tab</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="c1">--&gt; 10 nil</span>

<span class="n">setDefault</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tab</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tab</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="c1">--&gt; 10 0</span>
</code></pre>
</div>

<p>监控表:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="c1">-- create private index</span>
<span class="kd">local</span> <span class="n">index</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1">-- create metatable</span>
<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__index</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">"*access to element "</span> <span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="c1">-- access the original table</span>
	<span class="k">end</span>

	<span class="n">__newindex</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">"*update of element "</span> <span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">..</span> <span class="s2">" to "</span><span class="o">..</span> <span class="nb">tostring</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
		<span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="c1">-- update original table</span>
	<span class="k">end</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">track</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>

	<span class="kd">local</span> <span class="n">proxy</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">proxy</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">proxy</span>
<span class="k">end</span>
</code></pre>
</div>

<p>只读表:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="k">function</span> <span class="nf">readOnly</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">proxy</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="kd">local</span> <span class="n">mt</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">-- create metatable</span>
	<span class="n">__index</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span>
	<span class="n">__newindex</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="nb">error</span><span class="p">(</span><span class="s2">"attempt to update a read-only table"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">end</span>
	<span class="p">}</span>
	<span class="nb">setmetatable</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">proxy</span>
<span class="k">end</span>

<span class="n">days</span> <span class="o">=</span> <span class="n">readOnly</span><span class="p">{</span><span class="s2">"Sunday"</span><span class="p">,</span> <span class="s2">"Monday"</span><span class="p">,</span> <span class="s2">"Tuesday"</span><span class="p">,</span> <span class="s2">"Wednesday"</span><span class="p">,</span>
<span class="s2">"Thursday"</span><span class="p">,</span> <span class="s2">"Friday"</span><span class="p">,</span> <span class="s2">"Saturday"</span><span class="p">}</span>


<span class="nb">print</span><span class="p">(</span><span class="n">days</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">--&gt; Sunday</span>
<span class="n">days</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Noday"</span>
<span class="c1">-- stdin:1: attempt to update a read-only table</span>

</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 协程</title>
      <link href="http://localhost:4000/lua-coroutine/"/>
      <pubDate>2017-03-16T05:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-coroutine</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>协同程序（coroutine）与多线程情况下的线程比较类似：有自己的堆栈，自己的局
部变量，有自己的指令指针，但是和其他协同程序共享全局变量等很多信息。线程和协
同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线
程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这
个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
</blockquote>

<p>宏观上可能看成是比线程更小的执行单位。但本质上，它是线程管理下的单位。这就是上面所说的在任一指定时刻只有一个协同程序在运行。是一种多任务方式。</p>

<h3 id="协同的基础">协同的基础</h3>

<p>lua 提供对应一些协程的函数。如 create() status() resume() 等等。</p>

<p>创建一个协程create()</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"hello world!"</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">co</span><span class="p">)</span> 
</code></pre>
</div>

<p>查看状态，可用status</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span><span class="p">(</span><span class="nb">coroutine.status</span><span class="p">(</span><span class="n">co</span><span class="p">))</span> <span class="c1">--&gt; suspended</span>
</code></pre>
</div>

<p>协同有三个状态：挂起态、运行态、停止态。</p>

<p>让一个协程从挂起状变为运行态</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">)</span>
</code></pre>
</div>

<p>让一个协程挂起，可用yield()</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span> <span class="k">do</span>
	<span class="nb">print</span><span class="p">(</span><span class="s2">"co"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="nb">coroutine.yield</span><span class="p">()</span>
	<span class="k">end</span>
<span class="k">end</span><span class="p">)</span>
</code></pre>
</div>
<p>在程序使用resume后，协程被激活。</p>

<p>看 resume-yield 可以相互交换数据。</p>

<p>1 非对称的情况：</p>

<p>resume 把参数传入协程里。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"co"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
<span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">--&gt; co 1 2 3</span>
</code></pre>
</div>

<p>2 对称的情况：</p>

<p>yield 会把值返还给resume。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.create</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">--&gt; true 30 10</span>
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>lua 异常与错误</title>
      <link href="http://localhost:4000/lua-error/"/>
      <pubDate>2017-03-16T01:31:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-error</guid>
      <content:encoded><![CDATA[<h3 id="assert">assert</h3>

<p>Lua 提供了专门的内置函数 assert 来完成错误的检测的功能。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span> <span class="s2">"enter a number:"</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">assert</span><span class="p">(</span><span class="nb">io.read</span><span class="p">(</span><span class="s2">"*number"</span><span class="p">),</span> <span class="s2">"invalid input"</span><span class="p">)</span>
</code></pre>
</div>

<p>assert 首先检查第一个参数是否返回错误，如果不返回错误 assert 简单的返回，否则assert 以第二个参数抛出错误信息。第二个参数是可选的。</p>

<p>当函数遇到异常有两个基本的动作：返回错误代码或者抛出错误。这两种方式选择
哪一种没有固定的规则，但有一般的原则：容易避免的异常应该抛出错误否则返回错误
代码。</p>

<h3 id="异常和错误处理">异常和错误处理</h3>

<p>在 Lua 中需要处理错误，需要使用 pcall 函数封装你的代码。
用法如下：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="nb">pcall</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="k">then</span>
	<span class="c1">-- no errors while running `foo'</span>
<span class="o">...</span>
<span class="k">else</span>
<span class="c1">-- `foo' raised an error: take appropriate actions</span>
<span class="o">...</span>
<span class="k">end</span>

</code></pre>
</div>
<p>foo 为检测的函数。</p>

<p>用做匿名函数则是：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="k">if</span> <span class="nb">pcall</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="o">...</span> <span class="k">end</span><span class="p">)</span> <span class="k">then</span> <span class="o">...</span>
<span class="k">else</span> <span class="o">...</span>

</code></pre>
</div>
<p>pcall 在保护模式下调用他的第一个参数并运行，因此可以捕获所有的异常和错误。
如果没有异常和错误，pcall 返回 true 和调用返回的任何值；否则返回 nil 加错误信息。</p>

<h4 id="错误信息和回跟踪tracebacks">错误信息和回跟踪（Tracebacks）</h4>

<p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展看（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。</p>

<p>debug库提供了两个通用的错误处理函数:</p>
<ul>
  <li>debug.debug：提供一个Lua提示符，让用户来价差错误的原因</li>
  <li>debug.traceback：根据调用桟来构建一个扩展的错误消息。</li>
</ul>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">xpcall</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="nb">error</span><span class="p">(</span><span class="s1">'error..'</span><span class="p">)</span> <span class="k">end</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="nb">print</span><span class="p">(</span><span class="nb">debug.traceback</span><span class="p">())</span> <span class="k">end</span><span class="p">,</span> <span class="mi">33</span><span class="p">)</span>
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>lua 函数</title>
      <link href="http://localhost:4000/lua-function/"/>
      <pubDate>2017-03-15T19:16:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/lua-function</guid>
      <content:encoded><![CDATA[<p>lua的函数有必要记录可能也就是 可变参数, 后面的命名参数和多个返回值和python基本一样。</p>

<h3 id="可变参数">可变参数</h3>

<p>Lua 函数可以接受可变数目的参数，和 C 语言类似在函数参数列表中使用三点（…）
表示函数有可变的参数。Lua 将函数的参数放在一个叫 arg 的表中，除了参数以外，arg
表中还有一个域 n 表示参数的个数。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">g</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="k">end</span>

<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">nil</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span>
<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span>
<span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">;</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">}</span>

</code></pre>
</div>
<p>Lua 的函数还一些特性和C不一样的是：它和其他值（数值、字符串）一样，函数可以被存放在变
量中，也可以存放在表中，可以作为函数的参数，还可以作为函数的返回值。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="nb">print</span> <span class="o">=</span> <span class="nb">math.sin</span> <span class="c1">-- `print' now refers to the sine function</span>
<span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">(</span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">--&gt; 0.841470</span>
</code></pre>
</div>

<p>如函数被嵌套的函数里，它可以访问他外部函数中的变量。这一特性强大编程能力。</p>

<p>另一个特征是：匿名函数。</p>

<p>用表达式创建函数：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">foo</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="k">end</span>
</code></pre>
</div>

<h3 id="闭包">闭包</h3>

<p>当一个函数内部嵌套另一个函数定义时，内部的函数体可以访问外部的函数的局部变量，这种特征我们称作词法定界。虽然这看起来很清楚，事实并非如此，词法定界加上第一类函数在编程语言里是一个功能强大的概念，很少语言提供这种支持。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">newCounter</span><span class="p">()</span>
	<span class="kd">local</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">return</span> <span class="k">function</span><span class="p">()</span> <span class="c1">-- anonymous function</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">i</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">newCounter</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 2</span>

</code></pre>
</div>
<p>i不是全局变量也不是局部变量，我们称作外部的局部变量（external local variable）或者 upvalue。</p>

<p>匿名函数使用 upvalue i 保存他的计数，当我们调用匿名函数的时候 i 已经超出了作用范围，因为创建 i 的函数 newCounter 已经返回了。然而 Lua 用闭包的思想正确处理了这种情况。简单的说闭包是一个函数加上它可以正确访问的 upvalues。如果我们再次调
用 newCounter，将创建一个新的局部变量 i，因此我们得到了一个作用在新的变量 i 上的
新闭包。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="n">c2</span> <span class="o">=</span> <span class="n">newCounter</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c2</span><span class="p">())</span> <span class="c1">--&gt; 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="p">())</span> <span class="c1">--&gt; 3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c2</span><span class="p">())</span> <span class="c1">--&gt; 2</span>

</code></pre>
</div>
<p>技术上来讲，闭包指值而不是指函数，函数仅仅是闭包的一个原型声明；尽管如此，
在不会导致混淆的情况下我们继续使用术语函数代指闭包。</p>

<p>闭包在上下文环境中提供很有用的功能，如高级函数（sort）的参数；作为函数嵌套的函数（newCounter）。这一机制使得我们可以在 Lua 的函数世界里组合出奇幻的编程技术。闭包也可用在回调函数中。</p>

<h3 id="全局函数和局部函数">全局函数和局部函数</h3>

<p>局部函数就是在函数前加一个 local。</p>

<p>局部函数的两种方式：</p>

<ol>
  <li>方式一</li>
</ol>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="n">f</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">end</span>
<span class="kd">local</span> <span class="n">g</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">f</span><span class="p">()</span> <span class="c1">-- external local `f' is visible here</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre>
</div>

<ol>
  <li>方式二</li>
</ol>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="k">function</span> <span class="nf">f</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>有一点需要注意的是在声明递归局部函数的方式。
要提前定义local。</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="kd">local</span> <span class="n">fact</span>
<span class="n">fact</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<h3 id="尾调用proper-tail-calls">尾调用（Proper Tail Calls）</h3>

<p>尾调用是一种类似在函数结尾的 goto 调用，当函数最后一个动作是调用另外一个函
数时，我们称这种调用尾调用。例如：</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="k">function</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>g 的调用是尾调用。</p>

<p>例子中 f 调用 g 后不会再做任何事情，这种情况下当被调用函数 g 结束时程序不需
要返回到调用者 f；所以尾调用之后程序不需要在栈中保留关于调用者的任何信息。</p>

<p>如下三种不是尾调函数.</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code>
<span class="n">r</span> <span class="n">eturn</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">-- must do the addition</span>
<span class="k">return</span> <span class="n">x</span> <span class="ow">or</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1">-- must adjust to 1 result</span>
<span class="k">return</span> <span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">-- must adjust to 1 result</span>
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>日志模块</title>
      <link href="http://localhost:4000/model-log/"/>
      <pubDate>2016-12-15T17:23:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/model-log</guid>
      <content:encoded><![CDATA[<p>系统的开发，日志模块的是必不可少的。特别对于业务逻辑层的来说，有日志输出，很方便跟踪逻辑大概情况。但是对于底层的核心模块来说，日志输出反而成了累赘。日志的输出同样占有I/O。再者，对于底层的逻辑，一般都是比较复杂，核心。暴露出来也没必要。业务逻辑层同样没有必要去了解它。所以，一般的做法是：底层出错，返回错误编码。由上一层记录就OK了。</p>

<p>日志模块一般可以分为 print/note、 debug、 warn、error。人个觉得这四个层次就够了。当然，也可多增加几个，例如，trac。我曾经用于特别的调试，只是一些非必现的问题调试，把日志输出到这层，方便查找。</p>

<p>对于这四层，是分开几个文件，还是在同一个文件中？ 其实这两种方式我都用过。这些年的经验，感觉写到同一个文件中，比较分四个文件要好。理由是很清楚的知道日志输出的前后时间顺序。当然分开成几个日志文件输出，也是有办法按时间查看的，只要用linux的一些工具手段而已。分开成几个文件的好处，就是一看就知道是否有错误输出了。同一个文件，只能在文件中查到才知道。</p>

<p>无论是 apache,还是nignx，日志的输出都是分层，配置不同层次的，只有高于或等于它的才能被输出。当然，我们设计时也可以直接指定层次print、warn、error。</p>

<p>有日志输出，就意味着有日志文件的管理。如文件大小、文件命名、所在目录、如何清理。
一般，我的做法是日志文件的大小设计成可配置。在相关的配置文件中指定。
二，日志文件的命名，我是按模块名来命名（即进程名）。或加上日期或日期在体现在目录上。
三，所在目录，我选择是把所有的日志放到同一个Log目录下，千万别把分别放到不同模块的目录里面。这样做的好处是：我们可以系统中划出一个分区来，专门存放日志，和服务的进程分离开。这样做的理由是：如果日志输出过来，把硬盘空间爆了，不会影响到服务的运行。
四，对清理， 我没有体现在于日志模块里，而是用计划任务做定时清理。</p>

<p>日志模块应该有可配置性。 一般有：
路径、文件大小、模块名、输出层次、</p>

<p>日志的输出涉及到I/O。所以对效率是有一定的影响的。 必竞这是定文件的。有一个很不错的设计：就是日志写到队列（用共享内存实现 的）然后由专门的日志进程（logsvr）输出到文件中。这样日志输出就不会有I/O阻塞了，提高一些效率。</p>

<p>下一回，把日志的模块整理好，分析一下。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>余华-活着</title>
      <link href="http://localhost:4000/alive/"/>
      <pubDate>2016-10-15T17:23:53+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/alive</guid>
      <content:encoded><![CDATA[<p>这本书是从微博上看网友介绍的，还是朋友介绍的，我也不记得了。在kindle上看有已经购买。应该是一次买了后，忘记了看了。这两天上下班在地铁上，就把它给看了。</p>

<p>书里的主人公叫福贵。一个旧社会里的有钱人的少爷。年少时就一个败家子。按他妈的说法是上梁不正下梁歪。因为他老子年轻也也是败家子，败了家里的一百多亩田地。后来开窍了，好好的在经营自己的田地。他就边上厕所也会跑到自家的田地，可是就是肥水不流外人田的吧。老子还是蛮希望福贵能光大门楣的。结果还是一败家子。把他没败完的另一百多亩也败完了。</p>

<p>最后他爸把所有的田契和房契都让人换成了铜钱，整整三大担。让福贵自己挑去还赌债。福贵把肩膀都磨破了。才知道祖辈挣下这些钱不知要累死多少人。他自己挑都快累死了。这时才知道他老子为什么不要银元要铜钱。
破产后，他们只能去住茅草屋。没多久福贵的老子在拉屎的时候死了。家里能卖的东西也都卖光了。福贵只能去租田来种，可他是个就个少爷。可怜了他的老妈和老婆。
话说他老婆也是个好女人。一个城里米行的小姐，也读过书。嫁给一个败家子。最后再怎么受苦也跟定他了。 在福贵去城里为他妈找大夫时，他被国民党抓了壮丁。一去就是五年，幸好没有死，被共产党俘虏后放了。到家时，他妈死了，大女儿在生病时聋哑啊。小儿子也不认识他了。</p>

<p>然后，解放了，新中国成立了， 三反三反，大跃进，砸锅炼钢，文化大革命。开始了生产大队的大食堂的生活，最后没粮食了，食堂解散了，大伙都没有吃的。只能挖树根，然后说着要相信政府，相信党。可队长每一次都是空手而回的。大伙开始去乞讨，福贵的老婆说要去城里看望老父，其实就是去乞讨。却真的在街上碰到了父亲。（真想知道他们当时的场景）老父给她从自己的牙缝里省下的来小米。她高兴的回到家，福贵去不敢开社，因为知道一开灶全村都知道了。福贵要确认村里没有人才敢开灶。这让我想我爸说过一件。有一次，我开玩笑的对他说，如果中国经济真的不行了。我们是不是家里存点什么东西啊。他说：没什么用， 全村都没有，就我们家有，也是存不了的。想到爸之前的意思，他是不是以前就经历过这样的事。</p>

<p>儿子在医院给他输血时，被抽空死了。聋哑女儿好不容易嫁了个好人歪头。却在难产也死了。老婆却一直在生病，在女儿死后三个月也死了。儿子女子都死了，她没什么好操心的了。她死后也有福贵料理后事。而福贵的后事也有他的外孙。所以她死得安心。接下来的，是他的女婿歪头也在工地出意外死了，留下了外孙和他相依为命。可最后，边他的外孙也在吃豆撑死了。在福贵年迈时，他所有的亲人都死了。</p>

<p>他在床边放十块钱，全村的人都知道，那是给替他收尸的人的。他存了几年的钱，想为他外孙买头牛。却在看到别人宰杀一头老牛时，心生怜悯。买了一头老牛。村里人都是这牛活不过四五年，可他却不在意，他觉得自己的自己应该活不了那么久。</p>

<p>写得比较朴素简单，文字很简单。但福贵的命却是很悲剧的。不过，过他福贵自己讲出来的人生却没有悲剧的感觉。可能这就是《活着》想表达的东西吧。</p>

<p>最后想说的，那真个操蛋的年代 。</p>

<p>– 深圳 北站</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>libevent 初步分析</title>
      <link href="http://localhost:4000/libevent-base/"/>
      <pubDate>2016-07-16T01:32:03+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/libevent-base</guid>
      <content:encoded><![CDATA[<h3 id="一-reactor模式">一 reactor模式</h3>

<p>整个libevent本身就是一个reactor。reactor翻译成反应堆，是一种事件驱动机制。libevent，底层所运用的就是例epoll这样的一些模型。</p>

<p>应用程序一般都要在reactor注册回调函数。当事件被触发时，回调函数会被调用。这些事件可能是I/O读写， 定时器和信号。</p>

<p>reactor模型：必备的几个组件：事件源、reactor框架、多路利用机制和事件处理函数。</p>

<p><strong>事件源：</strong></p>

<p>Linux上是文件描述符， win下的socket 或 handle.</p>

<p><strong>event demultipexer (事件多路分发机制)：</strong></p>

<p>linux下如：epoll、 select、kqueue、devpoll</p>

<p>当有事件到达时， event demultiplexer会发出通知。这时相关的事件就成了就绪状态。libevent会在非阻塞的情况下进行处理。</p>

<p>libevent用 eventtop对 select epoll poll 等进行了封闭，形成统一的接口。</p>

<p><strong>reactor 反应器：</strong></p>

<p>reactor是事件管理接口。内部使用 event demultiplexer 注册、注销事件；并运行事件循环，
当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。对应到 libevent 中，就是 event_base 结构体。</p>

<p><strong>事件处理流程图：</strong></p>

<p>1）首先应用程序准备并初始化 event，设置好事件类型和回调函数；</p>

<p>2）向 libevent 添加该事件 event。对于定时事件， libevent 使用一个小根堆管理， key 为超
时时间；对于 Signal 和 I/O 事件， libevent 将其放入到等待链表（ wait list）中，这是一
个双向链表结构；</p>

<p>3） 程序调用 event_base_dispatch()系列函数进入无限循环，等待事件，以 select()函数为例；
每次循环前 libevent 会检查定时事件的最小超时时间 tv，根据 tv 设置 select()的最大等
待时间，以便于后面及时处理超时事件；当 select()返回后，首先检查超时事件，然后检查 I/O 事件；</p>

<p><img src="/assets/network/libevent_event_next.png" alt="" /></p>

<h3 id="二--源码文件组织结构">二  源码文件组织结构</h3>

<p>头文件、内部使用的头文件、辅助功能函数、日志、libevent框架、对系统I/O多路复用机制的封装
信号管理、定时事件管理、缓冲区管理、基本数据和基于libevent的两个实用库的向个部分。</p>

<p><strong>头文件</strong></p>

<p>event.h：事件宏定义、接口函数声明，主要结构体event的声明；</p>

<p>xxx-internal.h：内部数据结构和函数，对外不可见，以达到信息隐藏的目的；</p>

<p><strong>libevent框架</strong></p>

<p>event.c：event整体框架的代码实现；</p>

<p>对系统I/O多路复用机制的封装</p>

<ul>
  <li>epoll.c：对epoll的封装；</li>
  <li>select.c：对select的封装；</li>
  <li>devpoll.c：对dev/poll的封装;</li>
  <li>kqueue.c：对kqueue的封装；</li>
</ul>

<p><strong>定时事件管理</strong></p>

<p>min-heap.h：其实就是一个以时间作为key的小根堆结构；</p>

<p><strong>信号管理</strong></p>

<p>signal.c：对信号事件的处理；</p>

<p><strong>辅助功能函数</strong></p>

<p>evutil.h 和evutil.c：一些辅助功能函数，包括创建socket pair和一些时间操作函数：加、减和比较等。</p>

<p><strong>日志</strong></p>

<p>log.h和log.c：log日志函数</p>

<p><strong>缓冲区管理</strong></p>

<p>evbuffer.c和buffer.c：libevent对缓冲区的封装；</p>

<p><strong>基本数据结构</strong></p>

<p>compat\sys下的两个源文件：queue.h是libevent基本数据结构的实现，包括链表，双向链表，队列等；
_libevent_time.h：一些用于时间操作的结构体定义、函数和宏定义；</p>

<p><strong>实用网络库</strong></p>

<p>http和evdns：是基于libevent实现的http服务器和异步dns查询库</p>

<h3 id="三-事件event">三 事件event</h3>

<p>主要的结构体：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event_base</span> <span class="c1">// event最主要的结构，
</span><span class="k">struct</span> <span class="n">eventop</span>    <span class="c1">// 定义backend结构， 通过它定义各个模型，
</span></code></pre>
</div>

<ul>
  <li>ev_events： event关注的事件类型，它可以是以下3种类型：</li>
  <li>I/O事件：  EV_WRITE和EV_READ</li>
  <li>定时事件： EV_TIMEOUT</li>
  <li>信号：     EV_SIGNAL</li>
  <li>辅助选项： EV_PERSIST，表明是一个永久事件</li>
</ul>

<p>ev_next， ev_active_next 和 ev_signal_next 都是双向链表节点指针。</p>

<p>I/O和Signal事件使用了双向链表。</p>

<p>定时事件 使用了小根堆 min_heap_idx.</p>

<p>ev_next 是该I/O事件在链表中的位置，表示是“已注册事件链表”。
ev_signal_next signal事件在signal事件链表中的位置。
ev_active_next libevent将所有的激活事件放入到链表active list中，然后遍历 active list执行调度，ev_active_next就指明了event在active list中的位置。</p>

<p><strong><em>libevent 对 event 的管理</em></strong></p>

<p><img src="/assets/network/libevent_event_managemant.png" alt="" /></p>

<p>事件设置的接口函数</p>

<p>libevent 提供了函数：event_set(), event_base_set(), event_priority_set()。</p>

<p>设置事件 如：I/O事件、 时间事件、信号事件:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">event_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</code></pre>
</div>

<p>设置 event ev 将要注册到的 event_base；</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_base_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">)</span>
</code></pre>
</div>

<p>设置event ev的优先级:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_priority_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pri</span><span class="p">)</span>
</code></pre>
</div>

<h3 id="四-事件处理框架">四 事件处理框架</h3>

<p>事件处理都是围绕着 event_base。</p>

<p>初始化一个 event_base。 本质上是调用了 event_base_new_with_config。</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span> <span class="n">event_init</span><span class="p">()</span>
</code></pre>
</div>

<p>也是 初始化一个 event_base。不同的是 先创建了一个struct event_config。 这个东西是干什么用的还清楚。</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span> <span class="n">event_base_new</span><span class="p">()</span>
</code></pre>
</div>

<p>内部主要调用了 event_add_internal()</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</code></pre>
</div>

<p>内部主要调用了 event_del_internal()</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">);</span>
</code></pre>
</div>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">event_base_loop</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loops</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">event_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">);</span>
	
<span class="kt">void</span> <span class="n">event_process_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="五--事件主循环">五  事件主循环</h3>

<p>struct evsig_info // 这个又是干吗的？</p>

<p><strong>I/O和Timer事件的统一</strong></p>

<p>libevent将Timer和Signal事件都统一到了系统的I/O 的demultiplex机制中了，</p>

<p>堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是O(lgN)。而获取最小key值（小根堆）的复杂度为O(1)。</p>

<p><strong>I/O和Signal事件的统一</strong></p>

<p>如果当Signal发生时，并不立即调用event的callback函数处理信号，而是设法通知系统的I/O机制，让其返回，然后再统一和I/O事件以及Timer一起处理。</p>

<h3 id="六-集成信号处理">六 集成信号处理</h3>

<p>singal和I/O的事件统一是通过 socket pair的方式实现。（这个方式有点像是管道）</p>

<h3 id="七-io多路复用技术">七 I/O多路复用技术</h3>

<p>libevent根据系统配置和编译选项决定使用哪一种I/O demultiplex机制，而不支持在运行阶段根据配置再次选择。</p>

<h3 id="十一-时间管理">十一 时间管理</h3>

<p>Libevent 本身不是多线程安全的
libevent 库的其他组件提供其他功能，包括缓冲的事件系统（用于缓冲发送到客户端/从客户端接收的数据）以及 HTTP、DNS 和 RPC 系统的核心实现。</p>

<p>可以对比一下 libev</p>

<hr />

<p>参考：<a href="http://pan.baidu.com/s/1hssU5KC"><strong>libevent源码深度剖析.pdf</strong></a></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>linux corefile 设置</title>
      <link href="http://localhost:4000/linux-corefile/"/>
      <pubDate>2014-10-16T03:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/linux-corefile</guid>
      <content:encoded><![CDATA[<p>程序运行的过程中,可能会因为一些隐藏的bug导致崩溃,为了在出问题时，及时记录所在环境的情况，所以要设置core文件的产生。其实其本质就是把进程的内存保存到文件中去。</p>

<h4 id="1core文件的生成开关和大小限制">1.core文件的生成开关和大小限制</h4>

<p>1）使用ulimit -c命令可查看core文件的生成开关。若结果为0，则表示关闭了此功能，不会生成core文件。
2）使用ulimit -c filesize命令，可以限制core文件的大小（filesize的单位为kbyte）。</p>

<p>3）若ulimit -c unlimited，则表示core文件的大小不受限制。如果生成的信息超过此大小，将会被裁剪，最终生成一个不完整的core文件。在调试此core文件的时候，gdb会提示错误。</p>

<h4 id="2core文件的名称和生成路径">2.core文件的名称和生成路径</h4>

<p>若系统生成的core文件不带其他任何扩展名称，则全部命名为core。新的core文件生成将覆盖原来的core文件。</p>

<p>1）/proc/sys/kernel/core_uses_pid可以控制core文件的文件名中是否添加pid作为扩展。文件内容为1，表示添加pid作为扩展名，生成的core文件格式为core.xxxx；为0则表示生成的core文件同一命名为core。
可通过以下命令修改此文件：
echo “1” &gt; /proc/sys/kernel/core_uses_pid</p>

<p>2）proc/sys/kernel/core_pattern可以控制core文件保存位置和文件名格式。
可通过以下命令修改此文件：
echo “/corefile/core-%e-%p-%t” &gt; core_pattern，可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳
以下是参数列表:</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>%p - insert pid into filename 添加pid
%u - insert current uid into filename 添加当前uid
%g - insert current gid into filename 添加当前gid
%s - insert signal that caused the coredump into the filename 添加导致产生core的信号
%t - insert UNIX <span class="nb">time </span>that the coredump occurred into filename 添加core文件生成时的unix时间
%h - insert hostname where the coredump happened into filename 添加主机名
%e - insert coredumping executable name into filename 添加命令名
</code></pre>
</div>

<h4 id="3core文件的查看">3.core文件的查看</h4>

<p>core文件需要使用gdb来查看。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>gdb ./a.out
core-file core.xxxx
</code></pre>
</div>

<p>使用bt命令即可看到程序出错的地方。
以下两种命令方式具有相同的效果，但是在有些环境下不生效，所以推荐使用上面的命令。
1）gdb -core=core.xxxx</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>file ./a.out
bt
</code></pre>
</div>

<p>2）gdb -c core.xxxx</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>file ./a.out
bt
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>liunx下调试gdb</title>
      <link href="http://localhost:4000/linux-gdb/"/>
      <pubDate>2014-10-15T17:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/linux-gdb</guid>
      <content:encoded><![CDATA[<h3 id="一-单步执行和跟踪函数调用">一 单步执行和跟踪函数调用</h3>
<p>例子源码：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">add_range</span><span class="p">(</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"result[0]=%d</span><span class="se">\n</span><span class="s">result[1]=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>1、在编译时要加上-g选项，生成的可执行文件才能用gdb进行源码级调试。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>gcc -g main.c -o main
<span class="gp">$ </span>gdb main
</code></pre>
</div>

<p>gdb加-g编译时并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。</p>

<p>2、帮助命令</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">help</span>
</code></pre>
</div>

<p>进一步查看某一类别中有哪些命令，例如查看files类别下有哪些命令可用：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">help </span>files
</code></pre>
</div>

<p>3、 list命令</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> list
</code></pre>
</div>

<p>一次只列10行。
gdb的很多常用命令有简写形式，例如list命令可以写成l，要列一个函数的源代码也可以用函数名做参数：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> l add_range
</code></pre>
</div>

<p>4、退出gdb的环境</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> quit
</code></pre>
</div>

<p>5、start命令开始执行程序</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> start
Breakpoint 1 at 0x80483ad: file main.c, line 14.
Starting program: /home/akaedu/main 
main <span class="o">()</span> at main.c:14
14 result[0] <span class="o">=</span> add_range<span class="o">(</span>1, 10<span class="o">)</span>;
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre>
</div>

<p>6、next命令（简写为n）控制这些语句一条一条地执行。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> n
15 result[1] <span class="o">=</span> add_range<span class="o">(</span>1, 100<span class="o">)</span>;
<span class="o">(</span>gdb<span class="o">)</span> （直接回车）
16 <span class="nb">printf</span><span class="o">(</span><span class="s2">"result[0]=%d</span><span class="se">\n</span><span class="s2">result[1]=%d</span><span class="se">\n</span><span class="s2">"</span>, result[0], 
result[1]<span class="o">)</span>;
<span class="o">(</span>gdb<span class="o">)</span> （直接回车）
result[0]<span class="o">=</span>55
result[1]<span class="o">=</span>5105
17 <span class="k">return </span>0;
</code></pre>
</div>

<p>7、用step命令（简写为s）钻进add_range函数中去跟踪执行</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> s
add_range <span class="o">(</span><span class="nv">low</span><span class="o">=</span>1, <span class="nv">high</span><span class="o">=</span>10<span class="o">)</span> at main.c:6
6 <span class="k">for</span> <span class="o">(</span>i <span class="o">=</span> low; i &lt;<span class="o">=</span> high; i++<span class="o">)</span>
</code></pre>
</div>

<p>8、backtrace命令（简写为bt）可以查看函数调用的栈帧</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> bt
<span class="c">#0 add_range (low=1, high=10) at main.c:6</span>
<span class="c">#1 0x080483c1 in main () at main.c:14</span>
</code></pre>
</div>

<p>9 info命令（简写为i）查看add_range函数局部变量的值：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> i locals
i <span class="o">=</span> 0
sum <span class="o">=</span> 0
</code></pre>
</div>

<p>10、frame命令（简写为f）选择1号栈帧然后再查看局部变量：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> f 1
<span class="c">#1 0x080483c1 in main () at main.c:14</span>
14 result[0] <span class="o">=</span> add_range<span class="o">(</span>1, 10<span class="o">)</span>;
<span class="o">(</span>gdb<span class="o">)</span> i locals 
result <span class="o">=</span> <span class="o">{</span>0, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, 
...
-1208623680<span class="o">}</span>
</code></pre>
</div>

<p>11、用print命令（简写为p）打印出变量sum的值：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>gdb<span class="o">)</span> （直接回车）
6 <span class="k">for</span> <span class="o">(</span>i <span class="o">=</span> low; i &lt;<span class="o">=</span> high; i++<span class="o">)</span>
<span class="o">(</span>gdb<span class="o">)</span> p sum
<span class="nv">$1</span> <span class="o">=</span> 3
</code></pre>
</div>

<p>12、finish命令让程序一直运行到从当前函数返回为止：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> finish
Run till <span class="nb">exit </span>from <span class="c">#0 add_range (low=1, high=10) at main.c:6</span>
0x080483c1 <span class="k">in </span>main <span class="o">()</span> at main.c:14
14 result[0] <span class="o">=</span> add_range<span class="o">(</span>1, 10<span class="o">)</span>;
Value returned is <span class="nv">$2</span> <span class="o">=</span> 55
</code></pre>
</div>

<h4 id="二--断点">二  断点</h4>
<p>例子源码</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">"input=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>1、display命令使得每次停下来的时候都显示当前sum的值，然后继续往下走。
     undisplay命令可以取消跟踪显示，变量sum的编号是1，可以用undisplay 1命令取消它的跟踪显示</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> display sum
1: sum <span class="o">=</span> -1208103488
<span class="o">(</span>gdb<span class="o">)</span> n
9 scanf<span class="o">(</span><span class="s2">"%s"</span>, input<span class="o">)</span>;
1: sum <span class="o">=</span> 0
<span class="o">(</span>gdb<span class="o">)</span> 
123
10 <span class="k">for</span> <span class="o">(</span>i <span class="o">=</span> 0; input[i] !<span class="o">=</span> <span class="s1">'\0'</span>; i++<span class="o">)</span>
1: sum <span class="o">=</span> 0
</code></pre>
</div>

<p>2、break命令的参数也可以是函数名，表示在某个函数开头设断点。现在用continue命令（简写为c）连续运行而非单步运行，程序到达断点会自动停下来，这样就可以停在下一次循环的开头。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> l
5 int sum <span class="o">=</span> 0, i;
6 char input[5];
7 
8 <span class="k">while</span> <span class="o">(</span>1<span class="o">)</span> <span class="o">{</span>
9 scanf<span class="o">(</span><span class="s2">"%s"</span>, input<span class="o">)</span>;
10 <span class="k">for</span> <span class="o">(</span>i <span class="o">=</span> 0; input[i] !<span class="o">=</span> <span class="s1">'\0'</span>; i++<span class="o">)</span>
11 sum <span class="o">=</span> sum<span class="k">*</span>10 + input[i] - <span class="s1">'0'</span>;
12 <span class="nb">printf</span><span class="o">(</span><span class="s2">"input=%d</span><span class="se">\n</span><span class="s2">"</span>, sum<span class="o">)</span>;
13 <span class="o">}</span>
14 <span class="k">return </span>0;
<span class="o">(</span>gdb<span class="o">)</span> b 9
Breakpoint 2 at 0x80483bc: file main.c, line 9.
<span class="o">(</span>gdb<span class="o">)</span> c
Continuing.
<span class="nv">input</span><span class="o">=</span>123
Breakpoint 2, main <span class="o">()</span> at main.c:9
9 scanf<span class="o">(</span><span class="s2">"%s"</span>, input<span class="o">)</span>;
1: sum <span class="o">=</span> 123
</code></pre>
</div>

<p>3、用info命令可以查看已经设置的断点：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>Breakpoint 3 at 0x8048411: file main.c, line 12.
<span class="o">(</span>gdb<span class="o">)</span> i breakpoints
Num Type Disp Enb Address What
2 breakpoint keep y 0x080483c3 <span class="k">in </span>main at main.c:9
breakpoint already hit 1 <span class="nb">time
</span>3 breakpoint keep y 0x08048411 <span class="k">in </span>main at main.c:12
</code></pre>
</div>

<p>4、每个断点都有一个编号，可以用编号指定删除某个断点：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> delete breakpoints 2
<span class="o">(</span>gdb<span class="o">)</span> i breakpoints 
Num Type Disp Enb Address What
3 breakpoint keep y 0x08048411 <span class="k">in </span>main at main.c:12
</code></pre>
</div>

<p>5、有时候一个断点暂时不用可以禁用掉而不必删除，这样以后想用的时候可以直接启用，而不必重新
从代码里找应该在哪一行设断点：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> disable breakpoints 3
<span class="o">(</span>gdb<span class="o">)</span> i breakpoints 
Num Type Disp Enb Address What
3 breakpoint keep n 0x08048411 <span class="k">in </span>main at main.c:12
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">enable </span>3
<span class="o">(</span>gdb<span class="o">)</span> i breakpoints 
Num Type Disp Enb Address What
3 breakpoint keep y 0x08048411 <span class="k">in </span>main at main.c:12
<span class="o">(</span>gdb<span class="o">)</span> delete breakpoints 
Delete all breakpoints? <span class="o">(</span>y or n<span class="o">)</span> y
<span class="o">(</span>gdb<span class="o">)</span> i breakpoints
No breakpoints or watchpoints.
</code></pre>
</div>

<p>6、gdb的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当sum不等于0时才中断，然后用run命令（简写为r）重新从程序开头连续运行：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>9 <span class="k">if </span>sum !<span class="o">=</span> 0
Breakpoint 5 at 0x80483c3: file main.c, line 9.
<span class="o">(</span>gdb<span class="o">)</span> i breakpoints 
Num Type Disp Enb Address What
5 breakpoint keep y 0x080483c3 <span class="k">in </span>main at main.c:9
stop only <span class="k">if </span>sum !<span class="o">=</span> 0
<span class="o">(</span>gdb<span class="o">)</span> r
The program being debugged has been started already.
Start it from the beginning? <span class="o">(</span>y or n<span class="o">)</span> y
Starting program: /home/akaedu/main 
123
<span class="nv">input</span><span class="o">=</span>123
Breakpoint 5, main <span class="o">()</span> at main.c:9
9 
</code></pre>
</div>

<h3 id="三-观察点">三 观察点</h3>

<p>1、x命令打印指定存储单元的内容。7b是打印格式，b表示每个字节一组，7表示打印7组。</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> x/7b input
0xbfb8f0a7: 0x31 0x32 0x33 0x34 0x35 
0x00 0x00
</code></pre>
</div>

<p>2 观察点</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> watch input[5]
Hardware watchpoint 2: input[5]
<span class="o">(</span>gdb<span class="o">)</span> i watchpoints 
Num Type Disp Enb Address What
2 hw watchpoint keep y input[5]
</code></pre>
</div>

<p>四 段错误</p>

<p>如果程序运行时出现段错误，用gdb可以很容易定位到究竟是哪一行引发的段错误，例如这个小程
序：</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">man</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">man</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<p>调试过程如下：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>gdb main
...
<span class="o">(</span>gdb<span class="o">)</span> r
Starting program: /home/akaedu/main 
123
Program received signal SIGSEGV, Segmentation fault.
0xb7e1404b <span class="k">in </span>_IO_vfscanf <span class="o">()</span> from /lib/tls/i686/cmov/libc.so.6
<span class="o">(</span>gdb<span class="o">)</span> bt
<span class="c">#0 0xb7e1404b in _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6</span>
<span class="c">#1 0xb7e1dd2b in scanf () from /lib/tls/i686/cmov/libc.so.6</span>
<span class="c">#2 0x0804839f in main () at main.c:6</span>
</code></pre>
</div>

<h3 id="五设置变量">五设置变量</h3>

<p>有时候，在调试程序时，我们不单单只是查看运行时的变量，我们还可以直接设置程序中的变量，以模拟一些很难在测试中出现的情况，比较一些出错，或是switch的分支语句。使用set命令可以修改程序中的变量。</p>

<p>另外，你知道gdb中也可以有变量吗？就像shell一样，gdb中的变量以$开头，比如你想打印一个数组中的个个元素，你可以这样：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set</span> <span class="nv">$i</span> <span class="o">=</span> 0
<span class="o">(</span>gdb<span class="o">)</span> p a[<span class="nv">$i</span>++]
</code></pre>
</div>

<p>当然，这里只是给一个示例，表示程序的变量和gdb的变量是可以交互的。</p>

<h3 id="六-调试宏">六 调试宏</h3>

<p>在GDB下，我们无法print宏定义，因为宏是预编译的.所以要在GCC编译程序的时候，加上-ggdb3参数 就可以了。
另外，你可以使用下述的GDB的宏调试命令 来查看相关的宏。
info macro – 你可以查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。
macro – 你可以查看宏展开的样子。</p>

<h3 id="七-命令行参数">七 命令行参数</h3>

<p>有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。其实，有两种方法：</p>

<ul>
  <li>gdb命令行的 –args 参数</li>
  <li>gdb环境中 set args命令。</li>
</ul>

<h3 id="八-调试程序的子进程">八 调试程序的子进程</h3>

<p>用的是follow-fork-mode这个参数。方法是：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="nb">set </span>follow-fork-mode <span class="o">[</span>parent|child]

</code></pre>
</div>

<p>parent: fork之后继续调试父进程，子进程不受影响。
child: fork之后调试子进程，父进程不受影响。
因此如果需要调试子进程，在启动gdb后：</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>follow-fork-mode child
<span class="nb">set </span>detach-on-fork <span class="o">[</span>on|off]
</code></pre>
</div>

<p>on: 断开调试follow-fork-mode指定的进程。
off: gdb将控制父进程和子进程。follow-fork-mode指定的进程将被调试，另一个进程置于暂停（suspended）状态。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>TCP协议杂记</title>
      <link href="http://localhost:4000/tcp-base/"/>
      <pubDate>2014-10-15T17:08:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/tcp-base</guid>
      <content:encoded><![CDATA[<p>从四个方面来理解TCP协议
1 TCP头部信息
2 TCP 状态转移过程
3 TCP 数据流
4 TCP数据流的控制</p>

<p>TCP为什么叫数据流：应用程序对数据的发送和接收是没有边界限制的。
TCP为什么是可靠的：TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，其次，采用超时重传机制。</p>

<p>UDP虽然说是不可靠服务，但是可以在上层协议来处理数据确认和超时重传。</p>

<p>** TCP 固定头结构: **</p>

<p><img src="/assets/network/tcp-base-1.png" alt="" /></p>

<p>16位端口号：告知这个报文来自那个源端口和给上层协议或者应用那个目的端口。（注意IP是在IP协议层里的）
32位序号：一次TCP通信（从TCP连接到断开）过程中某一个传输方向上的字节流的每个字节编号。
32位确认号：用作对另一方发送来的TCP报文的响应。
4位头部长度：标识该TCP头部多少个32bit字（4字节）因为4位最大能表示15，所以TCP头最长60字节。（15*4=60）
6位标志们包含好下：
（1）URG 表示紧急指针是否有效
（2）ACK 表示确认号是否有效
（3）PSH 提示接收端应用程序应该即人TCP接收缓冲区中读走数据，为接收后续数据腾出空间。
（4）RST 表示要求对方重新连接。
（5）SYN 表示请求建立一个连接。
（6）FIN 表示通知对方本端村关闭连接。</p>

<p>16位窗口大小:是TCP流量控制的一个手段。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
16位校验和：同发送方填充。用CRC对数据作检验，这个校验不肥包括TCP头部，也包括数据部分，TCP可靠传输的一个生要保障。
16位紧急指针：是一个正的偏移量，它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。
TCP头部选项：这部分最后含有40字节。
kind=0：选项表结束选项
kind=1：空操作（nop）选项
kind=2：最大报文段长度选项，TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节 的TCP头部和20字节的IP头部）对以太网而言，MSS值是1460（1500-40）
kind=3：窗口扩大因子选项 。窗口扩大因了选项只能出现在同步报文段中。
kind=4：选择性确认 。使TCP模块只能重新发送丢失的TCP报文段、不用发送所有未被确认的 TCP报文段。
kind=5：SACK实际工作的选项
kind=8    时间戳选项 提供较为准确的计算通信双方之间的回路时间的方法。</p>

<p><strong>半关闭状态</strong></p>

<p>TCP 连接是全双工的，所以它允许两个方向的数据传输被独立关闭，通信的一端可艰送结束报文给对方，告诉它本端已经完成了数据的发送。但允许继续接收来息对方的数据 ，直到对方也发送结束报文段以关闭连接。TCP连接的这种状态称为半关闭状态。
服务器和客户端应用程序 判断对方是否已经关闭连接的方法是：read系统调用返回0（收到结束报文段）。
socket网络编程接口通过shutdown函数提供了对阗关闭的支持。</p>

<p>连接超时 ~~</p>

<p><strong>三次握手 四次挥手:</strong></p>

<p><img src="/assets/network/tcp-base-2.png" alt="" /></p>

<p>TIME_WAIT状态
从图可以看，客户端连接在收到 服务器的结束报文段之后，并没有直接进入 CLOSED状态，而是转移到TIME_WAIT状态。在这个状态，客户端连接要等待一段时间为2MSL的时间。才能完全关闭。
MSL是TCP报文段在刚和　的最大生存时间。</p>

<p><strong>TIME_WAIT状态存在的原因有两点:</strong> 
1）可靠地终止TCP连接
2）保证让发来的TCP报文段有足够的时间被识别并丢弃。</p>

<p>第一个原因：用于确认服务器结束报文段６和报文段７丢失。那么服务器重发结束报文段。因此客户端需要停留在某个以处理重复收到的结束报文段（即向服务器发送确认报文段）
第二个原因：在linux系统上，一个TCP端口不能被同时打开多次（两次及以上）。当一个TCP连接处于TIME_WAIT状态时。我们将无法立即使用该连接占用着的端口来建立一个连接。如果不存在TIME_WAIT，则应用程序程序能够立即建立一个和刚关闭的连接相似的连接（同IP地址和端口号）这个新连接被称了连接的化身。它可能会接收到属于原来的连接的应用程序数据。这是不应该发的事。  <br />
另外，历为TCP报文段的最大生存时间是MSL,所以坚持 2M  SL时间的TIME_WAIT状态能够确保网络上两具传输方向上接收到的、迟到的TCP报文都已经消失。因此一个新连接可能在2MSL时间后安全地建立。</p>

<p>复位报文段
在某些特殊条件下，TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段。</p>

<p>异常终止连接
TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排除等待的数据都将被丢弃。</p>

<p>处理半打开连接
服务器（或客户端）关闭或者异常终止了连接，而对方没有接收到结束报文段（比如发生了网络故障），此时，客户端（或服务端）还维持着原来的连接，而服务器（或客户端）即使重启，也已经没有该连接的任何信息了。我们将这种状态称为打开状态，处于这种连接称为半找连接。如果客户端（或服务器）往处于阗打开连接写入数据，则对方方将回应一个复位报文段。</p>

<p>TCP交互数据流
TCP报文段所携带的应用程序数据按照长度分为两种：交互数据和成块数据。交互灵气公包含很少的字节。使用交互数据的应用程序（或协议）对实时性求高。如telnet、ssh。成块数据的长度则通常用TCP报文段允许的最大数据长度。使用成块数据的应用程序 （协议）对传输效率要求高，如ftp。</p>

<p>带外数据
带外数据用于迅速通知对方本端发生的重要事件。因此，带外数据比普通数据（也称为带内数据）表更高的优先级。它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。
UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式 。</p>

<p>TCP超时重传
TCP服务必须能够重传超时间内未收到确认的TCP报文段。为此， TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。一共会执行5次重传。次数可以系统相关配置更改。/proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2 前者指定 在底IP接管之前TCP最少执行的重传次数，默认值是３，后者指定 连接放弃前TCP最多可以执行的重传次数，默认值是15。</p>

<p>拥塞控制
TCP拥塞控制的四个部分：慢启动、拥塞避免、快速重传、快速恢复、快速恢复。</p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
