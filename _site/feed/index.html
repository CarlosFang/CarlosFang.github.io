<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2018-09-13T21:11:35+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>devlog-2018-09</title>
      <link href="http://localhost:4000/devlog201809/"/>
      <pubDate>2018-09-13T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/devlog201809</guid>
      <content:encoded><![CDATA[<h3 id="2018-09-13">2018-09-13</h3>
<hr />
<p>1.muduo 中的 epoll 能否支持超时回调呢？其实就是问epoll 能否支持超时回调？<a href="https://github.com/chenshuo/muduo/issues/337">muduo能否支持epoll超时回调？？？</a></p>

<p>2.epoll 超时的话就应该是在 outtime时间里没有等到事件就返回了。这时返回值应该0。这么理解有问题吗？</p>

<p>3.今天重新看muduo的一些源码，加强对muduo的一些解理。还是有一些收获的。对于EventLoop Poller Channel 有了一些加强。
  也慢慢的开始注意了一些细节的事物了。如：一些 <code class="highlighter-rouge">(void) t</code> 的运用。只是想让这个变量被使用。从而不会变量未被使用的错误。</p>

<p>在知乎上有一个关于这个讨论， 陈硕回答下的下评论，有意思。<a href="https://www.zhihu.com/question/24311085">muduo库的很多返回值为空的函数的最后一行都有类似 (void) n的一句， 为什么要这样做？</a></p>

<p>4.后面写代码时要多用assert。 把gcc的编译严格等级设置为任何警告当成错误，而有的变量实际上是在debug版本中assert时有用的，release时这个变量就没用了， 此时编译器就会提醒有个变量没用的警告。</p>

<p>5.rvo优化  <a href="https://www.zhihu.com/question/27000013">什么时候应当依靠返回值优化（RVO）？</a></p>
<h3 id="2018-09-14">2018-09-14</h3>
<hr />
]]></content:encoded>
    </item>
    
    <item>
      <title>go的竞争检测</title>
      <link href="http://localhost:4000/go-check-race/"/>
      <pubDate>2018-03-02T04:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-check-race</guid>
      <content:encoded><![CDATA[<p><code class="highlighter-rouge">go run -race</code> 或者 <code class="highlighter-rouge">go build -race</code> 来进行竞争检测。</p>

<p>golang语言内部大概的实现就是同时开启多个goroutine执行同一个命令，并且纪录每个变量的状态。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="p">(</span><span class="x">
    </span><span class="s">"time"</span><span class="x">
    </span><span class="s">"fmt"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="x">
    </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(){</span><span class="x">
        </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">2</span><span class="x">
    </span><span class="p">}()</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">3</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"a is "</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="p">)</span><span class="x">

    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>这个程序可以看出变量a出现了竞争。</p>

<p>在windows下执行</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go run: <span class="nt">-race</span> and <span class="nt">-msan</span> are only supported on linux/amd64, freebsd/amd64, darwin
/amd64 and windows/amd64
</code></pre></div></div>

<p>在linux下执行</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="x"> </span><span class="n">is</span><span class="x">  </span><span class="m">3</span><span class="x">
</span><span class="o">==================</span><span class="x">
</span><span class="n">WARNING</span><span class="o">:</span><span class="x"> </span><span class="n">DATA</span><span class="x"> </span><span class="n">RACE</span><span class="x">
</span><span class="n">Write</span><span class="x"> </span><span class="n">at</span><span class="x"> </span><span class="m">0x00c4200140a8</span><span class="x"> </span><span class="n">by</span><span class="x"> </span><span class="n">goroutine</span><span class="x"> </span><span class="m">6</span><span class="o">:</span><span class="x">
  </span><span class="n">main</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">func1</span><span class="p">()</span><span class="x">
      </span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">race</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">11</span><span class="x"> </span><span class="o">+</span><span class="m">0x3b</span><span class="x">

</span><span class="n">Previous</span><span class="x"> </span><span class="n">write</span><span class="x"> </span><span class="n">at</span><span class="x"> </span><span class="m">0x00c4200140a8</span><span class="x"> </span><span class="n">by</span><span class="x"> </span><span class="n">main</span><span class="x"> </span><span class="n">goroutine</span><span class="o">:</span><span class="x">
  </span><span class="n">main</span><span class="o">.</span><span class="n">main</span><span class="p">()</span><span class="x">
      </span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">race</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">13</span><span class="x"> </span><span class="o">+</span><span class="m">0x8e</span><span class="x">

</span><span class="n">Goroutine</span><span class="x"> </span><span class="m">6</span><span class="x"> </span><span class="p">(</span><span class="n">running</span><span class="p">)</span><span class="x"> </span><span class="n">created</span><span class="x"> </span><span class="n">at</span><span class="o">:</span><span class="x">
  </span><span class="n">main</span><span class="o">.</span><span class="n">main</span><span class="p">()</span><span class="x">
      </span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">race</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">10</span><span class="x"> </span><span class="o">+</span><span class="m">0x7d</span><span class="x">
</span><span class="o">==================</span><span class="x">
</span><span class="n">Found</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="n">race</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="n">exit</span><span class="x"> </span><span class="n">status</span><span class="x"> </span><span class="m">66</span><span class="x">
</span></code></pre></div></div>
<p><strong>13行 出现变量竞争。</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go build 时的错误分析</title>
      <link href="http://localhost:4000/go-build-error/"/>
      <pubDate>2018-03-01T19:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-build-error</guid>
      <content:encoded><![CDATA[<p>go build 程序时，如果出现：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>warning: building out-of-date packages:

runtime/pprof

testing

regexp/syntax

regexp

installing these packages with <span class="s1">'go test -i'</span> will speed future tests.
</code></pre></div></div>

<p>那么就是说明下面的包已经有修改过了，但是没有重新install</p>

<p>如果有标准的包过期，使用go install -a -v std来进行更新</p>

<p>如果是自定义的包过期，重新调用go install</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go gdb 编译</title>
      <link href="http://localhost:4000/go-gdb/"/>
      <pubDate>2018-03-01T18:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-gdb</guid>
      <content:encoded><![CDATA[<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go build <span class="nt">-gcflags</span> <span class="s2">"-N -l"</span> demo.go
</code></pre></div></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>go关于defer的一道面试题</title>
      <link href="http://localhost:4000/go-defer-1/"/>
      <pubDate>2018-03-01T18:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-defer-1</guid>
      <content:encoded><![CDATA[<p>请写出输出结果</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">(){</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="x">
    </span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">2</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="x"> </span><span class="kt">int</span><span class="p">){</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>结果是</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3
0 2 2
0 2 2
1 3 4
</code></pre></div></div>

<h4 id="考察两个知识点">考察两个知识点：</h4>

<p>1.defer是栈调用，后写的先执行</p>

<p>2.defer的函数调用语句会在父函数调用后执行，但是用到的参数会在当时就执行得出</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go vet检测代码错误</title>
      <link href="http://localhost:4000/go-ver/"/>
      <pubDate>2018-03-01T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-ver</guid>
      <content:encoded><![CDATA[<p>这个种方式很不错，当代码量很大时，可以用这种方式去做检测。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x"> </span><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">Func</span><span class="p">(</span><span class="n">num</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"call Func</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"num = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">num</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"num = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">,</span><span class="x"> </span><span class="m">3</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Func</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>使用vet工具检测代码：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go build demo.go
<span class="nv">$ </span>go tool vet demo.go
demo.go:7: arg num <span class="k">for </span><span class="nb">printf </span>verb %s of wrong <span class="nb">type</span>: int
demo.go:8: wrong number of args <span class="k">for </span>format <span class="k">in </span>Printf call: 1 needed but 3 args
 
</code></pre></div></div>

<p>通过vet工具，可以检测到go代码中一些可疑的结构，虽然vet不能确保发现的问题都是真正的错误，但是它可以发现一些编译器无法捕获的错误。</p>

<p>例如示例中，这段代码能正常的编译通过，但是通过vet检测出2个问题，第一个问题是打印的格式与参数类型不匹配，第二个问题需要打印的参数和所给参数数量不一致。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go 资料</title>
      <link href="http://localhost:4000/go-material/"/>
      <pubDate>2018-03-01T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-material</guid>
      <content:encoded><![CDATA[<ul>
  <li>github Go语言资料收集 <a href="https://github.com/wonderfo/wonderfogo/wiki">https://github.com/wonderfo/wonderfogo/wiki</a></li>
  <li>这个人的几篇blog可以看 <a href="http://www.cnblogs.com/yjf512/category/385369.html">http://www.cnblogs.com/yjf512/category/385369.html</a></li>
  <li>这不是一个go项目，他是一个学习go的资料网站，属于著名的awesome系列，里面关于go的资源非常详细。<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a></li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>go 编译时传递参数</title>
      <link href="http://localhost:4000/go-build-ldflags/"/>
      <pubDate>2018-03-01T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-build-ldflags</guid>
      <content:encoded><![CDATA[<p>很有意思，可能运用的场景不多。如果想调试某个模块时，可以在编译直接给他赋值。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">var</span><span class="x"> </span><span class="n">BuildDate</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"no build date"</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"build date: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">BuildDate</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>传递参数步骤：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go build demo.go
<span class="nv">$ </span>./demo
build <span class="nb">date</span>: no build <span class="nb">date</span>
<span class="nv">$ DATE</span><span class="o">=</span><span class="sb">`</span><span class="nb">date</span> <span class="s1">'+%Y-%m-%d-%I:%M:%S'</span><span class="sb">`</span>
<span class="nv">$ </span>go build <span class="nt">-ldflags</span> <span class="s2">"-X main.BuildDate=</span><span class="nv">$DATE</span><span class="s2">"</span> demo.go
<span class="nv">$ </span>./demo
build <span class="nb">date</span>: 2018-05-03-03:15:35
</code></pre></div></div>
<p>通过-X选项，可以给go程序传递相关参数。例如示例中，借助-X选项，将编译日期BuildDate实时传递到程序中。另外，如版本信息之类也可以通过该方式实现。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go笔记 初学简记</title>
      <link href="http://localhost:4000/go-first/"/>
      <pubDate>2018-03-01T15:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-first</guid>
      <content:encoded><![CDATA[<p>这一篇笔记来源于不同的书籍,有《go语言圣经》，还有许式伟的《Go语言编程》。有一些来源于网络。并不是每一本书都全部看完，便尽力做吧。有一些章节并没有很好理解，要吧记下，后面基础越来越好时可以继续看下去。</p>

<ol>
  <li>go 竟然支持GDB。</li>
  <li>go有一个make函数，可以创建很多类型。</li>
  <li>go 保留c语言的指针和goto。</li>
  <li>小写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用</li>
  <li>go语言提供了一个内置函数delete()，用于删除容器内的元素 。</li>
  <li><strong>RPC很有意思</strong></li>
  <li><strong>反射</strong></li>
  <li>预定义常量，iota一个特别常量，可以被认为是一个可被编译器修改的常量，在每一个const关键字出现时被重置为0，然后在下一个const出现之前，每出现一次iota，其所代表的数字会自动增1。
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span><span class="x"> </span><span class="p">(</span><span class="x"> </span><span class="c">// iota被重设为0</span><span class="x">
   </span><span class="n">c0</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="no">iota</span><span class="x"> </span><span class="c">// c0 == 0</span><span class="x">
   </span><span class="n">c1</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="no">iota</span><span class="x"> </span><span class="c">// c1 == 1</span><span class="x">
   </span><span class="n">c2</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="no">iota</span><span class="x"> </span><span class="c">// c2 == 2</span><span class="x">
</span><span class="p">)</span><span class="x"> 
</span></code></pre></div>    </div>
    <p>所以，这个东西可用于枚举。</p>
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span><span class="x"> </span><span class="p">(</span><span class="x">
</span><span class="n">Sunday</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="no">iota</span><span class="x">
</span><span class="n">Monday</span><span class="x">
</span><span class="n">Tuesday</span><span class="x">
</span><span class="n">Wednesday</span><span class="x">
</span><span class="n">Thursday</span><span class="x">
</span><span class="n">Friday</span><span class="x">
</span><span class="n">Saturday</span><span class="x">
</span><span class="n">numberOfDays</span><span class="x"> </span><span class="c">// 这个常量没有导出</span><span class="x">
</span><span class="p">)</span><span class="x">  
</span></code></pre></div>    </div>
  </li>
</ol>

<h3 id="go的类型">GO的类型</h3>
<hr />
<ol>
  <li>基础类型
    <ul>
      <li>布尔类型：bool。</li>
      <li>整型：int8、byte、int16、int、uint、uintptr等。</li>
      <li>浮点类型：float32、float64。</li>
    </ul>
  </li>
  <li>复数类型：complex64、complex128。
    <ul>
      <li>字符串：string。</li>
      <li>字符类型：rune。</li>
      <li>错误类型：error。</li>
    </ul>
  </li>
  <li>其他复合类型：
    <ul>
      <li>指针（pointer）</li>
      <li>数组（array）</li>
      <li>切片（slice）</li>
      <li>字典（map）</li>
      <li>通道（chan）</li>
      <li>结构体（struct）</li>
      <li>接口（interface）</li>
    </ul>
  </li>
  <li>注意
两个不同类型的整型数不能直接比较，比如int8类型的数和int类型的数不能直接比较，但`各种类型的整型变量都可以直接与字面常量（literal）进行比较</li>
</ol>

<h3 id="切片-slice">切片 Slice</h3>
<hr />
<ol>
  <li>slice的语法和数据有很像，只是没有固定长度。</li>
  <li>slice由三个部分构成：指针、长度、容量。</li>
  <li>多个slice之间可以共享底层的数据，并全引用的数组部分区间可能重叠。</li>
  <li>字符串的切片操作和[]byte字节类型切片的切片操作是类似的。</li>
  <li>x[m:n]切处操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新[]byte</li>
  <li>和数组不同的时是,slice之间不能比较。因此我们不能使用==操作来判断两具slice是否含有全部相等元素。</li>
  <li>之所以不直接比较去运算符，有两方面，一是slice的元素是间接引用，一个slice甚至可以包含自身。二是slice在不同的时间可能包含不同元素，底层数据的元素可能会被修改。</li>
  <li>测试一个slice是否是空的， len(s) == 0,  不应该用s==nil来判断。</li>
  <li>make 函数创建一个指定元素类型。长度 和容量的slice。</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="n">T</span><span class="p">,</span><span class="x"> </span><span class="nb">len</span><span class="p">)</span><span class="x">
 </span><span class="nb">make</span><span class="p">([]</span><span class="n">T</span><span class="p">,</span><span class="x">  </span><span class="nb">len</span><span class="p">,</span><span class="x"> </span><span class="nb">cap</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>
<ol>
  <li>append函数，用于向slice追加元素。
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x">    </span><span class="k">func</span><span class="x"> </span><span class="n">appendInt</span><span class="p">(</span><span class="n">x</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">y</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">][]</span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
   </span><span class="k">var</span><span class="x"> </span><span class="n">z</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x"> 
   </span><span class="n">zlen</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="m">1</span><span class="x">
   </span><span class="k">if</span><span class="x"> </span><span class="n">zlen</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="nb">cap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
       </span><span class="n">z</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">x</span><span class="x"> </span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">]</span><span class="x"> 
   </span><span class="p">}</span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
       </span><span class="n">zcap</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">zlen</span><span class="x">
       </span><span class="k">if</span><span class="x"> </span><span class="nb">cap</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="x">
           </span><span class="n">zcap</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">2</span><span class="o">*</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="x">
       </span><span class="p">}</span><span class="x">
       </span><span class="n">z</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">mak</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">zlen</span><span class="p">,</span><span class="x"> </span><span class="n">zcap</span><span class="p">)</span><span class="x">
       </span><span class="nb">copy</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="x"> </span><span class="n">x</span><span class="p">)</span><span class="x">
   </span><span class="p">}</span><span class="x">
   </span><span class="n">z</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">y</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">z</span><span class="x"> 
    </span><span class="p">}</span><span class="x">
</span></code></pre></div>    </div>
  </li>
  <li>copy函数第一个是目标， 第一个是源</li>
</ol>

<h3 id="map">map</h3>
<hr />
<ol>
  <li>GO中的map底层是用哈希表做的。</li>
  <li>浮点数用做key类型则是一个坏的想法，可能会出错。</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x">    </span><span class="n">ages</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="x"> </span><span class="p">(</span><span class="nb">make</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span><span class="x">
    
    </span><span class="n">ages</span><span class="x"> </span><span class="p">;</span><span class="o">=</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="x">
        </span><span class="s">"alice"</span><span class="x"> </span><span class="o">:</span><span class="x"> </span><span class="m">13</span><span class="p">,</span><span class="x">
        </span><span class="s">"charlie"</span><span class="x"> </span><span class="o">:</span><span class="x"> </span><span class="m">34</span><span class="p">,</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span></code></pre></div></div>
<ol>
  <li>不能对map的元素进行取址操作，  _ = &amp;ages[“bob”] // compile error :cannot take address of map elemnet</li>
  <li>因为随着map的增大，可能会重新进行分配空间</li>
  <li>map的迭代顺充是不的，并且不同的哈希函数袖可能导致不同的遍历顺序。如果想顺序遍历则对key进行显式的排序。</li>
  <li>if age, ok := ages[“bob”]; !ok {/* */}</li>
  <li>和clice一样，map之间不能进行相等的比较，唯一的例外是和nil进行比较。要判断两个是否包含相同的key和value。要循环一个一个来。</li>
</ol>

<h3 id="结构体">结构体</h3>
<hr />
<ol>
  <li>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话，可以被合并到一行。</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x">   </span><span class="k">type</span><span class="x"> </span><span class="n">Employee</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
       </span><span class="n">ID</span><span class="x">            </span><span class="kt">int</span><span class="x"> 
       </span><span class="n">Name</span><span class="p">,</span><span class="x"> </span><span class="n">Address</span><span class="x"> </span><span class="kt">string</span><span class="x">
       </span><span class="n">Dob</span><span class="x">           </span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="x">
   </span><span class="p">}</span><span class="x"> 
</span></code></pre></div></div>
<ol>
  <li>结松体成员的输入顺序也有重要的意义。 如果要交换Name和Address 出现的顺序，那么就是定义不同的结构类型。</li>
  <li>如果结构体成员名字是以大写字母开头的，那么成员就是导出的，这是GO语言导出决定的。一个结构体可能同时包含导出和未导出的成员。</li>
  <li>一个命名为S的结构体类型汪能两元信S类型的成员。因为一个聚合的值不能包含它自身。但是S类型的结构可以包含*S指针类型成员。</li>
  <li>结构体的零值是每个成员都是零值。</li>
  <li>结构体没有任何成员的訞不是空结构体，写作struct{}。它的大小为0,不包含任何信息。</li>
  <li>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回。</li>
  <li>结构体嵌入和匿名成员。Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字，这类成员就是叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x">   </span><span class="k">type</span><span class="x"> </span><span class="n">Point</span><span class="x"> </span><span class="k">struct</span><span class="p">{</span><span class="x">
       </span><span class="n">x</span><span class="p">,</span><span class="x"> </span><span class="n">y</span><span class="x"> </span><span class="kt">int</span><span class="x"> 
   </span><span class="p">}</span><span class="x">
   
   </span><span class="k">type</span><span class="x"> </span><span class="n">Cirecle</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
       </span><span class="n">Point</span><span class="x">
       </span><span class="n">Radius</span><span class="x"> </span><span class="kt">int</span><span class="x">
   </span><span class="p">}</span><span class="x">
   
   </span><span class="k">type</span><span class="x"> </span><span class="n">Wheel</span><span class="x"> </span><span class="k">struct</span><span class="p">{</span><span class="x">
       </span><span class="n">Circle</span><span class="x"> 
       </span><span class="n">Spokes</span><span class="x"> </span><span class="kt">int</span><span class="x">
   </span><span class="p">}</span><span class="x">
</span></code></pre></div></div>
<ol>
  <li>因为匿名成员也且个隐匿的名字，不能同进包含两个类型相同的匿名成员，这会导致名字冲突。</li>
  <li>成员的名字是由其类型隐匿地决定的。</li>
</ol>

<h3 id="函数">函数</h3>
<hr />
<ol>
  <li>调用多返回值函数时， 返回给调用者的是一组值，调用者必须显式的交这些分配给变量
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">link</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">findLinks</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="x">
</span></code></pre></div>    </div>
  </li>
  <li>如果某个值不被使用，可以将其分配给blank indentifier</li>
  <li>也可以交一个返回多个参数的函数伤脑筋为该函数的参数，这很少出现在实际生产代码中，这个可以用在代码debug时很方便。</li>
  <li>v如果一个函数将所有的返回值都显示的变量名，那么该return 语句可以活力操作数。这称之为bare return.
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x"> </span><span class="k">func</span><span class="x"> </span><span class="n">ConutWordsAndImages</span><span class="p">(</span><span class="n">url</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="n">words</span><span class="p">,</span><span class="x">  </span><span class="n">images</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">){</span><span class="x">
     </span><span class="n">resp</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="x">
     </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="n">nul</span><span class="x"> </span><span class="p">{</span><span class="x">
         </span><span class="k">return</span><span class="x">   </span><span class="c">// 这个地方的返回是  return words, images, err</span><span class="x">
     </span><span class="p">}</span><span class="x">
        
     </span><span class="c">//.... </span><span class="x">
 </span><span class="p">}</span><span class="x">
</span></code></pre></div>    </div>
  </li>
  <li>函数被看作第一类值（first-class values）:函数像其他值一样，拥有类型，可以被赋值其他变量，传递函数，从函数返回。对函数值的调用类似函数调用。
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x"> </span><span class="k">func</span><span class="x"> </span><span class="n">square</span><span class="p">(</span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">    </span><span class="k">return</span><span class="x"> </span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="x"> </span><span class="p">}</span><span class="x">
 </span><span class="n">f</span><span class="o">:=</span><span class="x"> </span><span class="n">square</span><span class="x">
 </span><span class="n">fmt</span><span class="p">,</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="m">3</span><span class="p">))</span><span class="x">  </span><span class="c">// "9"</span><span class="x">
</span></code></pre></div>    </div>
  </li>
  <li>函数值可与nil比较
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x"> </span><span class="k">var</span><span class="x"> </span><span class="n">f</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">int</span><span class="x"> 
 </span><span class="k">if</span><span class="x"> </span><span class="n">f</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
     </span><span class="n">f</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="x">
 </span><span class="p">}</span><span class="x">
</span></code></pre></div>    </div>
  </li>
  <li>函数值之间是不能可比较的，也不能做map的key。</li>
  <li>匿名函数 在func关键籽后没有函数名。</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">squares</span><span class="p">()</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">x</span><span class="x">  </span><span class="kt">int</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">x</span><span class="o">++</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">f</span><span class="x"> </span><span class="err">：</span><span class="o">=</span><span class="x"> </span><span class="n">squares</span><span class="p">()</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">())</span><span class="x"> </span><span class="c">// "1"</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">())</span><span class="x"> </span><span class="c">// "4"</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>9.这个地方的变量生命周期不由它的作用域决定。</p>

<p>10.当匿名函数需要被递归调用时，我们必须首先声明一个变量。再将匿名函数赋值给这变量。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">visiAll</span><span class="x"> </span><span class="n">finc</span><span class="p">(</span><span class="n">item</span><span class="x"> </span><span class="p">[]</span><span class="kt">string</span><span class="p">)</span><span class="x">
</span><span class="n">visiAll</span><span class="x">  </span><span class="o">=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">items</span><span class="x"> </span><span class="p">[]</span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">item</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">items</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="o">!</span><span class="n">seen</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">seen</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="no">true</span><span class="x">
            </span><span class="n">visitAll</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">item</span><span class="p">])</span><span class="x">
            </span><span class="c">//...</span><span class="x">
        </span><span class="p">}</span><span class="x">

</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>11.在循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值，以dir为例，后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x">    </span><span class="k">var</span><span class="x"> </span><span class="n">rmdirs</span><span class="x"> </span><span class="p">[]</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">d</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">tempDirs</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">dir</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">d</span><span class="x"> </span><span class="c">// NOTE: necessary </span><span class="x">
        </span><span class="n">os</span><span class="o">.</span><span class="n">MkdirAll</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span><span class="x"> </span><span class="m">0755</span><span class="p">)</span><span class="x"> </span><span class="c">// creates parent directiories too </span><span class="x">
        </span><span class="n">rmdirs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">rmdirs</span><span class="p">,</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">os</span><span class="o">.</span><span class="n">RemoverAll</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="x">
            
        </span><span class="p">})</span><span class="x">
    </span><span class="p">}</span><span class="x">
    
    </span><span class="c">/////</span><span class="x">
     </span><span class="k">var</span><span class="x"> </span><span class="n">rmdirs</span><span class="x"> </span><span class="p">[]</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">dir</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">tempDirs</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">os</span><span class="o">.</span><span class="n">MkdirAll</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span><span class="x"> </span><span class="m">0755</span><span class="p">)</span><span class="x"> </span><span class="c">// creates parent directiories too </span><span class="x">
        </span><span class="n">rmdirs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">rmdirs</span><span class="p">,</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">os</span><span class="o">.</span><span class="n">RemoverAll</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="x"> </span><span class="c">// NOTE incorrect </span><span class="x">
            
        </span><span class="p">})</span><span class="x">
    </span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>12.如果你使用go语句或者defer语句，会经常遇到些类问题，这不是go或defer本身导致的，而是因为它们都会等待的循环结束后，再执行函数值。</p>

<p>13.参数数量可变的函数称为可变参函数。 在声明可变参数函数时，要在参数列表的最后一个参数类型之前加上省略符号”…”</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">sum</span><span class="x"> </span><span class="p">(</span><span class="n">vals</span><span class="x"> </span><span class="o">...</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">total</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="n">val</span><span class="x"> </span><span class="o">:=</span><span class="x">  </span><span class="k">range</span><span class="x"> </span><span class="n">vals</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">total</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">val</span><span class="x"> 
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
    
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">5</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

<p>14.当defer语句被执行时，跟在defer后面的函数会被重视迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条dfer语句，它们的执行与声明顺序相反。</p>

<p>15.defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。释放资源的defer应该直接跟在请求资源的语句后。</p>

<p>16.调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。下例中的bigSlowOperation函数，直接调用trace记录函数的被调用情况。通过这种方式，我们可以只通过一个语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间，需要注意一点：不要忘记defer语句的圆的括号。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">bigSlowOperation</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">trace</span><span class="p">(</span><span class="s">"bigSlowOperation"</span><span class="p">)()</span><span class="x"> </span><span class="c">// don't forget the</span><span class="x">
    </span><span class="n">extra</span><span class="x"> </span><span class="n">parentheses</span><span class="x">
    </span><span class="c">// ...lots of work…</span><span class="x">
    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">10</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="x"> </span><span class="c">// simulate slow</span><span class="x">
    </span><span class="n">operation</span><span class="x"> </span><span class="n">by</span><span class="x"> </span><span class="n">sleeping</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">trace</span><span class="p">(</span><span class="n">msg</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">start</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="x">
    </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"enter %s"</span><span class="p">,</span><span class="x"> </span><span class="n">msg</span><span class="p">)</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"exit %s (%s)"</span><span class="p">,</span><span class="x"> </span><span class="n">msg</span><span class="p">,</span><span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">start</span><span class="p">))</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h3 id="方法">方法</h3>
<hr />
<ol>
  <li>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上。即相当 于为这种类型定义了一个独占的方法。</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">geometry</span><span class="x">
</span><span class="k">import</span><span class="x"> </span><span class="s">"math"</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">Point</span><span class="x"> </span><span class="k">struct</span><span class="p">{</span><span class="x"> </span><span class="n">X</span><span class="p">,</span><span class="x"> </span><span class="n">Y</span><span class="x"> </span><span class="kt">float64</span><span class="x"> </span><span class="p">}</span><span class="x">

</span><span class="c">// traditional function</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">Distance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="x"> </span><span class="n">q</span><span class="x"> </span><span class="n">Point</span><span class="p">)</span><span class="x"> </span><span class="kt">float64</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">math</span><span class="o">.</span><span class="n">Hypot</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="x"> </span><span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// same thing, but as a method of the Point type</span><span class="x">
</span><span class="c">// 参数p叫做访求的接收器</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">p</span><span class="x"> </span><span class="n">Point</span><span class="p">)</span><span class="x"> </span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="x"> </span><span class="n">Point</span><span class="p">)</span><span class="x"> </span><span class="kt">float64</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">math</span><span class="o">.</span><span class="n">Hypot</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">X</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">X</span><span class="p">,</span><span class="x"> </span><span class="n">q</span><span class="o">.</span><span class="n">Y</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="n">p</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Point</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">}</span><span class="x">
</span><span class="n">q</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">Point</span><span class="p">{</span><span class="m">4</span><span class="p">,</span><span class="x"> </span><span class="m">6</span><span class="p">}</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">Distance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="x"> </span><span class="n">q</span><span class="p">))</span><span class="x"> </span><span class="c">// "5", function call</span><span class="x">
</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Distance</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="x"> </span><span class="c">// "5", method call</span><span class="x">

</span></code></pre></div></div>
<p>2.在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。方法可以被 声明到任意类型，只要不是一个指针或者一个interface。</p>

<p>3.当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法。</p>

<p>4.这个方法的名字是 (*Point).ScaleBy 。这里的括号是必须的；没有括号的话这个表达式可能会被理解为 *(Point.ScaleBy) 。</p>

<p>5.如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用如下这种写法：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x">
</span><span class="n">p</span><span class="o">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>编译器会隐式的帮我们用&amp;p去调用ScaleBy这认方法。这种简写的方法只适用于“变量”，包括struct里字段比如p.X,以及array和slice内的元素比如perim[0]。</p>

<p>6.不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。</p>

<p>7.在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷
贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明
白。</p>

<p>8.Nil也是一个合法的接收器类型，这一点应该怎么用？</p>

<p>9.通过嵌入结构体来扩展类型。这个有点类型于C++中对于类的继承。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span><span class="x"> </span><span class="s">"image/color"</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">Point</span><span class="x"> </span><span class="k">struct</span><span class="p">{</span><span class="x"> </span><span class="n">X</span><span class="p">,</span><span class="x"> </span><span class="n">Y</span><span class="x"> </span><span class="kt">float64</span><span class="x"> </span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">ColoredPoint</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Point</span><span class="x">
    </span><span class="n">Color</span><span class="x"> </span><span class="n">color</span><span class="o">.</span><span class="n">RGBA</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>10.当结构体嵌入时，被嵌入的结构体和嵌入的结构体的一些方法的调用应该注意的事项，这个地方还是很理解。要复习一下。</p>

<p>11.方法值和方法表达式。 一个方法表达式可以赋值给你一个方法值。然后，这个方法值可以像函数一样的运用，</p>

<p>12.封装，一个对你的变量或方法如果对调用方是不可见的，一定就被定义为“封装”。也叫信息隐藏。</p>

<p>13.Go语言只有一种控制可见性的手段。大写首字母的标识符会宣言它们的包中被导出。小定字母的则不会。</p>

<h3 id="接口">接口</h3>
<hr />

<p>1.接口类型是一种抽象类型。它不会暴露出它所代表的对象的内部值和结构和这个对象支持的基础操作的集合。它只展示出它们自己的方法。</p>

<p>2.interface理解其为一种类型的规范或者约定。一种类型是不是“实现”了一个接口呢？就看这种类型是不是实现了接口中定义的所有方法。接口是一个或多个方法签名的集合，任何非接口类型只要拥有与之对应的全部方法实现 (包括相同的名称、参数列表以及返回值。)，就表示它”实现” 了该接口，无需显式在该类型上添加接口声明。此种方式又被称作Duck Type。</p>

<p>3.type绝不只是对应于C/C++中的typedef,它不是用于定义一系列的别名。它的作用是定义一系列互不相干的行为特征：通过这些互不相干的行为特征， 本质上同一的事物表现出不同事物的特征。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Age</span><span class="x"> </span><span class="kt">int</span><span class="x"> 
</span><span class="k">type</span><span class="x"> </span><span class="n">Height</span><span class="x"> </span><span class="kt">int</span><span class="x"> 
</span><span class="n">ytpe</span><span class="x"> </span><span class="n">Grade</span><span class="x"> </span><span class="kt">int</span><span class="x"> 
</span></code></pre></div></div>

<p>用type定义出的，是完全不同的类型。（面向不同的对象）,可对他们定义不同的方法或函数</p>

<p>4.接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例</p>

<p>5.接口内嵌</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">ReadWriter</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Reader</span><span class="x">
    </span><span class="n">Writer</span><span class="x">
</span><span class="p">}</span><span class="x"> 
</span><span class="k">type</span><span class="x"> </span><span class="n">ReadWriteCloser</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Reader</span><span class="x">
    </span><span class="n">Writer</span><span class="x">  
</span><span class="n">Closer</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>6.一个类型如果拥有一个接口需要的所有方法，那么这个类型就袖了这个接口。</p>

<p>7.flag.Value接口 帮忙命令行标记定义新的符号的</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">period</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">flag</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="s">"period"</span><span class="p">,</span><span class="x"> </span><span class="m">1</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span><span class="x"> </span><span class="s">"sleep period"</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">flag</span><span class="o">.</span><span class="n">Parese</span><span class="p">()</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"sleeping for %v ..."</span><span class="p">,</span><span class="x"> </span><span class="o">*</span><span class="n">period</span><span class="p">)</span><span class="x">
    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="o">*</span><span class="n">period</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>8.接口赋值</p>
<ul>
  <li>接口同仁并不要求两个接口必须等价 。如果接口A的方法列表是接口B的方法列表的子集，那么接口B可以赋值给接口A。</li>
</ul>

<p>9.接口查询</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">file1</span><span class="x"> </span><span class="n">Writer</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">...</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">file5</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">file1</span><span class="o">.</span><span class="p">(</span><span class="n">two</span><span class="o">.</span><span class="n">IStream</span><span class="p">);</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
</span><span class="o">...</span><span class="x">
</span><span class="p">}</span><span class="x">  
</span></code></pre></div></div>

<p>这个if语句检查file1接口指向的对象实例是否实现了two.IStream接口，如果实现了，则执行特定的代码。
在Go语言中，你可以询问接口它指向的对象是否是某个类型，比如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">file1</span><span class="x"> </span><span class="n">Writer</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">...</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">file6</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">file1</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">File</span><span class="p">);</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
</span><span class="o">...</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>这个if语句判断file1接口指向的对象实例是否是*File类型，如果是则执行特定代码。</p>

<p>10.接口组合</p>

<ul>
  <li>只不过接口只包含方法，而不包含任何成员变量。</li>
</ul>

<ol>
  <li>接口与动态类型。 用一个例子说明可能会好很多。</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">IDuck</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Quack</span><span class="p">()</span><span class="x">
    </span><span class="n">Walk</span><span class="p">()</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">DuckDance</span><span class="p">(</span><span class="n">duck</span><span class="x"> </span><span class="n">IDuck</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="m">3</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">duck</span><span class="o">.</span><span class="n">Quack</span><span class="p">()</span><span class="x">
        </span><span class="n">duck</span><span class="o">.</span><span class="n">Walk</span><span class="p">()</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">Bird</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// ...</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">b</span><span class="x"> </span><span class="o">*</span><span class="n">Bird</span><span class="p">)</span><span class="x"> </span><span class="n">Quack</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"I am quacking!"</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">b</span><span class="x"> </span><span class="o">*</span><span class="n">Bird</span><span class="p">)</span><span class="x"> </span><span class="n">Walk</span><span class="p">()</span><span class="x">  </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"I am walking!"</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">new</span><span class="p">(</span><span class="n">Bird</span><span class="p">)</span><span class="x">
    </span><span class="n">DuckDance</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<h3 id="类型系统">类型系统</h3>
<hr />

<ol>
  <li>在Go语言中，你可以给任意类型（包括内置类型，但不包括指针类型）添加相应的方法。有点像c++在结构本中定义方法。</li>
  <li>Go语言和C语言一样，类型都是基于值传递的。要想修改变量的值，只能传递指针。</li>
  <li>有四个引用语义 数组切片  map channel 接口</li>
  <li>要使某个符号对其他包（package）可见（即可以访问），需要将该符号定义为以大写字母开头</li>
</ol>

<h3 id="协程">协程</h3>
<hr />
<p>coroutine，也叫轻量级线程 。</p>

<p>最常见的并发通信模型：共享数据和消息。  Go语言提供的是另一种通信模型，即以消息机制而非共享内存作为通信方式。Go语言提供的消息通信机制被称为channel。</p>

<h3 id="channel">channel</h3>
<hr />

<ol>
  <li>基本语法
一般channel的声明形式为：</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">chanName</span><span class="x"> </span><span class="k">chan</span><span class="x"> </span><span class="n">ElementType</span><span class="x">
</span></code></pre></div></div>

<p>与一般的变量声明不同的地方仅仅是在类型之前加了chan关键字。ElementType指定这个</p>

<p>channel所能传递的元素类型。举个例子，我们声明一个传递类型为int的channel：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">ch</span><span class="x"> </span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span></code></pre></div></div>

<p>或者，我们声明一个map，元素是bool型的channel:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var m map[string] chan bool  
</code></pre></div></div>

<p>2.两个相同类型的channel可以使用==运算符比较。如果两个channnel引用是相通的对象，那比较的结果为真。一个channel也可以和nil进行比较。</p>

<p>3.select</p>

<p>select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。与switch语句可以选择任何可使用相等比较的条件相比，select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作，大致的结构如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">case</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">chan1</span><span class="o">:</span><span class="x">
    </span><span class="c">// 如果chan1成功读到数据，则进行该case处理语句</span><span class="x">
    </span><span class="k">case</span><span class="x"> </span><span class="n">chan2</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="m">1</span><span class="o">:</span><span class="x">
    </span><span class="c">// 如果成功向chan2写入数据，则进行该case处理语句</span><span class="x">
    </span><span class="k">default</span><span class="o">:</span><span class="x">
    </span><span class="c">// 如果上面都没有成功，则进入default处理流程</span><span class="x">
</span><span class="p">}</span><span class="x">  
</span></code></pre></div></div>

<p>4.一个基于无缓存Channels的发送操作将导致发送者的goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送值通过Channels成功传输之后，两个goroutine可以继续执行后面语句。反之，如果接收者操作先发生，那么接收者goroutine也将阻塞，直到有 另一个goroutine在相同的Channles执行发送的操作。</p>

<ol>
  <li>单向channle</li>
</ol>

<p>单向channel变量的声明非常简单，如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">ch1</span><span class="x"> </span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="c">// ch1是一个正常的channel，不是单向的</span><span class="x">
</span><span class="k">var</span><span class="x"> </span><span class="n">ch2</span><span class="x"> </span><span class="k">chan</span><span class="o">&lt;-</span><span class="x"> </span><span class="kt">float64</span><span class="c">// ch2是单向channel，只用于写float64数据</span><span class="x">
</span><span class="k">var</span><span class="x"> </span><span class="n">ch3</span><span class="x"> </span><span class="o">&lt;-</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="c">// ch3是单向channel，只用于读取int数据  </span><span class="x">
</span></code></pre></div></div>

<p>6.单身Channle,只有在发送者所在的goroutine才会调用close函数。因此对一个只接收的channel调用close将是一个编译错误。</p>

<p>7.关闭channel</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>close(ch)  
</code></pre></div></div>

<p>8.如何判断一个channel是否已经被关闭？</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x, ok := &lt;-ch  
</code></pre></div></div>

<p>只需要看第二个bool返回值即可，如果返回值是false则表示ch已经被关闭。</p>

<p>9.带缓冲的channel。 创建一个带缓冲的channel</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="m">1024</span><span class="p">)</span><span class="x">  
</span></code></pre></div></div>

<p>10.如果内部的缓存队列是满的，那么发送操作将阻塞真到因另一个goroutine执行接收操作面释放了新的队列空间。相反，如果 channel是空的，接收后操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p>

<ol>
  <li>超时机制</li>
</ol>

<p>Go语言没有提供直接的超时处理机制，但我们可以利用select机制。虽然select机制不是专为超时而设计的，却能很方便地解决超时问题。因为select的特点是只要其中一个case已经完成，程序就会继续往下执行，而不会考虑其他case的情况。</p>

<p>基于此特性，我们来为channel实现超时机制：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 首先，我们实现并执行一个匿名的超时等待函数</span><span class="x">
</span><span class="n">timeout</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="kt">bool</span><span class="p">,</span><span class="x"> </span><span class="m">1</span><span class="p">)</span><span class="x">
</span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1e9</span><span class="p">)</span><span class="x"> </span><span class="c">// 等待1秒钟</span><span class="x">
    </span><span class="n">timeout</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="no">true</span><span class="x">
</span><span class="p">}()</span><span class="x">

</span><span class="c">// 然后我们把timeout这个channel利用起来</span><span class="x">

</span><span class="k">select</span><span class="x"> </span><span class="p">{</span><span class="x">

    </span><span class="k">case</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">ch</span><span class="o">:</span><span class="x">  
    </span><span class="c">// 从ch中读取到数据</span><span class="x">
    </span><span class="k">case</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">timeout</span><span class="o">:</span><span class="x">
    </span><span class="c">// 一直没有从ch中读取到数据，但从timeout中读取到了数据</span><span class="x">
</span><span class="p">}</span><span class="x">  
</span></code></pre></div></div>

<h3 id="同步锁">同步锁</h3>
<hr />
<p>Go语言包中的sync包提供了两种锁类型：sync.Mutex和sync.RWMutex</p>

<h3 id="包">包</h3>
<hr />

<p>1.如何导入有相同包名的包。导入声明必须至少为一个同名包指定一个新的包名以避免冲突，叫做导入包的重命名。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
    </span><span class="s">"crypto/rand"</span><span class="x">
    </span><span class="n">mrand</span><span class="x"> </span><span class="s">"math/rand"</span><span class="x">
</span><span class="p">)</span><span class="x">
</span></code></pre></div></div>

<p>2.包的匿名导入，导入一个包而不去使用它，就会发生编译错误。可以用匿名导入</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="s">"image/png"</span><span class="x">
</span></code></pre></div></div>

<p>3.对大多数的go开发者,只需要 配置一叫GOPATH的环境变量，用来指定当前工作目录即可。当需要切不同工作区的时候，只要更新GOPATH就可以了</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">export</span><span class="x"> </span><span class="n">GOPATH</span><span class="o">=</span><span class="err">$</span><span class="n">HOME</span><span class="o">/</span><span class="n">gobook</span><span class="x">
</span><span class="k">go</span><span class="x"> </span><span class="n">get</span><span class="x"> </span><span class="n">gopl</span><span class="o">.</span><span class="n">io</span><span class="o">/....</span><span class="x">
</span></code></pre></div></div>

<p>4.查看Go工具涉及涉的所有环境变量的值。</p>

<p>5.可以用 go get 下载对应的包。</p>

<p>6.go get  命令当前流行的托管网站GitHub、Bitbucket、Launchpad。</p>

<p>7.go get 获得的代码是真实的本地存储仓库。可以用git操作。</p>

<p>8.构建包的方法  go build</p>

<p>9.go install 命令和 go build 命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。 被编译的包会被保存到$GOPATH/pkg目录下，目录路径和 src目录路径对应，可执行程序被保存到$GOPATH/bin目录。</p>

<h3 id="备注">备注</h3>
<hr />

<p><strong>后面要重新看的，如下:</strong></p>
<ul>
  <li>错误处理</li>
  <li>接口</li>
  <li>并发</li>
  <li>channel</li>
  <li>网络编程</li>
  <li>反射</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>muduo笔记  第八章 muduo网络库设计与实现</title>
      <link href="http://localhost:4000/muduo-8-muduo-EventLoop/"/>
      <pubDate>2018-01-05T04:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-8-muduo-EventLoop</guid>
      <content:encoded><![CDATA[<p>runInLoop() 线程安全的理解</p>

<p><img src="/assets/muduo/8-muduo-EventLoop.png" alt="" /></p>

<p>在线程T1 muduo::EventLoop loop;， 并loop.loop();那么这个事件应该在线程T1上跑。但是线程T2做了一件事，就是loop::runInLoop(cb); 这个时候添加回调时和loop并不是同一个线程。会有问题。</p>

<p>所以,runInLoop()的做法是：先判断是不是同一个线程，是的话就直接被执行，不是的话就加到挂起队列中。</p>

<p>// 是否在当线线程，不在就加入队列。 因为可能是其他线程执行这个代码，</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isInLoopThread</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">cb</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">queueInLoop</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在queueInLoop中会唤醒T1线程。做法是：</p>

<p>T1和T2线程有一个channel,写入一个字符。触发T1的事件，T1在loop中会执行被挂起的函数队列。</p>

<p>addTimer 要做到线程安全，就是把它的回调加入到runInLoop，这样它可以触发它所在的线程去执行。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TimerId</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span><span class="o">&amp;</span> <span class="n">cb</span><span class="p">,</span>
                             <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span>
                             <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Timer</span><span class="o">*</span> <span class="n">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">TimerId</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="84-实现tcp-网络库">8.4 实现TCP 网络库</h4>

<p>这一节主要是讲 Acceptor class。</p>

<p>Acceptor class是用于封装accept接受新连接的。为什么在单独成为一个模块类呢？</p>

<p>1.Acceptor  的成员有socket channel 。其中socket 是用了RAII handle 。</p>

<p>2.Channel用于观察此socket上的readable事件，并回调Acceptor:: handleRead()，后者会调用accept(2)来接受新连接，并回调用户callback。</p>

<p>3.关于，如果系统的fd耗尽的问题。 在一个开始，就打一个空闲的fd。当系统耗尽时，会先关闭这个空闲的fd。要给新上来的客户端accept。最后，
断开客户端，把fd交还给空闲的占用。 这么做是为了解决在系统耗尽fd时，不会断开客户端上来的链接。</p>

<h4 id="85-tcpserver--接受新连接">8.5 TcpServer  接受新连接</h4>
<hr />
<p>主要是讲TcpServer class。 tcp服务是管理accept获得TcpConnection。
这是一个新连接的接受的过程：</p>

<p><img src="/assets/muduo/8-muduo-tcpserver-class.png" alt="" /></p>

<p>TcpServer 很简单，用户只 需要设置好callback，再调用start()。就OK了。</p>

<hr />
<p>-– 《Linux多线程服务端编程：使用muduo C++ 网络库》 陈硕. 电子工业出版社. Kindle 版本.</p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
