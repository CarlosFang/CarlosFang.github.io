<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2020-02-09T19:37:11+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>《极客时间》 微服务架构核心20讲</title>
      <link href="http://localhost:4000/time-geekbang-microservice-core20/"/>
      <pubDate>2020-02-09T03:22:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/time-geekbang-microservice-core20</guid>
      <content:encoded><![CDATA[<p>极客时间学习笔记， 微服务架构核心20讲</p>

<p>作者：杨波　（拍拍贷框架研发部总监，资深架构师，微服务技术专家）</p>

<p><a href="https://time.geekbang.org/course/intro/66">微服务架构核心20讲 https://time.geekbang.org/course/intro/66</a></p>

<h2 id="1-什么是微服务架构">1 什么是微服务架构</h2>
<hr />
<p>微服务是一种架构风格（如MVC）　</p>

<p>微服务的六个特点：　</p>
<ul>
  <li>一组小的服务</li>
  <li>独立的进程</li>
  <li>轻量级通信</li>
  <li>基于业务能务</li>
  <li>独立部署</li>
  <li>无集中式管理</li>
</ul>

<p><a href="https://www.martinfowler.com/articles/microservices.html">马丁福勒的文章 https://www.martinfowler.com/articles/microservices.htm</a></p>

<p><strong>微服务定义</strong></p>

<p>基于有界上下文的　松散耦合面向服务的架构。</p>

<h2 id="２架构师如何权衡微服务的利弊">２　架构师如何权衡微服务的利弊</h2>
<hr />
<p>架构师的一个重要职责就是权衡</p>

<p>利:</p>

<ul>
  <li>强模块化边界</li>
  <li>可独立部署</li>
  <li>技术多样性</li>
</ul>

<p>弊:</p>
<ul>
  <li>分布式系统复杂性</li>
  <li>最终一致性</li>
  <li>运维复杂性</li>
  <li>测试复杂性</li>
</ul>

<p>分布式系统带来的一个挑战就是取终一致性。</p>

<h2 id="３康威法则和微服务给架构师怎样的启示">３　康威法则和微服务给架构师怎样的启示</h2>
<hr />

<p>设计系统的组织，其产生的架构设计等价于组织间的沟通结构。</p>

<p>其实就是要规避，多个团队去支持一个服务模块。应该拆解成一个团队支持一个小服务，多个小服务组织成一个大服务（或系统）。</p>

<h2 id="４企业应该在什么时候开始考虑引入微服务">４　企业应该在什么时候开始考虑引入微服务</h2>
<hr />

<p>微服务的适用性:</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_4.png" alt="" /></p>

<p>Monolth 单块服务</p>

<p>Microservice 微服务</p>

<p>微服务 有基础模块和平台的要求，所以企业刚开始时微服务并不能有高的生产力。</p>

<p>所以一般以单块服务开始。适用于小企业，微服务更加适合于中大型企业。</p>

<p>中间的交点，就是企业要考虑从单块服务切换成微服务的时候了。</p>

<p>业务模块的复杂性已经达到某个点了。 点的把控要架构师应该思考的问题、一般100人的团队可以考虑了这个问题了。</p>

<p>一般业务开始以单块服务优先。如果研发效率开始下降了。再做优化，向微服方向转变。</p>

<p>如果一开始就以微服开始，可能在设计上会更复杂。</p>

<p>架构是演化出来的。</p>

<h2 id="5-什么样组织架构更适合微服务">5 什么样组织架构更适合微服务</h2>
<hr />

<p>组织架构：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_5_1.png" alt="" /></p>

<p>左边是比较传统的组织架构。产品从左到右流程走，可能出现的问题，反馈比较慢，对业务支持比较慢。</p>

<p>右边是比较合适微服务的组织架构， 每一个团队（基于微服务的跨职能的团队），有开发，有产品，有测试，团队都支持自己的微服务。交付的产口是平台，对外提供API
接口支持多样的业务。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_5_2.png" alt="" /></p>

<p>在团队内做内部循环。端对端的开发。</p>

<p>谁开发的，谁构建，谁支持。</p>

<h2 id="6-如何理解阿里巴巴提出的微服务">6 如何理解阿里巴巴提出的微服务</h2>
<hr />

<p>中台战略和微服务的关系
下图：一线互联网主流的组织架构。 微服的标准的参考架构。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_6.png" alt="" /></p>

<p>业务中台和技术中台 统称为大中台。支撑业务前台。中台越强大，前台越发展越快。</p>

<p>PaaS 和 核心业务层是和微服务相关的。这一些基本都可以用微服务来实现。</p>

<p>IaaS：Infrastructure-as-a-Service（基础设施即服务）</p>

<p>PaaS：Platform-as-a-Service（平台即服务）</p>

<h2 id="7-如何给出一个清晰简洁的服务分层方式">7 如何给出一个清晰简洁的服务分层方式</h2>
<hr />

<p>大致的服务分层图：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_7.png" alt="" /></p>

<p>SOA  Service-Oriented Architecture  （面向服务的架构）</p>

<p>基础服务：　也有其他的说法。如：核心领域服务、中间层服务、公共服务。</p>

<p>聚合服务：　对基础服务的聚全和裁剪，以达到满足业务的需求，提供给外部调用。　</p>

<h2 id="８微服务总体技术架构体系是怎么设计的">８　微服务总体技术架构体系是怎么设计的</h2>
<hr />

<p>微服务总体架构体系图：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_8.png" alt="" /></p>

<ul>
  <li>接入层：　外部和内部接入，主要把流量接入进来，做负载均衡。</li>
  <li>网关层：　反向路由，限流，安全，跨横切面的功能。　　</li>
  <li>业务服务层：　可分为：聚合服务，基础服务。</li>
  <li>支撑服务： 后台服务。</li>
  <li>平台服务： 可以是一些管理系统。</li>
  <li>基础设施　由运维团队运维。　</li>
</ul>

<p>网关层、业务服务层、支撑服务、平台服务。 这四层可以和微服务相关的，</p>

<h2 id="9-微服务最经典的三种服务发现机制">9 微服务最经典的三种服务发现机制</h2>
<hr />

<p>消息者应该怎么去发现生产者。三者主流的模式：</p>

<p>1 通过DNS 访问LB，LB（负载均衡）。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_9_1.png" alt="" /></p>

<p>2 　LB功能放到Consumer内， service 注册到 Service Registry上。有定时心跳发到注册中收，Consumer  定期的同步 Service Registry的信息。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_9_2.png" alt="" /></p>

<p>3 结全前面两种方式， 在Consumer的主机上也布置一个LB。 LB会定期同步Service Registry的信息。 运维成本比较高一点。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_9_3.png" alt="" /></p>

<h2 id="10-微服务-api-服务网关一原理">10 微服务 API 服务网关（一）原理</h2>
<hr />

<p>API　Gateway</p>

<p>屏蔽掉服务内部的逻辑，希望外部访问看到是统一的接口。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_10_1.png" alt="" /></p>

<p>下面这个图 接入网关的前面有一层LB（负载均衡）如果是网关可以是无状态的，这样方便扩展，单点挂掉时，可以摘除。对系统的稳定性很重要。</p>

<h5 id="网关主要的功能">网关主要的功能</h5>
<ul>
  <li>反向路由  将外部的请求换成内部调用。</li>
  <li>认证安全 防刷 防爬虫。</li>
  <li>限流熔断 处理可能会突发流量。</li>
  <li>日志监控  进行访问访问审计，监控流量。</li>
</ul>

<p>一般不要把过多的业务逻辑写在网关当中。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_10_2.png" alt="" /></p>

<h2 id="11-服务-api-服务网关二开源网关-zuul">11 服务 API 服务网关（二）开源网关 Zuul</h2>
<hr />

<p>核心:  Servlet 和 Fitter Runner 
过滤器：  前置过滤器，  路由过滤器，后置过滤器</p>

<p>过滤器开发，可以通过脚本开发。开发完后上传到过滤器目录中， 被扫描后加到Filtter Runner中。</p>

<p>各个Fitte 共享数据通过 Request Context 来实现。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_11_1.png" alt="" /></p>

<p>过滤链的流程：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_11_2.png" alt="" /></p>

<h2 id="12-跟-netflix-学习微服务路由发现体系">12 跟 Netflix 学习微服务路由发现体系</h2>
<hr />

<p>netflix 有两个比较重要的支撑服务</p>

<ul>
  <li>服务注册中心  Eureka</li>
  <li>网关 zuul</li>
</ul>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_12.png" alt="" /></p>

<h2 id="13-集中式配置中心的作用和原理是什么">13 集中式配置中心的作用和原理是什么</h2>
<hr />

<p>为什么要引入配置中心呢？
　
小企业一般是写在配置文件中的，不方便管理。响应比较慢。无法审计。配置中心可能解决这些问题。</p>

<p>什么可做配置呢？</p>

<ul>
  <li>业务开关</li>
  <li>调用/响应超时</li>
  <li>限流</li>
  <li>连接字符串</li>
  <li>动态参数</li>
</ul>

<p>Svr 更新配置有两种方式 拉和推。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_13_1.png" alt="" /></p>

<p>携程的Apollo配置中心:</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_13_2.png" alt="" /></p>

<h2 id="14-微服务通讯方式-rpc-vs-rest">14 微服务通讯方式 RPC vs REST</h2>
<hr />

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_14.png" alt="" /></p>

<h2 id="15-微服务框架需要考虑哪些治理环节">15 微服务框架需要考虑哪些治理环节</h2>
<hr />

<p>一个公司的微服务多了，就要需要考虑治理。</p>

<p>软负载： 负载 跟帖</p>

<p>Metrics: 服务的调用量， 耗时监控。</p>

<p>调用链埋点： 方便快速定位问题，</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_15.png" alt="" /></p>

<p>阿里巴巴微服务治理生态：Dubbo</p>

<h2 id="16-微服务监控系统分层和监控架构">16 微服务监控系统分层和监控架构</h2>
<hr />

<p>五个层次的监控</p>

<ul>
  <li>基础设施监控</li>
  <li>系统层监控</li>
  <li>应用层监控 url sevice mysql cache 可用率，性能， qps</li>
  <li>业务层监控 核心指标监控 登录注册</li>
  <li>端用户体验监控</li>
</ul>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_16_1.png" alt="" /></p>

<p>日志 监控  对应Elasticsearch<br />
metrcs 监控
健康检查
调用链监控
告警系统</p>

<p>比较典型的监控架构，大部分公司的流程</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_16_2.png" alt="" /></p>

<p>比较大的队列用kafka 。</p>

<p>Nagios 健康检测工具。</p>

<p>ELK　ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。</p>

<h2 id="17-微服务的调用链监控该如何选型">17 微服务的调用链监控该如何选型</h2>
<hr />

<p>调用链的监控　谷歌2010年提出来的。　</p>

<p>通过 Span来跟踪， RootSpan  ChildSpan  跨进程时  会有Trace di + parant span id</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_17_1.png" alt="" /></p>

<p>三个主流调用链监控系统的比较：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_17_2.png" alt="" /></p>

<h2 id="18-微服务的容错限流是如何工作的">18 微服务的容错限流是如何工作的</h2>
<hr />

<p>Netfiix  Hystrix 具有熔断 隔离 限流 降级的功能 。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_18.png" alt="" /></p>

<p>说明：</p>

<ul>
  <li>
    <p>3 Cirult OPen 判断是否可以熔断， 是则执行 getFAllBack() 降级处理函数</p>
  </li>
  <li>
    <p>5 run() 超时 也执行降级处理函数。</p>
  </li>
  <li>
    <p>6 不成功也 执行处理函数 。</p>
  </li>
  <li>
    <p>Calculate Cirult Health 就是在正常执行成功后计算是否需要熔断。</p>
  </li>
</ul>

<h2 id="19-docker-容器部署技术--持续交付流水线">19 Docker 容器部署技术 &amp; 持续交付流水线</h2>
<hr />

<p>docker 容器治理就是解决：环境不一致的问题。把依赖的所有包都打在镜像中。</p>

<p>统一、标准化的交付流水线。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_19_1.png" alt="" /></p>

<p>发布模式： 蓝绿布置，灰度发布。</p>

<p>蓝绿、金丝雀和灰度发布：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_19_2.png" alt="" /></p>

<h2 id="20-容器集群调度和基于容器的发布体系">20 容器集群调度和基于容器的发布体系</h2>
<hr />

<p>资源调度框架 Mesos 架构</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_20_1.png" alt="" /></p>

<p>基于容器的云发布体系</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_20_2.png" alt="" /></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 条件变量 sync.Cond</title>
      <link href="http://localhost:4000/timegeekbang-go-syncCond/"/>
      <pubDate>2019-03-28T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-syncCond</guid>
      <content:encoded><![CDATA[<p>条件变量是和互斥锁一起使用的。
条件变量是和互斥锁一起使用的。</p>

<p>条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。</p>

<p>条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。</p>

<p>这里有一个疑问：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">mailbox</span><span class="x"> </span><span class="kt">uint8</span><span class="x">
</span><span class="k">var</span><span class="x"> </span><span class="n">lock</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span><span class="x">
</span><span class="n">sendCond</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span><span class="x">
</span><span class="n">recvCond</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="n">lock</span><span class="o">.</span><span class="n">RLocker</span><span class="p">())</span><span class="x">
</span></code></pre></div></div>

<p>endCond := sync.NewCond(&amp;lock)和recvCond := sync.NewCond(lock.RLocker())</p>

<p>传入的一个是 &amp;lock 另一个是 lock.RLocker() 为什么？</p>

<p><strong>条件变量的Wait方法做了什么？</strong></p>

<p>条件变量的Wait方法主要做了四件事。</p>

<p>1　把调用它的 goroutine（也就是当前的 goroutine）加入到当前条件变量的通知队列中。</p>

<p>2　解锁当前的条件变量基于的那个互斥锁。</p>

<p>3　让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 goroutine 就会阻塞在调用这个Wait方法的那行代码上。</p>

<p>4　如果通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的goroutine 就会继续执行后面的代码了。</p>

<p><strong>条件变量的Signal方法和Broadcast方法有哪些异同？</strong></p>

<p>条件变量的Signal方法和Broadcast方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 goroutine，而后者的通知却会唤醒所有为此等待的 goroutine。</p>

<p>扩展 ：https://blog.csdn.net/wentyoon/article/details/81174288</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 互斥锁 sync.Mutex与sync.RWMutex</title>
      <link href="http://localhost:4000/timegeekbang-go-syncMutex/"/>
      <pubDate>2019-03-27T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-syncMutex</guid>
      <content:encoded><![CDATA[<p>一个互斥锁可以被 用来保护一个临界区或一组相关临界区。保证在同一时刻只有一个Goroutine处于该临界区之内</p>

<p>为了兑现这保证上，每当goroutine 想进入临界区时，都要先对它进行锁定 ，离开时临界区时都要及时地对它进行解锁。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
</span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writer</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
 </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"error: %s [%d]"</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">,</span><span class="x"> </span><span class="n">id</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
</span></code></pre></div></div>

<p><strong>使用互斥锁时有哪 些注意事项：</strong></p>

<p>1 不要重复锁定互斥锁。</p>

<p>2 不要忘记解锁互斥锁，必要时用 defer 语句</p>

<p>3 不要对沿未锁定或者已经解锁的互斥锁解锁</p>

<p>4 不要在多个函数之前直接传递互斥锁</p>

<p>死锁时抛出的panic是属于致使错误，都是无法被恢复的，调用recover函数对它们起不了任何作用。</p>

<p>互斥锁是开箱即用的。sysnc.Mutex类型 是一个结构体类型，属于值类型中的一种，把它传给一个函数、将它从函数中返回，把它赋给其他变量。让它进入 某个通道都会导致它的副本的产生。
它们是独立的，都是不同的互斥锁。</p>

<p><strong>读写锁与互斥锁有哪 异同？</strong></p>

<p>sync.RWMute类型的值代表。 都是开箱即用。 它是把对共享资源的“读操作”和“写操作”区别对待。</p>

<p>比互斥锁有列加细腻的访问控制。</p>

<p>一个读写锁中实际上包含了两个锁，即：读锁和写锁。sync.RWMutex类型中的Lock方法和Unlock方法分别用于对写锁进行锁定和解锁，而它的RLock方法和RUnlock方法则分别用于对读锁进行锁定和解锁。</p>

<p><strong>另外，对于同一个读写锁来说有如下规则：</strong></p>

<p>1 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的 goroutine。</p>

<p>2 在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的 goroutine</p>

<p>3 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goroutine。</p>

<p>4 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的goroutine。</p>

<p>换一个角度来说，对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行。</p>

<p>go 语言代码  实例：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
    </span><span class="s">"bytes"</span><span class="x">
    </span><span class="s">"errors"</span><span class="x">
    </span><span class="s">"fmt"</span><span class="x">
    </span><span class="s">"io"</span><span class="x">
    </span><span class="s">"log"</span><span class="x">
    </span><span class="s">"sync"</span><span class="x">
    </span><span class="s">"time"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="c">// singleHandler 代表单次处理函数的类型。</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">singleHandler</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x">

</span><span class="c">// handlerConfig 代表处理流程配置的类型。</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">handlerConfig</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">handler</span><span class="x">   </span><span class="n">singleHandler</span><span class="x"> </span><span class="c">// 单次处理函数。</span><span class="x">
    </span><span class="n">goNum</span><span class="x">     </span><span class="kt">int</span><span class="x">           </span><span class="c">// 需要启用的goroutine的数量。</span><span class="x">
    </span><span class="n">number</span><span class="x">    </span><span class="kt">int</span><span class="x">           </span><span class="c">// 单个goroutine中的处理次数。</span><span class="x">
    </span><span class="n">interval</span><span class="x">  </span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="x"> </span><span class="c">// 单个goroutine中的处理间隔时间。</span><span class="x">
    </span><span class="n">counter</span><span class="x">   </span><span class="kt">int</span><span class="x">           </span><span class="c">// 数据量计数器，以字节为单位。</span><span class="x">
    </span><span class="n">counterMu</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="x">    </span><span class="c">// 数据量计数器专用的互斥锁。</span><span class="x">

</span><span class="p">}</span><span class="x">

</span><span class="c">// count 会增加计数器的值，并会返回增加后的计数。</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">hc</span><span class="x"> </span><span class="o">*</span><span class="n">handlerConfig</span><span class="p">)</span><span class="x"> </span><span class="n">count</span><span class="p">(</span><span class="n">increment</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">hc</span><span class="o">.</span><span class="n">counterMu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">hc</span><span class="o">.</span><span class="n">counterMu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
    </span><span class="n">hc</span><span class="o">.</span><span class="n">counter</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="n">increment</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">hc</span><span class="o">.</span><span class="n">counter</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// mu 代表以下流程要使用的互斥锁。</span><span class="x">
    </span><span class="c">// 在下面的函数中直接使用即可，不要传递。</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">mu</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="x">

    </span><span class="c">// genWriter 代表的是用于生成写入函数的函数。</span><span class="x">
    </span><span class="n">genWriter</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">writer</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">Writer</span><span class="p">)</span><span class="x"> </span><span class="n">singleHandler</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="c">// 准备数据。</span><span class="x">
            </span><span class="n">data</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span><span class="x">
                </span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">StampNano</span><span class="p">))</span><span class="x">
            </span><span class="c">// 写入数据。</span><span class="x">
            </span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
            </span><span class="n">n</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">writer</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="x">
            </span><span class="k">return</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// genReader 代表的是用于生成读取函数的函数。</span><span class="x">
    </span><span class="n">genReader</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">reader</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span><span class="x"> </span><span class="n">singleHandler</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">buffer</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reader</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span><span class="x">
            </span><span class="k">if</span><span class="x"> </span><span class="o">!</span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"unsupported reader"</span><span class="p">)</span><span class="x">
                </span><span class="k">return</span><span class="x">
            </span><span class="p">}</span><span class="x">
            </span><span class="c">// 读取数据。</span><span class="x">
            </span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
            </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">buffer</span><span class="o">.</span><span class="n">ReadString</span><span class="p">(</span><span class="sc">'\t'</span><span class="p">)</span><span class="x">
            </span><span class="n">n</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="x">
            </span><span class="k">return</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// buffer 代表缓冲区。</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">buffer</span><span class="x"> </span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="x">

    </span><span class="c">// 数据写入配置。</span><span class="x">
    </span><span class="n">writingConfig</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">handlerConfig</span><span class="p">{</span><span class="x">
        </span><span class="n">handler</span><span class="o">:</span><span class="x">  </span><span class="n">genWriter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">),</span><span class="x">
        </span><span class="n">goNum</span><span class="o">:</span><span class="x">    </span><span class="m">5</span><span class="p">,</span><span class="x">
        </span><span class="n">number</span><span class="o">:</span><span class="x">   </span><span class="m">4</span><span class="p">,</span><span class="x">
        </span><span class="n">interval</span><span class="o">:</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="m">100</span><span class="p">,</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="c">// 数据读取配置。</span><span class="x">
    </span><span class="n">readingConfig</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">handlerConfig</span><span class="p">{</span><span class="x">
        </span><span class="n">handler</span><span class="o">:</span><span class="x">  </span><span class="n">genReader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">),</span><span class="x">
        </span><span class="n">goNum</span><span class="o">:</span><span class="x">    </span><span class="m">10</span><span class="p">,</span><span class="x">
        </span><span class="n">number</span><span class="o">:</span><span class="x">   </span><span class="m">2</span><span class="p">,</span><span class="x">
        </span><span class="n">interval</span><span class="o">:</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="m">100</span><span class="p">,</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// sign 代表信号的通道。</span><span class="x">
    </span><span class="n">sign</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="k">struct</span><span class="p">{},</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="o">+</span><span class="n">readingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="p">)</span><span class="x">

    </span><span class="c">// 启用多个goroutine对缓冲区进行多次数据写入。</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">sign</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="k">struct</span><span class="p">{}{}</span><span class="x">
            </span><span class="p">}()</span><span class="x">
            </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">number</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">writingConfig</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span><span class="x">
                </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">handler</span><span class="p">()</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"writer [%d-%d]: error: %s"</span><span class="p">,</span><span class="x">
                        </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x">
                    </span><span class="k">continue</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="n">total</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="x">
                </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"writer [%d-%d]: %s (total: %d)"</span><span class="p">,</span><span class="x">
                    </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">total</span><span class="p">)</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}(</span><span class="n">i</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// 启用多个goroutine对缓冲区进行多次数据读取。</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">sign</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="k">struct</span><span class="p">{}{}</span><span class="x">
            </span><span class="p">}()</span><span class="x">
            </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">number</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">readingConfig</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span><span class="x">
                </span><span class="k">var</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="x">
                </span><span class="k">var</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="x">
                </span><span class="k">var</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="x">
                </span><span class="k">for</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">handler</span><span class="p">()</span><span class="x">
                    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="o">||</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">EOF</span><span class="x"> </span><span class="p">{</span><span class="x">
                        </span><span class="k">break</span><span class="x">
                    </span><span class="p">}</span><span class="x">
                    </span><span class="c">// 如果读比写快（读时会发生EOF错误），那就等一会儿再读。</span><span class="x">
                    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">readingConfig</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"reader [%d-%d]: error: %s"</span><span class="p">,</span><span class="x">
                        </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x">
                    </span><span class="k">continue</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="n">total</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="x">
                </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"reader [%d-%d]: %s (total: %d)"</span><span class="p">,</span><span class="x">
                    </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">total</span><span class="p">)</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}(</span><span class="n">i</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// signNumber 代表需要接收的信号的数量。</span><span class="x">
    </span><span class="n">signNumber</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="x">
    </span><span class="c">// 等待上面启用的所有goroutine的运行全部结束。</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">signNumber</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="o">&lt;-</span><span class="n">sign</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 原子操作</title>
      <link href="http://localhost:4000/timegeekbang-go-sync-atomic/"/>
      <pubDate>2019-03-26T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-sync-atomic</guid>
      <content:encoded><![CDATA[<p>在众多的同步工具中，真正能够保证原子性执行的只有原子操作（atomic operation）。原子操作在进行的过程中是不允许中断的。在底层，这会由 CPU 提供芯片级别的支持。</p>

<p><strong>sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？</strong></p>

<p>sync/atomic包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。</p>

<p><strong>第一个衍生问题 ：</strong>我们都知道，传入这些原子操作函数的第一个参数值对应的都应该是那个被操作的值。比如，atomic.AddInt32函数的第一个参数，对应的一定是那个要被增大的整数。可是，这个参数的类型为什么不是int32而是*int32呢？</p>

<p>回答是：因为原子操作函数需要的是被操作值的指针，而不是这个值本身；被传入函数的参数值都会被复制，像这种基本类型的值一旦被.传入函数，就已经与函数外的那个值毫无关系了。</p>

<p>所以，传入值本身没有任何意义。unsafe.Pointer类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向的那个值，所以需要的仍然是指向这个指针值的指针。</p>

<p><strong>第二个衍生问题：</strong> 用于原子加法操作的函数可以做原子减法吗？比如，atomic.AddInt32函数可以用于减小那个被操作的整数值吗？</p>

<p>回答是：当然是可以的。atomic.AddInt32函数的第二个参数代表差量，它的类型是int32，是有符号的。如果我们想做原子减法，那么把这个差量设置为负整数就可以了。</p>

<p>对于atomic.AddUint64函数做原子减法，就不能这么直接了，因为它们的第二个参数的类型分别是uint32和uint64，都是无符号的。所以要做转换 uint32(int32(-3))。如果不这么做的话，可报错。还有一种更加考虑直接的方式可以传入^uint32(-N-1)</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">atomic</span><span class="o">.</span><span class="n">AddUint32</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="kt">uint32</span><span class="p">(</span><span class="kt">int32</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span><span class="x">
</span><span class="c">//或</span><span class="x">
</span><span class="n">atomic</span><span class="o">.</span><span class="n">AddUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="o">^</span><span class="kt">uint32</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

<p><strong>第三个衍生问题：</strong> 比较并交换操作与交换操作相比有什么不同？优势在哪里？</p>

<p>回答是：比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行值的交换。
所谓的交换指的是，把新值赋给变量，并返回变量的旧值。</p>

<p><strong>第四个衍生问题：</strong> 假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，，还有必要使用原子操作吗？</p>

<p>回答是：很有必要。如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。</p>

<p>** 问题：怎样用好sync/atomic.Value?**</p>

<p>atomic.Value类型是开箱即用的，我们声明一个该类型的变量（以下简称原子变量）之后就可以直接使用了。这个类型使用起来很简单，它只有两个指针方法：Store和Load。不过，虽然简单，但还是有一些值得注意的地方的。</p>

<p>1 一旦被真正的使用，就不应该被复制，atomic.Value类型属于结构体类型， 而结构体类型属于值类型。复制时会产生个一完全分离的新值。</p>

<p>2 不能用原子偷走一存储nil</p>

<p>3 向原子值存储的第一个值，决定了它今后能且只能在座哪一个类型的值。即使使用接口类型，然后再存储这个接口的某个实现类型的值，还是不可以的。</p>

<p><strong>使用建议：</strong></p>

<p>1 不要把内部使用的原子值暴露给外界</p>

<p>2 如果不和地不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数让外界间接地信息使用它。注意，这种情况下不要把原子值传递外界，不论是传递原子值本身还是它的指针值。</p>

<p>3 如果通过某个函数可以向内部民的原子值 存储的话，那么就应该在这个函数中先判断被存储值类型的合法性。</p>

<p>4 最好把原子值封装到一个数据类型中，比如结构体类型。</p>

<p>尽量不要向原子值中存储引用类型的值，容易造成安全漏洞。</p>

<p>扩展阅读：https://www.jianshu.com/p/228c119a7d0e</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 程序性能分析基本</title>
      <link href="http://localhost:4000/timegeekbang-go-pprof/"/>
      <pubDate>2019-03-25T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-pprof</guid>
      <content:encoded><![CDATA[<p>Go 语言为程序开发者们提供了丰富的性能分析 API和标准工具。这些主要存在于：</p>

<blockquote>
  <p>1 runtime/pprof</p>

  <p>2 net/http/pprof</p>

  <p>3 runtime/trace</p>
</blockquote>

<p>在 Go 语言中，用于分析程序性能的概要文件有三种，分别是CPU 概要文件（CPU Profile）、内存概要文件（Mem Profile）和阻塞概要文件（Block Profile）。</p>

<p>对于 CPU 概要文件来说，其中的每一段独立的概要信息都记录着，在进行某一次采样的那个时刻，CPU 上正在执行的Go 代码。</p>

<p>而对于内存概要文件，其中的每一段概要信息都记载着，在某个采样时刻，正在执行的 Go 代码以及堆内存的使用情况，这里包含已分配和已释放的字节数量和对象数量。至于阻塞概要文件，其中的每一段概要信息，都代表着 Go 程序中的一个 goroutine 阻塞事件。</p>

<p>这时就可以显现出go tool pprof这个工具的作用了。我们可以通过它进入一个基于命令行的交互式界面，并对指定的概要文件进行查阅。概要文件是protoclo buffer 方式存储的。</p>

<p><strong>怎样设定内存概要信息的采样频率？</strong></p>

<p>只要为<code class="highlighter-rouge">runtime.MemProfileRate</code>变量赋值即可。</p>

<p>这个变量的含义是，平均每分配多少个字节，就对堆内存的使用情况进行一次采样。如果把该变量的值设为0，那么，Go 语言运行时系统就会完全停止对内存概要信息的采样。该变量的缺省值是512 KB，也就是512千字节。</p>

<p>越早设置越好，在main 开始时就设置。之后，需要调用<code class="highlighter-rouge">runtime/pprof</code>包中的<code class="highlighter-rouge">WriteHeapProfile</code>函数。该函数会把收集好的内存概要信息，写到我们指定的写入器中。</p>

<p>注意，我们通过<code class="highlighter-rouge">WriteHeapProfile</code>函数得到的内存概要信息并不是实时的，它是一个快照，是在最近一次的内存垃圾收集工作完成时产生的。如果你想要实时的信息，那么可以调用<code class="highlighter-rouge">runtime.ReadMemStats</code>函数。不过要特别注意，该函数会引起 Go 语言调度器的短暂停顿。</p>

<p><strong>怎样获取到阻塞概要信息？</strong></p>

<p>我们调用runtime包中的<code class="highlighter-rouge">SetBlockProfileRate</code>函数，即可对阻塞概要信息的采样频率进行设定。该函数有一个名叫rate的参数，它是int类型的。</p>

<p>这个参数的含义是，只要发现一个阻塞事件的持续时间达到了多少个纳秒，就可以对其进行采样。如果这个参数的值小于或等于0，那么就意味着 Go 语言运行时系统将会完全停止对阻塞概要信息的采样。</p>

<p>还有一个名叫<code class="highlighter-rouge">blockprofilerate</code>的包级私有变量，它是uint64类型的。这个变量的含义是，只要发现一个阻塞事事件的持续时间跨越了多少个 CPU 时钟周期，就可以对其进行采样。</p>

<p>另一方面，当我们需要获取阻塞概要信息的时候，需要先调用runtime/pprof包中的Lookup函数并传入参数值”block”，从而得到一个*runtime/pprof.Profile类型的值（以下简称Profile值）。在这之后，我们还需要调用这个Profile值的WriteTo方法，以驱使它把概要信息写进我们指定的写入器中。</p>

<p><strong>runtime/pprof.Lookup函数的调用方式是什么？</strong></p>

<p><code class="highlighter-rouge">runtime/pprof.Lookup</code>函数（以下简称Lookup函数）的功能是，提供与给定的名称相对应的概要信息。这个概要信息会由一个Profile值代表。如果该函数返回了一个nil，那么就说明不存在与给定名称对应的概要信息。</p>

<p><code class="highlighter-rouge">runtime/pprof</code>包已经为我们预先定义了 6 个概要名称。它们对应的概要信息收集方法和输出方法也都已经准备好了。我们直接拿来使用就可以了。</p>

<p>它们是：<code class="highlighter-rouge">goroutine、heap、allocs、threadcreate、block和mutex</code>。</p>

<p><strong>问题 4：如何为基于 HTTP 协议的网络服务添加性能分析接口？</strong></p>

<p>这个问题说起来还是很简单的。这是因为我们在一般情况下只要在程序中导入net/http/pprof代码包就可以了，就像这样：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="s">"net/http/pprof"</span><span class="x">
</span></code></pre></div></div>
<p>然后，启动网络服务并开始监听，比如：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">"localhost:8082"</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 sync.WaitGroup和sync.Once</title>
      <link href="http://localhost:4000/timegeekbang-go-synWaitGroup/"/>
      <pubDate>2019-03-25T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-synWaitGroup</guid>
      <content:encoded><![CDATA[<p>sync.WaitGroup类型（以下简称WaitGroup类型）是开箱即用的，也是并发安全的。同时，它一旦被真正使用就不能被复制了。</p>

<p>WaitGroup类型拥有三个指针方法：Add、Done和Wait。你可以想象该类型中有一个计数器，它的默认值是0。我们可以通过调用该类型值的Add方法来增加，或者减少这个计数器的值。</p>

<p>一般情况下，我会用这个方法来记录需要等待的 goroutine 的数量。相对应的，这个类型的Done方法，用于对其所属值中计数器的值进行减一操作。我们可以在需要等待的 goroutine 中，通过defer语句调用它。</p>

<p>而此类型的Wait方法的功能是，阻塞当前的 goroutine，直到其所属值中的计数器归零。如果在该方法被调用的时候，那个计数器的值就是0，那么它将不会做任何事情。</p>

<p>sync.WaitGroup类型值中计数器的值可以小于0吗？</p>

<p>这里的典型回答是：不可以。</p>

<p>另外，你可能已经知道，WaitGroup值是可以被复用的，但需要保证其计数周期的完整性。这里的计数周期指的是这样一个过程：该值中的计数器值由0变为了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了0。</p>

<p>也就是说，只要计数器的值始于0又归为0，就可以被视为一个计数周期。在一个此类值的生命周期中，它可以经历任意多个计数周期。但是，只有在它走完当前的计数周期之后，才能够开始下一个计数周期。</p>

<p><img src="/assets/timegeekbang/go-sync.png" alt="" /></p>

<p>不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行。换句话说，要杜绝对同一个WaitGroup值的两种操作的并发执行。</p>

<p>问题：sync.Once类型值的Do方法是怎么保证只执行参数函数一次的？
与sync.WaitGroup类型一样，sync.Once类型（以下简称Once类型）也属于结构体类型，同样也是开箱即用和并发安全的。由于这个类型中包含了一个sync.Mutex类型的字段，所以，复制该类型的值也会导致功能的失效。</p>

<p>扩展：https://www.cnblogs.com/linyihai/p/10285437.html</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>devlog-2018-11</title>
      <link href="http://localhost:4000/devlog201811/"/>
      <pubDate>2018-11-01T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/devlog201811</guid>
      <content:encoded><![CDATA[<p>11月份，刚搬完家。10月做的事不多。这个月加油！</p>

<h2 id="2018-11-01">2018-11-01</h2>

<p>看<a href="https://www.amazon.cn/dp/B009WMC3QQ/ref=sr_1_2?ie=UTF8&amp;qid=1540548648&amp;sr=8-2&amp;keywords=git">《Git权威指南》</a></p>

<p>看看Redmine和git的结合。是不是以后项目管理用到呢？</p>

<h2 id="2018-11-07">2018-11-07</h2>

<p>搬家，忙工作上事。之死期间大致看了<a href="https://www.amazon.cn/dp/B009WMC3QQ/ref=sr_1_2?ie=UTF8&amp;qid=1540548648&amp;sr=8-2&amp;keywords=git">《Git权威指南》</a>  想必应该够工作上用了吧。</p>

<p>返回来继续看skynet吧。</p>

<h2 id="2018-11-08">2018-11-08</h2>

<p>为什么skynet 中的一些函数正常情况下也返回-1。这和c编码习惯相悖啊。风云是出什么考虑呢？</p>

<h2 id="2018-11-09">2018-11-09</h2>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SIZEOF_TCPBUFFER (offsetof(struct write_buffer, udp_address[0]))
</span></code></pre></div></div>
<p>offsetof 该宏用于求结构体中一个成员在该结构体中的偏移量。</p>

<p>那么 offsetof和sizeof的区别在哪里呢？</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define THREAD_MAIN 1
</span><span class="kt">uint32_t</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="o">-</span><span class="n">THREAD_MAIN</span><span class="p">);</span>
</code></pre></div></div>

<p>在计算机中负数是用补码表示的,即反码加1 正数直接用原码表示</p>

<p>如： （这里用10位表示）</p>

<p>因为-1是负数就用补码表示为</p>

<p>00000000 00000001 的反码 11111111 11111110+1 即 11111111 11111111 转换为十进制数为</p>

<h2 id="2018-11-12">2018-11-12</h2>

<p>感觉自己有点害怕锁。看源码时，看到锁都会小心翼翼的。也会怀疑它会不会导致性能问题。</p>

<p>开始使用golang语言了。刚开始会写的慢一些，没关系，多用用，就可以了。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>devlog-2018-10</title>
      <link href="http://localhost:4000/devlog201810/"/>
      <pubDate>2018-10-12T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/devlog201810</guid>
      <content:encoded><![CDATA[<p>10月份，国庆回老家。感觉，回家比加班累。但是吃的，真的比较外面好很多。</p>

<h2 id="2018-10-09">2018-10-09</h2>

<p>国庆放假回老家。放假回来，发现公司的要svn挂了，他们搞了很久，没搞定。去支援一下。把网络搞好。csvn搞起来了。发现数据没了? what? 好像有盘没加载进来。一搞一天就没了。</p>

<h2 id="2018-10-10">2018-10-10</h2>

<p>学习skynet游戏框架。</p>

<h2 id="2018-10-11">2018-10-11</h2>

<p>学习skynet游戏框架，对于lua的代码不是很熟练。搞了一下mac系统。升级时失败了，开不了机。很麻烦。</p>

<h2 id="2018-10-12">2018-10-12</h2>

<p>学习skynet游戏框架。报了一个错误，不知道为什么 <code class="highlighter-rouge">error : ./lualib/skynet.lua:525: ./lualib/skynet.lua:155: ./../script/gateservice.lua:133: attempt to call a nil value (field 'open')
stack traceback:</code></p>

<p>这个错误是说 没有open这个函数。 后面发现我看错工程了。呵呵~</p>

<p><a href="http://xg.qq.com/docs/">腾讯信鸽推送</a></p>

<h2 id="2018-10-13">2018-10-13</h2>

<p>skynet 对lua的要求是在5.3版本以上的。</p>

<p>今天去苹果店修电脑，排了一个小时的队，然后告诉我是这队是帮回答我问题的，不是帮我修改的。 一脸蒙逼啊。让我明天早上10点半之前过去，登记排队修，或者 预约了一下，在四天后. 呵呵。</p>

<h2 id="2018-10-14">2018-10-14</h2>

<p>一早就是苹果店，又排了一个小时队的，又重复了昨天流程。他们说今天的话要排到晚上8点钟才行。好吧，我先回了。晚上有没有时间真的不一定了。</p>

<p>朱哥留下的游戏服务端代码 是skynet写，我也不知道它是个成品，还是个不成品，反正我是跑了好几天都没能跑成功。 直到昨天我才发现我看错目录，那个应该旧的源码，没有删除，可能他是出于备份的目的。但那代码是跑不起来了。今天算是跑起来了。把Skynet更到了最新，发现少许问题，更了一下配置。OK，服务可以启来了。</p>

<p>我的想法是通过这一套代码。熟悉skynet的用法，然后再把skynet源码看完。</p>

<h2 id="2018-10-15">2018-10-15</h2>

<p>做go开发，发现很多依赖库被墙在国外了。搞不懂为什么要对技术做封锁。在网看找到这个 <a href="https://gopm.io/">https://gopm.io/</a></p>

<h2 id="2018-10-24">2018-10-24</h2>

<p>抓紧时间把skynet的源码看完。 – 今天忙了一天，需求不断，bugg不断。</p>

<h2 id="2018-10-25">2018-10-25</h2>
<p>lua gc 要看一下，其实应该是看一下lua源码。 今天看几个skynet源码的文件。 算是一个开端吧。</p>

<p><a href="https://blog.csdn.net/vermilliontear/article/details/50895658">快速掌握Lua 5.3 —— Lua与C之间的交互概览</a></p>

<p>为什么 skynet 函数为什么没对传入的指针做判断呢？</p>

<h2 id="2018-10-25-1">2018-10-25</h2>
<p>昨晚加班很晚 3点多才回去。 今天比较晚上班，看一些skynet源码。 在提交git时，出了问题。代码不见了。靠， 不知道发生了什么事， 对git了解不。</p>

<p>立马买一本， <a href="https://www.amazon.cn/dp/B009WMC3QQ/ref=sr_1_2?ie=UTF8&amp;qid=1540548648&amp;sr=8-2&amp;keywords=git">《Git权威指南》</a></p>

<p>无法接受这个事故。</p>

<h2 id="2018-10-25-2">2018-10-25</h2>
<p>看<a href="https://www.amazon.cn/dp/B009WMC3QQ/ref=sr_1_2?ie=UTF8&amp;qid=1540548648&amp;sr=8-2&amp;keywords=git">《Git权威指南》</a></p>

<p>搬家了</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>源码阅读中一个特殊注释说明</title>
      <link href="http://localhost:4000/sourcecode-comment/"/>
      <pubDate>2018-09-17T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/sourcecode-comment</guid>
      <content:encoded><![CDATA[<p><strong>TODO: + 说明：</strong></p>

<p>如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</p>

<p><strong>FIXME: + 说明：</strong>
如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p>

<p><strong>XXX: + 说明：</strong>
如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>devlog-2018-09</title>
      <link href="http://localhost:4000/devlog201809/"/>
      <pubDate>2018-09-13T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/devlog201809</guid>
      <content:encoded><![CDATA[<p>9月份，开发，学习日志，适量的公开。</p>

<h2 id="2018-09-13">2018-09-13</h2>

<p>1.muduo 中的 epoll 能否支持超时回调呢？其实就是问epoll 能否支持超时回调？<a href="https://github.com/chenshuo/muduo/issues/337">muduo能否支持epoll超时回调？？？</a></p>

<p>2.epoll 超时的话就应该是在 outtime时间里没有等到事件就返回了。这时返回值应该0。这么理解有问题吗？</p>

<p>3.今天重新看muduo的一些源码，加强对muduo的一些解理。还是有一些收获的。对于EventLoop Poller Channel 有了一些加强。
  也慢慢的开始注意了一些细节的事物了。如：一些 <code class="highlighter-rouge">(void) t</code> 的运用。只是想让这个变量被使用。从而不会变量未被使用的错误。</p>

<p>在知乎上有一个关于这个讨论， 陈硕回答下的下评论，有意思。<a href="https://www.zhihu.com/question/24311085">muduo库的很多返回值为空的函数的最后一行都有类似 (void) n的一句， 为什么要这样做？</a></p>

<p>4.后面写代码时要多用assert。 把gcc的编译严格等级设置为任何警告当成错误，而有的变量实际上是在debug版本中assert时有用的，release时这个变量就没用了， 此时编译器就会提醒有个变量没用的警告。</p>

<p>5.rvo优化  <a href="https://www.zhihu.com/question/27000013">什么时候应当依靠返回值优化（RVO）？</a>
<a href="https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement?lq=1">C++11 rvalues and move semantics confusion (return statement)</a>
 2018-09-14
——</p>

<p>0.继续看muduo 的源码</p>

<p>1.要加强对Boost智能指针的理解。 <a href="https://blog.csdn.net/yockie/article/details/8840205">Boost智能指针——scoped_ptr、shared_ptr、weak_ptr、intrusive_ptr</a></p>

<p>2.eventfd 事件 <a href="https://blog.csdn.net/majianfei1023/article/details/51199702">inux网络编程–eventfd</a></p>

<h2 id="2018-09-17">2018-09-17</h2>

<p>1.TCP中 shutdown 和close的区别。</p>

<p>2.看完Buffer后，要再回看一次TcpConnection。</p>

<p>3.可以看看这个blog<a href="https://dirtysalt.github.io/html/index.html">dirtysalt’s site / 章炎的个人站点</a></p>

<p>4.<a href="https://blog.csdn.net/u012432778/article/details/47323805">分散/聚集 I/O(scatter-gather I/O)</a></p>

<p>5.二是Buffer::readFd()只调用一次read(2)，而没有反复调用read(2) 直到其返回EAGAIN。首先，这么做是正确的，因为muduo采用level trigger，这么做不会丢失 数据或消息。</p>

<p>6.libevent 默认的epoll模式是什么？</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// epoll.c </span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">eventop</span> <span class="n">epollops_changelist</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">"epoll (with changelist)"</span><span class="p">,</span>
	<span class="n">epoll_init</span><span class="p">,</span>
	<span class="n">event_changelist_add</span><span class="p">,</span>
	<span class="n">event_changelist_del</span><span class="p">,</span>
	<span class="n">epoll_dispatch</span><span class="p">,</span>
	<span class="n">epoll_dealloc</span><span class="p">,</span>
	<span class="mi">1</span><span class="p">,</span> <span class="cm">/* need reinit */</span>
	<span class="n">EV_FEATURE_ET</span><span class="o">|</span><span class="n">EV_FEATURE_O1</span><span class="p">,</span>
	<span class="n">EVENT_CHANGELIST_FDINFO_SIZE</span>
<span class="p">};</span>

<span class="c1">// EV_FEATURE_ET 可以看是Edge_triggered(边缘触发)</span>
</code></pre></div></div>
<p>7.水平触发，写事件怎么理解？ 写入数据时要手动去触发。</p>

<p>8.muduo TcpConnection 类中 为什么有地方是用this 有地方是用shared_from_this()？</p>

<p>9.<a href="https://www.zhihu.com/question/19732473/answer/26091478">怎样理解阻塞非阻塞与同步异步的区别？</a></p>

<p>10.<a href="https://aceld.gitbooks.io/libevent/content/">libevent深入浅出</a></p>

<h2 id="2018-09-18">2018-09-18</h2>

<blockquote>
  <p>注意sendInLoop()和handleWrite()都只调用了一次write(2)而不会反复调用直至它返回EAGAIN，原因是如果第一次write(2)没有能够发送完全部数据的话，第二次调用write(2)几乎肯定会返回EAGAIN。</p>
</blockquote>

<p>这muduo 8.7关于handleWrite()的一段话？为什么第二次调用 Write几乎肯定会返回EAGAIN呢？ 因为第一次就把fd的缓冲区写满了，所以第二次写且还第一次数据还没以出去时，就会出现EAGAIN。</p>

<p>在创建链接时，对于有新的客户端链接过来时，会在Acceptor的读事件回调中处理，链接已经创建后，对于连接过来的数据在TcpConnection中的读事件回调中处理。</p>

<p>关于muduo 的时间定时器要重新看一下。</p>

<p>muduo 网络库核心的看完第二遍了，明天整理一下笔记。</p>

<h2 id="2018-09-19">2018-09-19</h2>

<p>1.shutdown和forceClose区别 ?</p>

<p>shutdown()是关闭了socket中的写。<code class="highlighter-rouge">::shutdown(sockfd, SHUT_WR)</code></p>

<p>forceClose()呢？ TcpConnection对象是通过share_ptr来管理的。要销毁它时，就是把所有对它的引用去掉就可以了。</p>

<h2 id="2018-09-20">2018-09-20</h2>

<p>1.muduo 的大概是算是看完了。 也上网看了一些网友对muduo的一些评价。</p>

<p>2.有空对应一下boost版本和c++11版本的差异。</p>

<p>3.把stl的封装整理一下。然后把googletest 试一下。</p>

<p>4.然后准备看一下数据库方面的知识。《大规模分布式存储系统 原理理解与实战》</p>

<p>5.重新看一下libevent的原码。</p>

<h2 id="2018-09-20-1">2018-09-20</h2>

<p>1.现在的项目中，对stl做了封装。其实stl的封装没有必要性。而这个模块中重点是对double_map.又key的map的运用还是很广的。</p>

<p>2.用google test 对stl模块的单元测试。stl还是很简单的。也正好把google test 用起来。</p>

<h2 id="2018-09-22">2018-09-22</h2>

<p>1.在网上看到一个io的游戏源码，服务端是c++的。<a href="https://github.com/WaeCo/agar.io-clone">agar.io-clone</a></p>

<p>2.大致瞄了一眼，c++的代码风格还算很好。c++11, boost,websocket的运用。可以看一下，以后做小游戏可能用的到。</p>

<h2 id="2018-09-23">2018-09-23</h2>

<p>1.中秋节放假中。</p>

<h2 id="2018-09-25">2018-09-25</h2>

<p>1.把google test 放到stl里了。写了一个makefile。花了很长时间。就想方便一些，以后加入一些测试用例时，不用去改makefile文件。</p>

<p>2.还好，想起以前就整理过google test。就直接拿来用了。</p>

<h2 id="2018-09-26">2018-09-26</h2>

<ol>
  <li>GW游戏中用到关于内存的管理方式。就是使用内存池的方式来管理对象。可以把这个一模块整理出来。</li>
  <li>在内在池模块中看到了有用到nedmalloc的。一个线程缓存式的内存，用宏定义做了开关<a href="http://www.nedprod.com/programs/portable/nedmalloc/">nedmalloc</a>。
暂时不发散出来了。后有机会再回头看看nedmalloc。先把nedmalloc去掉简洁代码结构。</li>
  <li>不考虑线程安全，所以不要在里面加锁。</li>
  <li>GW游戏的登录验证是用php写的， 好像同事都没搞过php。写的很不好。今天就php模块加了一个日志模块，其实的暂时算了。对于php掌握很有限。</li>
  <li>整理出了内存池的代码了。很自觉加上了google test。当然没有全部测试。后面测试搞。</li>
  <li><a href="https://mp.weixin.qq.com/s/m2YiRyzNSzi9NpWr9ODrwg">《腾讯工程师破解入侵酒店 WiFi，被新加坡网安局逮捕》</a>。<a href="https://hk.saowen.com/a/6e3d908180fb701992fb60035e2a9fcdf8b1b52268516ae75882add040bd39d1">Exploit Singapore Hotels: ezxcess.antlabs.com</a>有意思。</li>
</ol>

<h2 id="2018-09-27">2018-09-27</h2>

<ol>
  <li>看一下<a href="https://github.com/WaeCo/agar.io-clone">agar.io-clone</a> <a href="https://github.com/WaeCo/agar.io-clone.git">git clone</a>。</li>
  <li>STL中，map 对应的数据结构是 红黑树。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 O(logN)。而 unordered_map 对应 哈希表，哈希表的特点就是查找效率高，时间复杂度为常数级别 O(1)， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 unordered_map 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 map 容器。</li>
  <li>看agar.io-clone的代码。发现自己的对于设计模式不在行。之前看过的模式都忘光。</li>
  <li>后面要整理一下github上 c++11这个源码。</li>
</ol>

<h2 id="2018-09-28">2018-09-28</h2>

<ol>
  <li>在agar.io-clone看到了它用一个数据结构叫四叉树。是用于管理散布在平面上的对象的。
    <ul>
      <li><a href="http://www.cnblogs.com/zhenbianshu/p/7061550.html">空间索引</a></li>
      <li><a href="https://blog.csdn.net/zhouxuguang236/article/details/12312099">四叉树空间索引原理及其实现</a></li>
      <li><a href="https://blog.codingnow.com/2006/10/quadtree.html">云风的bog.用四叉树管理散布在平面上的对象</a></li>
    </ul>
  </li>
</ol>

<h2 id="2018-09-29">2018-09-29</h2>
<ul>
  <li><a href="https://blog.csdn.net/yuanfengyun/article/details/54706333">电子书网站</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
