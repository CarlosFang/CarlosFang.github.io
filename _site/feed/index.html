<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2018-09-12T01:25:33+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>go的竞争检测</title>
      <link href="http://localhost:4000/go-check-race/"/>
      <pubDate>2018-03-02T04:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-check-race</guid>
      <content:encoded><![CDATA[<p><code class="highlighter-rouge">go run -race</code> 或者 <code class="highlighter-rouge">go build -race</code> 来进行竞争检测。</p>

<p>golang语言内部大概的实现就是同时开启多个goroutine执行同一个命令，并且纪录每个变量的状态。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="p">(</span><span class="x">
    </span><span class="s">"time"</span><span class="x">
    </span><span class="s">"fmt"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="x">
    </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(){</span><span class="x">
        </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">2</span><span class="x">
    </span><span class="p">}()</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">3</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"a is "</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="p">)</span><span class="x">

    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>这个程序可以看出变量a出现了竞争。</p>

<p>在windows下执行</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go run: <span class="nt">-race</span> and <span class="nt">-msan</span> are only supported on linux/amd64, freebsd/amd64, darwin
/amd64 and windows/amd64
</code></pre></div></div>

<p>在linux下执行</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="x"> </span><span class="n">is</span><span class="x">  </span><span class="m">3</span><span class="x">
</span><span class="o">==================</span><span class="x">
</span><span class="n">WARNING</span><span class="o">:</span><span class="x"> </span><span class="n">DATA</span><span class="x"> </span><span class="n">RACE</span><span class="x">
</span><span class="n">Write</span><span class="x"> </span><span class="n">at</span><span class="x"> </span><span class="m">0x00c4200140a8</span><span class="x"> </span><span class="n">by</span><span class="x"> </span><span class="n">goroutine</span><span class="x"> </span><span class="m">6</span><span class="o">:</span><span class="x">
  </span><span class="n">main</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">func1</span><span class="p">()</span><span class="x">
      </span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">race</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">11</span><span class="x"> </span><span class="o">+</span><span class="m">0x3b</span><span class="x">

</span><span class="n">Previous</span><span class="x"> </span><span class="n">write</span><span class="x"> </span><span class="n">at</span><span class="x"> </span><span class="m">0x00c4200140a8</span><span class="x"> </span><span class="n">by</span><span class="x"> </span><span class="n">main</span><span class="x"> </span><span class="n">goroutine</span><span class="o">:</span><span class="x">
  </span><span class="n">main</span><span class="o">.</span><span class="n">main</span><span class="p">()</span><span class="x">
      </span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">race</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">13</span><span class="x"> </span><span class="o">+</span><span class="m">0x8e</span><span class="x">

</span><span class="n">Goroutine</span><span class="x"> </span><span class="m">6</span><span class="x"> </span><span class="p">(</span><span class="n">running</span><span class="p">)</span><span class="x"> </span><span class="n">created</span><span class="x"> </span><span class="n">at</span><span class="o">:</span><span class="x">
  </span><span class="n">main</span><span class="o">.</span><span class="n">main</span><span class="p">()</span><span class="x">
      </span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">race</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">10</span><span class="x"> </span><span class="o">+</span><span class="m">0x7d</span><span class="x">
</span><span class="o">==================</span><span class="x">
</span><span class="n">Found</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="n">race</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x">
</span><span class="n">exit</span><span class="x"> </span><span class="n">status</span><span class="x"> </span><span class="m">66</span><span class="x">
</span></code></pre></div></div>
<p><strong>13行 出现变量竞争。</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go gdb 编译</title>
      <link href="http://localhost:4000/go-gdb/"/>
      <pubDate>2018-03-01T18:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-gdb</guid>
      <content:encoded><![CDATA[<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go build <span class="nt">-gcflags</span> <span class="s2">"-N -l"</span> demo.go
</code></pre></div></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>go关于defer的一道面试题</title>
      <link href="http://localhost:4000/go-defer-1/"/>
      <pubDate>2018-03-01T18:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-defer-1</guid>
      <content:encoded><![CDATA[<p>请写出输出结果</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">(){</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="x">
    </span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">2</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="m">0</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">calc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="x"> </span><span class="kt">int</span><span class="p">){</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="x">
</span><span class="p">}</span><span class="x">

</span></code></pre></div></div>

<p>结果是</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3
0 2 2
0 2 2
1 3 4
</code></pre></div></div>

<h4 id="考察两个知识点">考察两个知识点：</h4>

<p>1.defer是栈调用，后写的先执行</p>

<p>2.defer的函数调用语句会在父函数调用后执行，但是用到的参数会在当时就执行得出</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go vet检测代码错误</title>
      <link href="http://localhost:4000/go-build-ver/"/>
      <pubDate>2018-03-01T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-build-ver</guid>
      <content:encoded><![CDATA[<p>这个种方式很不错，当代码量很大时，可以用这种方式去做检测。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="x"> </span><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">Func</span><span class="p">(</span><span class="n">num</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"call Func</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"num = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">num</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"num = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">,</span><span class="x"> </span><span class="m">3</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Func</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>使用vet工具检测代码：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go build demo.go
<span class="nv">$ </span>go tool vet demo.go
demo.go:7: arg num <span class="k">for </span><span class="nb">printf </span>verb %s of wrong <span class="nb">type</span>: int
demo.go:8: wrong number of args <span class="k">for </span>format <span class="k">in </span>Printf call: 1 needed but 3 args
 
</code></pre></div></div>

<p>通过vet工具，可以检测到go代码中一些可疑的结构，虽然vet不能确保发现的问题都是真正的错误，但是它可以发现一些编译器无法捕获的错误。</p>

<p>例如示例中，这段代码能正常的编译通过，但是通过vet检测出2个问题，第一个问题是打印的格式与参数类型不匹配，第二个问题需要打印的参数和所给参数数量不一致。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go 编译时传递参数</title>
      <link href="http://localhost:4000/go-build-ldflags/"/>
      <pubDate>2018-03-01T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-build-ldflags</guid>
      <content:encoded><![CDATA[<p>很有意思，可能运用的场景不多。如果想调试某个模块时，可以在编译直接给他赋值。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">var</span><span class="x"> </span><span class="n">BuildDate</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"no build date"</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"build date: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="x"> </span><span class="n">BuildDate</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>传递参数步骤：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go build demo.go
<span class="nv">$ </span>./demo
build <span class="nb">date</span>: no build <span class="nb">date</span>
<span class="nv">$ DATE</span><span class="o">=</span><span class="sb">`</span><span class="nb">date</span> <span class="s1">'+%Y-%m-%d-%I:%M:%S'</span><span class="sb">`</span>
<span class="nv">$ </span>go build <span class="nt">-ldflags</span> <span class="s2">"-X main.BuildDate=</span><span class="nv">$DATE</span><span class="s2">"</span> demo.go
<span class="nv">$ </span>./demo
build <span class="nb">date</span>: 2018-05-03-03:15:35
</code></pre></div></div>
<p>通过-X选项，可以给go程序传递相关参数。例如示例中，借助-X选项，将编译日期BuildDate实时传递到程序中。另外，如版本信息之类也可以通过该方式实现。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go build 时的错误分析</title>
      <link href="http://localhost:4000/go-build-error/"/>
      <pubDate>2018-01-05T04:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/go-build-error</guid>
      <content:encoded><![CDATA[<p>go build 程序时，如果出现：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>warning: building out-of-date packages:

runtime/pprof

testing

regexp/syntax

regexp

installing these packages with <span class="s1">'go test -i'</span> will speed future tests.
</code></pre></div></div>

<p>那么就是说明下面的包已经有修改过了，但是没有重新install</p>

<p>如果有标准的包过期，使用go install -a -v std来进行更新</p>

<p>如果是自定义的包过期，重新调用go install</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>muduo笔记  第八章 muduo网络库设计与实现</title>
      <link href="http://localhost:4000/muduo-8-muduo-EventLoop/"/>
      <pubDate>2018-01-05T04:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-8-muduo-EventLoop</guid>
      <content:encoded><![CDATA[<p>runInLoop() 线程安全的理解</p>

<p><img src="/assets/muduo/8-muduo-EventLoop.png" alt="" /></p>

<p>在线程T1 muduo::EventLoop loop;， 并loop.loop();那么这个事件应该在线程T1上跑。但是线程T2做了一件事，就是loop::runInLoop(cb); 这个时候添加回调时和loop并不是同一个线程。会有问题。</p>

<p>所以,runInLoop()的做法是：先判断是不是同一个线程，是的话就直接被执行，不是的话就加到挂起队列中。</p>

<p>// 是否在当线线程，不在就加入队列。 因为可能是其他线程执行这个代码，</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isInLoopThread</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">cb</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">queueInLoop</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在queueInLoop中会唤醒T1线程。做法是：</p>

<p>T1和T2线程有一个channel,写入一个字符。触发T1的事件，T1在loop中会执行被挂起的函数队列。</p>

<p>addTimer 要做到线程安全，就是把它的回调加入到runInLoop，这样它可以触发它所在的线程去执行。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TimerId</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span><span class="o">&amp;</span> <span class="n">cb</span><span class="p">,</span>
                             <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span>
                             <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Timer</span><span class="o">*</span> <span class="n">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">TimerId</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="84-实现tcp-网络库">8.4 实现TCP 网络库</h4>

<p>这一节主要是讲 Acceptor class。</p>

<p>Acceptor class是用于封装accept接受新连接的。为什么在单独成为一个模块类呢？</p>

<p>1.Acceptor  的成员有socket channel 。其中socket 是用了RAII handle 。</p>

<p>2.Channel用于观察此socket上的readable事件，并回调Acceptor:: handleRead()，后者会调用accept(2)来接受新连接，并回调用户callback。</p>

<p>3.关于，如果系统的fd耗尽的问题。 在一个开始，就打一个空闲的fd。当系统耗尽时，会先关闭这个空闲的fd。要给新上来的客户端accept。最后，
断开客户端，把fd交还给空闲的占用。 这么做是为了解决在系统耗尽fd时，不会断开客户端上来的链接。</p>

<h4 id="85-tcpserver--接受新连接">8.5 TcpServer  接受新连接</h4>
<hr />
<p>主要是讲TcpServer class。 tcp服务是管理accept获得TcpConnection。
这是一个新连接的接受的过程：</p>

<p><img src="/assets/muduo/8-muduo-tcpserver-class.png" alt="" /></p>

<p>TcpServer 很简单，用户只 需要设置好callback，再调用start()。就OK了。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>muduo笔记 第七章 时间轮</title>
      <link href="http://localhost:4000/muduo-7-muduo-timing-wheel/"/>
      <pubDate>2018-01-05T04:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-7-muduo-timing-wheel</guid>
      <content:encoded><![CDATA[<p>用timing wheel 踢掉空闲连接。</p>

<h4 id="如果一个连接连续几秒内没有收到数据就把它断开为此有两种简单粗暴的做法">如果一个连接连续几秒内没有收到数据，就把它断开，为此有两种简单、粗暴的做法：</h4>

<p>1.每个连接保存”最后收到数据的时间lastReceiveTime”， 然后用一个定时器，每秒遍历一遍所有连接， 断开那些(now - connection. lastReceiveTime) &gt; 8s 的connection。 这种做法全局只有一个repeated timer， 不过每次timeout 都要检查全部连接，如果连接数目比较大（几千上万） 这一步可能会比较费时。 ·</p>

<p>2.每个连接设置一个one-shot timer， 超时定为8s， 在超时的时候就断开本连接。当然，每次收到数据要去更新timer。 这种做法需要很多个one-shot timer， 会频繁地更新timers。如果连接数目比较大， 可能对EventLoop 的 TimerQueue 造成 压力。</p>

<p>连接超时不需要精确定时，只要大致8秒超时断开就行，多一秒、少一秒关系不大。</p>

<p>处理连接超时可用一个简单的数据结构：8个桶组成的循环队列。</p>

<p>第1个桶放1秒之后将要超时的连接，第2个桶放2秒之后将要超时的连接。每个连接一收到数据就把自己放到第8个桶，然后在每秒的timer里把第一个桶里的连接断开，把这个空桶挪到队尾。</p>

<p>这样大致可以做到8秒没有数据就超时断开连接。</p>

<h4 id="时间轮的原理">时间轮的原理</h4>

<p>简单的时间轮的基本结构是一个循环队列，还有一个指向队尾的指针（tail）。这个指针每秒移动一格，就像钟表上的时针。</p>

<p>以下是某一时刻timing wheel 的状态（ 见图7-42的左图）， 格子里的数字是倒计时（ 与通常的 timing wheel 相反）， 表示这个格子（ 桶子） 中连接的 剩余寿命。1秒以后（见图 7-42的右图）， tail 指针移动一格， 原来四点钟方向的格子被清空，其中的连接已被断开。</p>

<p><img src="/assets/muduo/7-time-wheel1.png" alt="" /></p>

<p>连接超时时被踢掉的过程
假设在某个时刻，conn1到达， 把它放到当前格子中，它的剩余寿命是7秒（见图7-43的左图）。 此后conn1 上没有收到数据。 1秒之后（见图7-43的右图），tail指向下一个格子， conn 1的剩余寿命是6秒。</p>

<p><img src="/assets/muduo/7-time-wheel2.png" alt="" /></p>

<p>又 过了几 秒， tail指向conn1之前的那个格子， conn1即将被断开（见图7-44的左图）。下一秒（见图7-44的右图），tail重新指向conn1原来所在的格子，清空其中的数据，断开conn1连接。
<img src="/assets/muduo/7-time-wheel3.png" alt="" /></p>

<h4 id="连接刷新">连接刷新</h4>

<p>如果在断开conn1之前收到数据，就把它移到当前的格子里。conn1的剩余寿命是3秒（见图7-45的左图），此时 conn 1收到数据，它的寿命恢复为7秒（见图 7-45 的右图）。</p>

<p><img src="/assets/muduo/7-time-wheel4.png" alt="" /></p>

<p>时间继续前进，conn1寿命递减，不过它已经比第一种情况长寿了（见图7-46）。</p>

<p><img src="/assets/muduo/7-time-wheel5.png" alt="" /></p>

<h4 id="多个连接">多个连接</h4>

<p>timingwheel中的每个格子是个hashset，可以容纳不止一个连接。比如一开始，conn1到达。随后，conn2到达（见图7-47），这时候tail还没有移动，两个连接位于同一个格子中，具有相同的剩余寿命。（在图7-47中画成链表，代码中是哈希表。）</p>

<hr />

<p>代码的实现体现在主要在三个地方。</p>

<p>1）新的连接上来时。</p>

<p><img src="/assets/muduo/7-time-wheel6.png" alt="" /></p>

<p>entry 为 shared_ptr类型。连接时会把entery插入到循环队列中的set当中。</p>

<p>2）当有数的数据过来时。</p>

<p><img src="/assets/muduo/7-time-wheel7.png" alt="" /></p>

<p>也会把这个连接的entry加入到循环队列中的set当中。</p>

<p>3）定时器
每一秒钟会从循环队列中拿掉一个Set。entry的shared_ptr计数就会减1。</p>

<p><img src="/assets/muduo/7-time-wheel8.png" alt="" /></p>

<p>当entry的shared_ptr被减到0时，entry就会被释放。就会断开连接。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>muduo笔记 第七章 定时器</title>
      <link href="http://localhost:4000/muduo-7-muduo-timer/"/>
      <pubDate>2018-01-05T04:20:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-7-muduo-timer</guid>
      <content:encoded><![CDATA[<p>在一般的服务端程序设计 中， 与时间有关的常见任务有：</p>

<p>1、获取当前时间， 计算时间间隔。</p>

<p>2、时区转换与日期计算； 把纽约当地时间转换为上海当地时间； 2011-02-05 之后第100天是几月几号星期几；等等。</p>

<p>3、 定时操作， 比如在预定的时间执行任务， 或者在一段延时之后执行任务。</p>

<p>计时，只使用gettimeofday(2)来获取当前时间</p>

<p>定时，只使用timerfd_*系统函数来处理定时任务</p>

<p>1、 time(2) 的精度太低了， ftime(3)被废弃。 clock_gettime(2)精度最高，但是系统调用的开销比gettimeofday大。</p>

<p>2、gettimeofday 不是系统调用，而是在用户态实现的。 没有上下文切换和陷入内核的开销。</p>

<p>3、timerfd_create(2)把时间变成了一个文件描述符，该“文件”在定时器超时的那一该变得可读，这样就能很方便的融入select(2)/poll(2)框架中，用统一的方式 来处理IO事件和超时事件，这也正是Reactor模式的长处。</p>

<p>4、传统的Reactor利用select(2)/poll(2)/epoll(4)的timeout来实现定时功能，但poll(2)和epoll_wait(2)的定时精度只有毫秒，远低于timerfd_ settime(2)的定时精度。</p>

<h4 id="muoduo-的定时器接口有三个都在eventloop中">muoduo 的定时器接口有三个。都在EventLoop中。</h4>
<p>1.runAt 在 指定的时间调用TimerCallback；</p>

<p>2.runAfter 等一段时间调用TimerCallback；</p>

<p>3.runEvery 以固定的间隔反复调用TimerCallback；</p>

<p>cancel 取消timer。 回调函数在EventLoop 对象所属的线程发生，与onMessage()、 onConnection() 等网络事件函数在同一个线程。</p>

<h3 id="注">[注]</h3>
<p>1、现在所在游戏项目中所用的时间函数是clock_gettime 然后再转成毫秒。</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>muduo笔记 第七章 限制服务器的最大并发连接数</title>
      <link href="http://localhost:4000/muduo-7-muduo-max-connection/"/>
      <pubDate>2018-01-05T04:19:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/muduo-7-muduo-max-connection</guid>
      <content:encoded><![CDATA[<p>一方面， 我们不希望服务程序超载。</p>

<p>另一方面，更因为filedescriptor是 稀缺资源， 如果出现 filedescriptor耗尽，很棘手，跟”malloc() 失败/new抛出std::bad_alloc”差不多同样棘。</p>

<p>当accept(2) 返回EMFILE该如何应对？</p>

<p>这意味着本进程的文件描述符已经达到上限， 无法为新连接创建socket文件描述符。</p>

<p>但是，既然没有socket文件描述符来表示这个连接，我们就无法close(2) 它。</p>

<p>程序继续运行，回到L11再一次调用epoll_ wait。这时候epoll_wait会立刻返回，因为新连接还等待处理，listening fd还是可读的。这样程序 立刻就陷入了busy loop， CPU占用率接近100%。</p>

<p>这既影响同一event loop上的连接， 也影响同一机器上的其他服务。</p>

<h4 id="解决方法">解决方法</h4>

<p>准备一个空闲的文件描述符。 遇到这种情况，先关闭这个空闲文件， 获得一个文件描述符的名额；</p>

<p>再accept(2) 拿到新socket连接的描述符；随后立刻close(2) 它，这样就优雅地断开了客户端连接；</p>

<p>最后重新打开一个空闲文件， 把”坑”占住，以备再次出现这种情况时使用。</p>

<p>其实有另外一种比较简单的办法：</p>

<p>file descriptor是hard limit，我们可以自己设一个 稍低 一点 的 soft limit，</p>

<p>如果超过soft limit 就主动关闭新连接， 这样就可避免触及”file descriptor 耗尽” 这种边界条件。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EMFILE</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">idleFd_</span><span class="p">);</span>
      <span class="n">idleFd_</span> <span class="o">=</span> <span class="o">::</span><span class="n">accept</span><span class="p">(</span><span class="n">acceptSocket_</span><span class="p">.</span><span class="n">fd</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">idleFd_</span><span class="p">);</span>
      <span class="n">idleFd_</span> <span class="o">=</span> <span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="s">"/dev/null"</span><span class="p">,</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<h4 id="注">[注]</h4>
<p>1、可能我们在实践当中，中不太可能改动每个服务器的，特别当服务器越来越多时，根本不靠谱。所以在框架中解决这个问题是比较好的选择。</p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
