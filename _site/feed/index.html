<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2020-10-24T23:16:59+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>service mesh 学习资料收集</title>
      <link href="http://localhost:4000/service-mesh-refer/"/>
      <pubDate>2020-10-17T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/service-mesh-refer</guid>
      <content:encoded><![CDATA[<h3 id="资料收集">资料收集</h3>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/61901608">什么是Service Mesh</a></li>
  <li><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html">Pattern: Service Mesh</a></li>
  <li><a href="https://www.servicemesher.com/istio-handbook/">Istio Handbook——Istio 服务网格进阶实战</a></li>
  <li><a href="https://istio.io/">istio官网 https://istio.io/</a></li>
  <li><a href="https://www.servicemesher.com/envoy/">Envoy 官方文档中文版</a></li>
  <li><a href="https://github.com/sofastack/sofa-mesh">蚁金服开源SOFAMesh</a></li>
  <li><a href="https://www.servicemesher.com/blog/istio-the-king-of-service-mesh/">腾讯云容器团队内部Istio专题分享</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>腾讯云容器团队内部Istio 笔记</title>
      <link href="http://localhost:4000/service-mesh-refer-copy/"/>
      <pubDate>2020-10-17T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/service-mesh-refer copy</guid>
      <content:encoded><![CDATA[<p>文章来源： <a href="https://www.servicemesher.com/blog/istio-the-king-of-service-mesh/">腾讯云容器团队内部Istio专题分享</a>
作者：钟华</p>

<p>微服务架构是更为复杂的分布式系统，它给运维带来了更多挑战, 这些挑战主要包括资源的有效管理和服务之间的治理, 如:</p>

<p>新的分布式系统:微服务架构 带来了新挑战， 资源的有效管理和服务之间的治理。 其实分布式系统本质上都有这样的挑战，但微服务架构快速发展，让这一些问更加突出了。</p>

<ul>
  <li>服务注册, 服务发现</li>
  <li>服务伸缩</li>
  <li>健康检查</li>
  <li>快速部署</li>
  <li>服务容错: 断路器, 限流, 隔离舱, 熔断保护, 服务降级等等</li>
  <li>认证和授权</li>
  <li>灰度发布方案</li>
  <li>服务调用可观测性, 指标收集</li>
  <li>配置管理</li>
</ul>

<p>在很多微服务架构中，都是通过架构api、sdk。做入侵式的开发，在架构中屏蔽了底层网络的复杂性，提供服务注册发现、服务RPC通信、服务配置管理、服务负载均衡、路由限流、容错、服务监控及治理、服务发布及升级等通用能力。</p>

<p>比较典型的产品有:</p>
<ul>
  <li>分布式RPC通信框架: COBRA, WebServices, Thrift, GRPC 等</li>
  <li>服务治理特定领域的类库和解决方案: Hystrix, Zookeeper, Zipkin, Sentinel 等</li>
  <li>对多种方案进行整合的微服务框架: SpringCloud、Finagle、Dubbox 等</li>
</ul>

<p>service mesh 提供了一种 <strong>Sidecar 模式</strong></p>

<p>这其实不是什么新东西，以前叫做agent, 在两个节点之前加一个代理。 微服务的大部分需要解决的问题，在这sidecar 实现。提供服务注册发现、服务RPC通信、服务配置管理、服务负载均衡、路由限流、容错、服务监控及治理、服务发布及升级等通用能力</p>

<p>Linkerd的CEO Willian Morgan给出的Service Mesh的定义:</p>

<blockquote>
  <p>A Service Mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable &gt; delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the
Service Mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code,
without the application needing to be aware.</p>
</blockquote>

<p>关键字：基础设施层　轻量级网络代理　对应用程序透明</p>

<p>第二代 Service Mesh　在数据平面的基础上添加了控制平面。</p>

<p>国内Service Mesh 发展情况：</p>

<ul>
  <li>蚂蚁金服开源SOFAMesh：
    <ul>
      <li>https://github.com/alipay/sofa-mesh</li>
      <li>从istio fork</li>
      <li>使用Golang语言开发全新的Sidecar，替代Envoy</li>
      <li>为了避免Mixer带来的性能瓶颈，合并Mixer部分功能进入Sidecar</li>
      <li>Pilot和Citadel模块进行了大幅的扩展和增强</li>
      <li>扩展RPC协议: SOFARPC/HSF/Dubbo</li>
    </ul>
  </li>
  <li>华为:
    <ul>
      <li>go-chassis: https://github.com/go-chassis/go-chassis golang 微服务框架, 支持istio平台</li>
      <li>mesher: https://github.com/go-mesh/mesher mesh 数据面解决方案</li>
      <li>国内首家提供Service Mesh公共服务的云厂商
目前(2019年1月)公有云Istio 产品线上已经支持申请公测, 产品形态比较完善
腾讯云 TSF:
基于 Istio、envoy 进行改造
支持 Kubernetes、虚拟机以及裸金属的服务
对 Istio 的能力进行了扩展和增强, 对 Consul 的完整适配
对于其他二进制协议进行扩展支持
唯品会
OSP (Open Service Platform)
新浪:
Motan: 是一套基于java开发的RPC框架, Weibo Mesh 是基于Motan</li>
    </ul>
  </li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>缓存</title>
      <link href="http://localhost:4000/cache/"/>
      <pubDate>2020-08-21T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/cache</guid>
      <content:encoded><![CDATA[<p>学习资料：
<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98">缓存</a></p>

<p>缓存可以提高页面的加载数据速度，减少服务器和数据库的负担。一般是先查询缓存中是否存在，不存在则向数据源请求，然后缓存在本地。</p>

<p>数据库分征均匀分布的读取是最好的，但存在热门数据，均匀分布读取就变成不可能的事，所以，缓存有效的缓解这一问题。</p>

<p>缓存分类：</p>

<ol>
  <li>客户端缓存</li>
  <li>CDN缓存</li>
  <li>Web服务器缓存</li>
</ol>

<h3 id="客户端缓存">客户端缓存</h3>

<p>一般指的是请求的缓存在本地的方式，可以位于客户端（操作系统，浏览器），服务器（当作客户端看待）另一个角度上看可以是进程内。</p>

<p>### CDN缓存</p>

<p>可以当做一种缓存，主要缓存静态文件。</p>

<h3 id="web服务器缓存">Web服务器缓存</h3>

<p>请求的数据被缓存在web服务器上，当发现这url命中缓存时，直接返回，不再向应用服务器请求数据。反向代理和缓存varnish。（查一下）</p>

<h3 id="数据库缓存">数据库缓存</h3>

<p>大部分数据库是可以配置内存缓存，如mysql <a href="https://zhuanlan.zhihu.com/p/55947158">[玩转MySQL之四]MySQL缓存机制</a>。
针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。</p>

<h3 id="应用缓存">应用缓存</h3>

<p>基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 least recently used (LRU) 的缓存无效算法可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。</p>

<p>Redis 有下附加功能：</p>

<ul>
  <li>持久性选项</li>
  <li>内置数据结构（有序集合和列表）</li>
</ul>

<p>有多个缓存级别，分为两大类： <strong>数据库查询</strong>和<strong>对象</strong></p>

<ul>
  <li>行级别</li>
  <li>查询级别</li>
  <li>完整的可序列化对象</li>
  <li>完全渲染的HTML</li>
</ul>

<p>一般来说，你应该尽量避免基于文件的缓存，因为这使得复制和自动缩放很困难。</p>

<p>对象级别的缓存</p>

<p>将数据视为对象，就像对待你的应用代码一样，让应用程序数据从数据库中的组合到类实例或数据结构中：</p>

<ul>
  <li>如果查对象的基础数据已经更改了。那么从缓存中删掉这个对象。（一般很难知道基础数据是否已经更新了）</li>
  <li>异步处理： workers 通过使用最新的缓存对象来组装对象。（监控基础数据是否有更新，有则更新缓存，注意必要时加锁）</li>
</ul>

<p>建议缓存的内容： 什么数据应该缓存，还是要看具体的场景，是否提高访问速度，减少服务器或数据库压力。换个说法，建议什么内容不要用缓存，事务性要求比较高，涉及交易数据等（后续想到添加….）</p>

<h3 id="何时更新缓存">何时更新缓存</h3>

<h4 id="缓存模式">缓存模式</h4>

<p>应用从存储器读写。缓存不和存储器直接交互，执行如下：</p>

<ul>
  <li>在缓存中查询记录，没命中</li>
  <li>从存储器中加载所需内容</li>
  <li>将查找到的结果存储到缓存中</li>
  <li>返回所需内容</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">get_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"user.{0}"</span><span class="p">,</span> <span class="n">user_id</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s">"SELECT * FROM users WHERE user_id = {0}"</span><span class="p">,</span> <span class="n">user_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s">"user.{0}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
            <span class="n">cache</span><span class="o">.</span><span class="nb">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">user</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">user</span>
</code></pre></div></div>
<p>这种方式一般都有设置缓存有效期。当过了有效期则重新从存储器上读取。
缺点：</p>

<ul>
  <li>请求数据不在缓存中，就需要经过三个步骤来获取数据，会有明显的延迟。</li>
  <li>存储器上的数据被更新了，会导致缓存中的数据成为旧数据。请求没能及时拿到最新的数据，可能通过设计有效时间，或直写的模式来缓解这种情况。</li>
</ul>

<h4 id="直写模式">直写模式</h4>

<p>应用使用缓存作为说要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。</p>

<ul>
  <li>应用向缓存中添加/更新数据</li>
  <li>缓存同步地写入数据存储</li>
  <li>返回所需内容</li>
</ul>

<p>即，应用层只关心写缓存就可以了，同步数据库由缓存机制自己完成。</p>

<p>应用代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set_user</span><span class="p">(</span><span class="mi">12345</span><span class="p">,</span> <span class="p">{</span><span class="s">"foo"</span><span class="p">:</span><span class="s">"bar"</span><span class="p">})</span>
</code></pre></div></div>
<p>缓存代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_user</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s">"UPDATE Users WHERE id = {0}"</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
    <span class="n">cache</span><span class="o">.</span><span class="nb">set</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">user</span><span class="p">)</span>
</code></pre></div></div>

<p>直写模式的缺点：</p>

<ul>
  <li>写入的大多数数据可能永远不会被读取，用TTL（生存时间值）可以最小化这种情况。</li>
  <li>存写操作比较慢，但读取刚写的数据很快。</li>
</ul>

<h4 id="回写模式">回写模式</h4>

<p>先写入缓存中，然后通过MQ，把数据发给另一个模块，由它写入数据库。</p>

<ul>
  <li>在缓存中增加或更新条目。</li>
  <li>异步写入数据，提高写入性能。</li>
</ul>

<p>缺点：</p>

<ul>
  <li>可能存在缓存写入成功，写入数据库失败，导致数据不一致。</li>
  <li>方式比直写模式或缓存更复杂一些。</li>
</ul>

<h3 id="相关资源和延伸阅读">相关资源和延伸阅读</h3>

<p><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies">缓存替换策略</a>
<a href="https://lethain.com/introduction-to-architecting-systems-for-scale/">可缩放系统构架介绍</a>
<a href="https://en.wikipedia.org/wiki/Cache_(computing)">维基百科</a></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>负载均衡和反向代理</title>
      <link href="http://localhost:4000/load-balancing-and-reverse-proxy/"/>
      <pubDate>2020-08-19T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/load-balancing-and-reverse-proxy</guid>
      <content:encoded><![CDATA[<h2 id="负载均衡">负载均衡</h2>

<p>负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。</p>

<h4 id="一个没有负载均衡的web架构">一个没有负载均衡的web架构</h4>

<p><img src="https://pic3.zhimg.com/80/v2-6a7f624cd5e776a6b0b05a051e65666e_720w.jpg" alt="" /></p>

<h4 id="存在问题">存在问题</h4>

<ol>
  <li>如果服务器宕机了，用户就无法访问到数据了。</li>
  <li>单位时间内请求人的比较，可能会超过它的处理极限，也可能请求不到数据。</li>
</ol>

<p>后端引入负载均衡器，可以缓解这个问题。通常要求所有后端服务器保证提供相同的内容，无论用户访问时昨到那了个服务响应。都能收到相同的内容。</p>

<h4 id="负载均衡器的效用在于">负载均衡器的效用在于</h4>

<ul>
  <li>防止请求进入不好的服务器</li>
  <li>防止资源过载帮助</li>
  <li>消除单一的故障点</li>
  <li>水平扩展，提高性能和可用性，性价比高。</li>
</ul>

<p><img src="https://picb.zhimg.com/80/v2-6aa2607e04cc9d2f0d448f9fa80b2ae2_720w.jpg" alt="" /></p>

<h4 id="负载均衡可以处理协议请求">负载均衡可以处理协议请求：</h4>

<ul>
  <li>http</li>
  <li>https</li>
  <li>tcp</li>
  <li>udp</li>
</ul>

<p>其实负载均衡是一种解法的问题思路，和具体的协议没什么关系。特定协议可以自己写负载均衡器达到目的。</p>

<p>负载均衡器如何选择要转发的后端服务器？</p>

<p>首先，要确保所和选择的服务器是健康的，一般会有一个健康服务器池（healthy pool）中进行选择。</p>

<p>如何知道后端的服务是否健康，我猜负载均衡器会定时的检测后端的服务的状态，是否可用。　</p>

<h4 id="选择规则算法">选择规则算法：</h4>

<ol>
  <li>轮询算法</li>
  <li>加权轮询算法</li>
  <li>随机算法</li>
  <li>加权随机算法</li>
  <li>哈希法</li>
  <li>一致性哈希</li>
  <li>最少连接算法</li>
</ol>

<p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上垂直扩展更贵的硬件具有更高的可用性。</p>

<p><strong>水平扩展的缺陷：</strong></p>

<ul>
  <li>
    <p>水平扩展引入了复杂度并涉及服务器复制</p>

    <ul>
      <li>服务器应该是无状态的:它们也不该包含像 session 或资料图片等与用户关联的数据。</li>
      <li>session 可以集中存储在数据库或持久化缓存（Redis、Memcached）的数据存储区中。</li>
    </ul>
  </li>
  <li>
    <p>缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。</p>
  </li>
</ul>

<h4 id="nginx-负载均衡的策略">nginx 负载均衡的策略：</h4>

<ol>
  <li>轮询（默认）： 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端不通，则自动剔除。</li>
  <li>weight  ： 指定轮询几率，weight和访问比率成正比， 用于后端服务器能不情况。</li>
  <li>ip_hash :  通过hash 用户访问IP，把用户指向同一个服务器上，这种方式会把用户固定在某一个服务器上，除非用户IP变了。</li>
  <li>fair （第三方）： 按后端服务嘎嘎的响应时间来分配请求，响应时间短的优先分配。</li>
  <li>url_hash (第三方) ：按访问url的hash结果来分配请求，使用每个url定向到一个（对应的）后端服务。</li>
</ol>

<h4 id="扩展阅读">扩展阅读</h4>

<ul>
  <li><a href="https://blog.csdn.net/readiay/article/details/53538085">浮动IP（FLOAT IP）</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/32841479">什么是负载均衡？https://zhuanlan.zhihu.com/p/32841479</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1480179">大神口中的服务器负载均衡到底是什么意思？https://cloud.tencent.com/developer/article/1480179</a></li>
  <li><a href="https://www.cnblogs.com/xybaby/p/7867735.html">关于负载均衡的一切：总结与思考:https://www.cnblogs.com/xybaby/p/7867735.html</a></li>
</ul>

<h2 id="反向代理">反向代理</h2>

<p>反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。</p>

<p><strong>带来的好处包括：</strong></p>

<ul>
  <li>增加安全性 - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。</li>
  <li>提高可扩展性和灵活性 - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。</li>
  <li>本地终结 SSL 会话 - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。 免除了在每个服务器上安装 X.509 证书的需要</li>
  <li>压缩 - 压缩服务器响应.</li>
  <li>缓存 - 直接返回命中的缓存结果.</li>
  <li>静态内容 - 直接提供静态内容, HTML/CSS/JS图片视频等等</li>
</ul>

<h4 id="扩展阅读-1">扩展阅读</h4>

<ul>
  <li><a href="https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/">What is a Reverse Proxy vs. Load Balancer? https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/</a></li>
  <li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/">NGINX 架构 https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》 微服务架构核心20讲</title>
      <link href="http://localhost:4000/time-geekbang-microservice-core20/"/>
      <pubDate>2020-02-09T03:22:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/time-geekbang-microservice-core20</guid>
      <content:encoded><![CDATA[<p>极客时间学习笔记， 微服务架构核心20讲</p>

<p>作者：杨波　（拍拍贷框架研发部总监，资深架构师，微服务技术专家）</p>

<p><a href="https://time.geekbang.org/course/intro/66">微服务架构核心20讲 https://time.geekbang.org/course/intro/66</a></p>

<h2 id="1-什么是微服务架构">1 什么是微服务架构</h2>
<hr />
<p>微服务是一种架构风格（如MVC）　</p>

<p>微服务的六个特点：　</p>
<ul>
  <li>一组小的服务</li>
  <li>独立的进程</li>
  <li>轻量级通信</li>
  <li>基于业务能务</li>
  <li>独立部署</li>
  <li>无集中式管理 （这里指的是可以用不同的技术栈，不同的存储）</li>
</ul>

<p>微服框架的定义者马丁福勒：他的一篇博客：</p>

<p><a href="https://www.martinfowler.com/articles/microservices.html">马丁福勒的文章 https://www.martinfowler.com/articles/microservices.htm</a></p>

<p><strong>微服务定义</strong></p>

<p>基于有界上下文的　松散耦合面向服务的架构。</p>

<h2 id="２架构师如何权衡微服务的利弊">２　架构师如何权衡微服务的利弊</h2>
<hr />
<p>开发者的一个重要职责就是权衡</p>

<p>利:</p>

<ul>
  <li>强模块化边界</li>
  <li>可独立部署</li>
  <li>技术多样性</li>
</ul>

<p>弊:</p>
<ul>
  <li>分布式系统复杂性</li>
  <li>最终一致性</li>
  <li>运维复杂性</li>
  <li>测试复杂性</li>
</ul>

<p>分布式系统带来的一个挑战就是取终一致性。</p>

<h2 id="３康威法则和微服务给架构师怎样的启示">３　康威法则和微服务给架构师怎样的启示</h2>
<hr />

<p>设计系统的组织，其产生的架构设计等价于组织间的沟通结构。</p>

<p>其实就是要规避，多个团队去支持一个服务模块。应该拆解成一个团队支持一个小服务，多个小服务组织成一个大服务（或系统）。</p>

<h2 id="４企业应该在什么时候开始考虑引入微服务">４　企业应该在什么时候开始考虑引入微服务</h2>
<hr />

<p>微服务的适用性:</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_4.png" alt="" /></p>

<p>Monolth 单块服务</p>

<p>Microservice 微服务</p>

<p>微服务 有基础模块和平台的要求，所以企业刚开始时微服务并不能有高的生产力。</p>

<p>所以一般以单块服务开始。适用于小企业，微服务更加适合于中大型企业。</p>

<p>中间的交点，就是企业要考虑从单块服务切换成微服务的时候了。</p>

<p>业务模块的复杂性已经达到某个点了。 点的把控要架构师应该思考的问题、一般100人的团队可以考虑了这个问题了。</p>

<p>一般业务开始以单块服务优先。如果研发效率开始下降了。再做优化，向微服方向转变。</p>

<p>如果一开始就以微服开始，可能在设计上会更复杂。</p>

<p>架构是演化出来的。</p>

<p>不可能一步到位， 所以一般是单块优先原则，然后不断迭代，不断的微服化。</p>

<h2 id="5-什么样组织架构更适合微服务">5 什么样组织架构更适合微服务</h2>
<hr />

<p>组织架构：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_5_1.png" alt="" /></p>

<p>左边是比较传统的组织架构。产品从左到右流程走，可能出现的问题，反馈比较慢，对业务支持比较慢。沟通成本比较大。</p>

<p>右边是比较合适微服务的组织架构， 每一个团队（基于微服务的跨职能的团队），有开发，有产品，有测试，团队都支持自己的微服务。交付的产口是平台，对外提供API
接口支持多样的业务。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_5_2.png" alt="" /></p>

<p>在团队内做内部循环。端对端的开发。</p>

<p>谁开发的，谁构建，谁支持。</p>

<h2 id="6-如何理解阿里巴巴提出的微服务">6 如何理解阿里巴巴提出的微服务</h2>
<hr />

<p>中台战略和微服务的关系
下图：一线互联网主流的组织架构。 微服的标准的参考架构。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_6.png" alt="" /></p>

<p>业务中台和技术中台 统称为大中台。支撑业务前台。中台越强大，前台越发展越快。</p>

<p>PaaS 和 核心业务层是和微服务相关的。这一些基本都可以用微服务来实现。</p>

<p>IaaS：Infrastructure-as-a-Service（基础设施即服务）</p>

<p>PaaS：Platform-as-a-Service（平台即服务）</p>

<h2 id="7-如何给出一个清晰简洁的服务分层方式">7 如何给出一个清晰简洁的服务分层方式</h2>
<hr />

<p>大致的服务分层图：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_7.png" alt="" /></p>

<p>SOA  Service-Oriented Architecture  （面向服务的架构）</p>

<p>基础服务：　也有其他的说法。如：核心领域服务、中间层服务、公共服务。</p>

<p>聚合服务：　对基础服务的聚全和裁剪，以达到满足业务的需求，提供给外部调用。　</p>

<h2 id="８微服务总体技术架构体系是怎么设计的">８　微服务总体技术架构体系是怎么设计的</h2>
<hr />

<p>微服务总体架构体系图：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_8.png" alt="" /></p>

<ul>
  <li>接入层：　外部和内部接入，主要把流量接入进来，做负载均衡。</li>
  <li>网关层：　反向路由，限流，安全，跨横切面的功能。　　</li>
  <li>业务服务层：　可分为：聚合服务，基础服务。</li>
  <li>支撑服务： 后台服务。</li>
  <li>平台服务： 可以是一些管理系统。</li>
  <li>基础设施　由运维团队运维。　</li>
</ul>

<p>网关层、业务服务层、支撑服务、平台服务。 这四层可以和微服务相关的，</p>

<h2 id="9-微服务最经典的三种服务发现机制">9 微服务最经典的三种服务发现机制</h2>
<hr />

<p>消息者应该怎么去发现生产者。三者主流的模式：</p>

<p>1 通过DNS 访问LB，LB（负载均衡）。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_9_1.png" alt="" /></p>

<p>2 　LB功能放到Consumer内， service 注册到 Service Registry上。有定时心跳发到注册中收，Consumer  定期的同步 Service Registry的信息。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_9_2.png" alt="" /></p>

<p>3 结全前面两种方式， 在Consumer的主机上也布置一个LB。 LB会定期同步Service Registry的信息。 运维成本比较高一点。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_9_3.png" alt="" /></p>

<h2 id="10-微服务-api-服务网关一原理">10 微服务 API 服务网关（一）原理</h2>
<hr />

<p>API　Gateway</p>

<p>屏蔽掉服务内部的逻辑，希望外部访问看到是统一的接口。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_10_1.png" alt="" /></p>

<p>下面这个图 接入网关的前面有一层LB（负载均衡）如果是网关可以是无状态的，这样方便扩展，单点挂掉时，可以摘除。对系统的稳定性很重要。</p>

<h5 id="网关主要的功能">网关主要的功能</h5>
<ul>
  <li>反向路由  将外部的请求换成内部调用。</li>
  <li>认证安全 防刷 防爬虫。</li>
  <li>限流熔断 处理可能会突发流量。</li>
  <li>日志监控  进行访问访问审计，监控流量。</li>
</ul>

<p>一般不要把过多的业务逻辑写在网关当中。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_10_2.png" alt="" /></p>

<h2 id="11-服务-api-服务网关二开源网关-zuul">11 服务 API 服务网关（二）开源网关 Zuul</h2>
<hr />

<p>核心:  Servlet 和 Fitter Runner 
过滤器：  前置过滤器，  路由过滤器，后置过滤器</p>

<p>过滤器开发，可以通过脚本开发。开发完后上传到过滤器目录中， 被扫描后加到Filtter Runner中。</p>

<p>各个Fitte 共享数据通过 Request Context 来实现。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_11_1.png" alt="" /></p>

<p>过滤链的流程：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_11_2.png" alt="" /></p>

<p>前置路由过滤器</p>

<p>路由过滤器</p>

<p>后置路由过滤器</p>

<h2 id="12-跟-netflix-学习微服务路由发现体系">12 跟 Netflix 学习微服务路由发现体系</h2>
<hr />

<p>netflix 有两个比较重要的支撑服务</p>

<ul>
  <li>服务注册中心  Eureka</li>
  <li>网关 zuul</li>
</ul>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_12.png" alt="" /></p>

<h2 id="13-集中式配置中心的作用和原理是什么">13 集中式配置中心的作用和原理是什么</h2>
<hr />

<p>为什么要引入配置中心呢？
　
小企业一般是写在配置文件中的，不方便管理。响应比较慢。无法审计。配置中心可能解决这些问题。</p>

<p>什么可做配置呢？</p>

<ul>
  <li>业务开关</li>
  <li>调用/响应超时</li>
  <li>限流</li>
  <li>连接字符串</li>
  <li>动态参数</li>
</ul>

<p>Svr 更新配置有两种方式 拉和推。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_13_1.png" alt="" /></p>

<p>携程的Apollo配置中心:</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_13_2.png" alt="" /></p>

<p>github : https://github.com/ctripcorp/apollo</p>

<h2 id="14-微服务通讯方式-rpc-vs-rest">14 微服务通讯方式 RPC vs REST</h2>
<hr />
<p>RPC：Remote Procedure Call 远程过程调用</p>

<p>REST ：Restful</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_14.png" alt="" /></p>

<h2 id="15-微服务框架需要考虑哪些治理环节">15 微服务框架需要考虑哪些治理环节</h2>
<hr />

<p>一个公司的微服务多了，就要需要考虑治理。</p>

<p>软负载： 蓝绿发布， 灰度发布</p>

<p>Metrics: 服务的调用量， 耗时监控。</p>

<p>调用链埋点： 方便快速定位问题，</p>

<p>契约生成代码： 定义结构体可自动生成json格式， vscode 有插件。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_15.png" alt="" /></p>

<p>阿里巴巴微服务治理生态：Dubbo 	http://dubbo.apache.org/en-us/</p>

<h2 id="16-微服务监控系统分层和监控架构">16 微服务监控系统分层和监控架构</h2>
<hr />

<p>五个层次的监控</p>

<ul>
  <li>基础设施监控</li>
  <li>系统层监控</li>
  <li>应用层监控 url sevice mysql cache 可用率，性能， qps</li>
  <li>业务层监控 核心指标监控 登录注册</li>
  <li>端用户体验监控</li>
</ul>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_16_1.png" alt="" /></p>

<p>日志 监控  对应Elasticsearch<br />
metrics 监控
健康检查
调用链监控
告警系统</p>

<p>比较典型的监控架构，大部分公司的流程</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_16_2.png" alt="" /></p>

<p>比较大的队列用kafka 。</p>

<p>Nagios 健康检测工具。</p>

<p>ELK　ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。</p>

<h2 id="17-微服务的调用链监控该如何选型">17 微服务的调用链监控该如何选型</h2>
<hr />

<p>调用链的监控　谷歌2010年提出来的。　</p>

<p>通过 Span来跟踪， RootSpan  ChildSpan  跨进程时  会有Trace di + parant span id</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_17_1.png" alt="" /></p>

<p>三个主流调用链监控系统的比较：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_17_2.png" alt="" /></p>

<h2 id="18-微服务的容错限流是如何工作的">18 微服务的容错限流是如何工作的</h2>
<hr />

<p>Netfiix  Hystrix 具有熔断 隔离 限流 降级的功能 。</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_18.png" alt="" /></p>

<p>说明：</p>

<ul>
  <li>3 Cirult OPen 判断是否可以熔断， 是则执行 getFAllBack() 降级处理函数</li>
  <li>5 run() 超时 也执行降级处理函数。</li>
  <li>6 不成功也 执行处理函数 。</li>
  <li>Calculate Cirult Health 就是在正常执行成功后计算是否需要熔断。</li>
</ul>

<h2 id="19-docker-容器部署技术--持续交付流水线">19 Docker 容器部署技术 &amp; 持续交付流水线</h2>
<hr />

<p>docker 容器治理就是解决：环境不一致的问题。把依赖的所有包都打在镜像中。</p>

<p>统一、标准化的交付流水线。</p>

<p>UAT 环境： User Acceptance Test （用户验收测试）</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_19_1.png" alt="" /></p>

<p>发布模式： 蓝绿布置，灰度发布（金丝雀发布）。</p>

<p>金丝雀发布 滚动发布：</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_19_2.png" alt="" /></p>

<h2 id="20-容器集群调度和基于容器的发布体系">20 容器集群调度和基于容器的发布体系</h2>
<hr />

<p>资源调度框架 Mesos 架构</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_20_1.png" alt="" /></p>

<p>基于容器的云发布体系</p>

<p><img src="/assets/time-geekbang-microservice-core20/micro_server_20_2.png" alt="" /></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 条件变量 sync.Cond</title>
      <link href="http://localhost:4000/timegeekbang-go-syncCond/"/>
      <pubDate>2019-03-28T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-syncCond</guid>
      <content:encoded><![CDATA[<p>条件变量是和互斥锁一起使用的。
条件变量是和互斥锁一起使用的。</p>

<p>条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。</p>

<p>条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。</p>

<p>这里有一个疑问：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">mailbox</span><span class="x"> </span><span class="kt">uint8</span><span class="x">
</span><span class="k">var</span><span class="x"> </span><span class="n">lock</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span><span class="x">
</span><span class="n">sendCond</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span><span class="x">
</span><span class="n">recvCond</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">NewCond</span><span class="p">(</span><span class="n">lock</span><span class="o">.</span><span class="n">RLocker</span><span class="p">())</span><span class="x">
</span></code></pre></div></div>

<p>endCond := sync.NewCond(&amp;lock)和recvCond := sync.NewCond(lock.RLocker())</p>

<p>传入的一个是 &amp;lock 另一个是 lock.RLocker() 为什么？</p>

<p><strong>条件变量的Wait方法做了什么？</strong></p>

<p>条件变量的Wait方法主要做了四件事。</p>

<p>1　把调用它的 goroutine（也就是当前的 goroutine）加入到当前条件变量的通知队列中。</p>

<p>2　解锁当前的条件变量基于的那个互斥锁。</p>

<p>3　让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 goroutine 就会阻塞在调用这个Wait方法的那行代码上。</p>

<p>4　如果通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的goroutine 就会继续执行后面的代码了。</p>

<p><strong>条件变量的Signal方法和Broadcast方法有哪些异同？</strong></p>

<p>条件变量的Signal方法和Broadcast方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 goroutine，而后者的通知却会唤醒所有为此等待的 goroutine。</p>

<p>扩展 ：https://blog.csdn.net/wentyoon/article/details/81174288</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 互斥锁 sync.Mutex与sync.RWMutex</title>
      <link href="http://localhost:4000/timegeekbang-go-syncMutex/"/>
      <pubDate>2019-03-27T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-syncMutex</guid>
      <content:encoded><![CDATA[<p>一个互斥锁可以被 用来保护一个临界区或一组相关临界区。保证在同一时刻只有一个Goroutine处于该临界区之内</p>

<p>为了兑现这保证上，每当goroutine 想进入临界区时，都要先对它进行锁定 ，离开时临界区时都要及时地对它进行解锁。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
</span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writer</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
 </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"error: %s [%d]"</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">,</span><span class="x"> </span><span class="n">id</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
</span></code></pre></div></div>

<p><strong>使用互斥锁时有哪 些注意事项：</strong></p>

<p>1 不要重复锁定互斥锁。</p>

<p>2 不要忘记解锁互斥锁，必要时用 defer 语句</p>

<p>3 不要对沿未锁定或者已经解锁的互斥锁解锁</p>

<p>4 不要在多个函数之前直接传递互斥锁</p>

<p>死锁时抛出的panic是属于致使错误，都是无法被恢复的，调用recover函数对它们起不了任何作用。</p>

<p>互斥锁是开箱即用的。sysnc.Mutex类型 是一个结构体类型，属于值类型中的一种，把它传给一个函数、将它从函数中返回，把它赋给其他变量。让它进入 某个通道都会导致它的副本的产生。
它们是独立的，都是不同的互斥锁。</p>

<p><strong>读写锁与互斥锁有哪 异同？</strong></p>

<p>sync.RWMute类型的值代表。 都是开箱即用。 它是把对共享资源的“读操作”和“写操作”区别对待。</p>

<p>比互斥锁有列加细腻的访问控制。</p>

<p>一个读写锁中实际上包含了两个锁，即：读锁和写锁。sync.RWMutex类型中的Lock方法和Unlock方法分别用于对写锁进行锁定和解锁，而它的RLock方法和RUnlock方法则分别用于对读锁进行锁定和解锁。</p>

<p><strong>另外，对于同一个读写锁来说有如下规则：</strong></p>

<p>1 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的 goroutine。</p>

<p>2 在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的 goroutine</p>

<p>3 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goroutine。</p>

<p>4 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的goroutine。</p>

<p>换一个角度来说，对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行。</p>

<p>go 语言代码  实例：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
    </span><span class="s">"bytes"</span><span class="x">
    </span><span class="s">"errors"</span><span class="x">
    </span><span class="s">"fmt"</span><span class="x">
    </span><span class="s">"io"</span><span class="x">
    </span><span class="s">"log"</span><span class="x">
    </span><span class="s">"sync"</span><span class="x">
    </span><span class="s">"time"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="c">// singleHandler 代表单次处理函数的类型。</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">singleHandler</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x">

</span><span class="c">// handlerConfig 代表处理流程配置的类型。</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">handlerConfig</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">handler</span><span class="x">   </span><span class="n">singleHandler</span><span class="x"> </span><span class="c">// 单次处理函数。</span><span class="x">
    </span><span class="n">goNum</span><span class="x">     </span><span class="kt">int</span><span class="x">           </span><span class="c">// 需要启用的goroutine的数量。</span><span class="x">
    </span><span class="n">number</span><span class="x">    </span><span class="kt">int</span><span class="x">           </span><span class="c">// 单个goroutine中的处理次数。</span><span class="x">
    </span><span class="n">interval</span><span class="x">  </span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="x"> </span><span class="c">// 单个goroutine中的处理间隔时间。</span><span class="x">
    </span><span class="n">counter</span><span class="x">   </span><span class="kt">int</span><span class="x">           </span><span class="c">// 数据量计数器，以字节为单位。</span><span class="x">
    </span><span class="n">counterMu</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="x">    </span><span class="c">// 数据量计数器专用的互斥锁。</span><span class="x">

</span><span class="p">}</span><span class="x">

</span><span class="c">// count 会增加计数器的值，并会返回增加后的计数。</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">hc</span><span class="x"> </span><span class="o">*</span><span class="n">handlerConfig</span><span class="p">)</span><span class="x"> </span><span class="n">count</span><span class="p">(</span><span class="n">increment</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">hc</span><span class="o">.</span><span class="n">counterMu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
    </span><span class="k">defer</span><span class="x"> </span><span class="n">hc</span><span class="o">.</span><span class="n">counterMu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
    </span><span class="n">hc</span><span class="o">.</span><span class="n">counter</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="n">increment</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">hc</span><span class="o">.</span><span class="n">counter</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// mu 代表以下流程要使用的互斥锁。</span><span class="x">
    </span><span class="c">// 在下面的函数中直接使用即可，不要传递。</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">mu</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="x">

    </span><span class="c">// genWriter 代表的是用于生成写入函数的函数。</span><span class="x">
    </span><span class="n">genWriter</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">writer</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">Writer</span><span class="p">)</span><span class="x"> </span><span class="n">singleHandler</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="c">// 准备数据。</span><span class="x">
            </span><span class="n">data</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span><span class="x">
                </span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">StampNano</span><span class="p">))</span><span class="x">
            </span><span class="c">// 写入数据。</span><span class="x">
            </span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
            </span><span class="n">n</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">writer</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="x">
            </span><span class="k">return</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// genReader 代表的是用于生成读取函数的函数。</span><span class="x">
    </span><span class="n">genReader</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">reader</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span><span class="x"> </span><span class="n">singleHandler</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">(</span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">buffer</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reader</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">)</span><span class="x">
            </span><span class="k">if</span><span class="x"> </span><span class="o">!</span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"unsupported reader"</span><span class="p">)</span><span class="x">
                </span><span class="k">return</span><span class="x">
            </span><span class="p">}</span><span class="x">
            </span><span class="c">// 读取数据。</span><span class="x">
            </span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span><span class="x">
            </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">buffer</span><span class="o">.</span><span class="n">ReadString</span><span class="p">(</span><span class="sc">'\t'</span><span class="p">)</span><span class="x">
            </span><span class="n">n</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="x">
            </span><span class="k">return</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// buffer 代表缓冲区。</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">buffer</span><span class="x"> </span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="x">

    </span><span class="c">// 数据写入配置。</span><span class="x">
    </span><span class="n">writingConfig</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">handlerConfig</span><span class="p">{</span><span class="x">
        </span><span class="n">handler</span><span class="o">:</span><span class="x">  </span><span class="n">genWriter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">),</span><span class="x">
        </span><span class="n">goNum</span><span class="o">:</span><span class="x">    </span><span class="m">5</span><span class="p">,</span><span class="x">
        </span><span class="n">number</span><span class="o">:</span><span class="x">   </span><span class="m">4</span><span class="p">,</span><span class="x">
        </span><span class="n">interval</span><span class="o">:</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="m">100</span><span class="p">,</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="c">// 数据读取配置。</span><span class="x">
    </span><span class="n">readingConfig</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">handlerConfig</span><span class="p">{</span><span class="x">
        </span><span class="n">handler</span><span class="o">:</span><span class="x">  </span><span class="n">genReader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">),</span><span class="x">
        </span><span class="n">goNum</span><span class="o">:</span><span class="x">    </span><span class="m">10</span><span class="p">,</span><span class="x">
        </span><span class="n">number</span><span class="o">:</span><span class="x">   </span><span class="m">2</span><span class="p">,</span><span class="x">
        </span><span class="n">interval</span><span class="o">:</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="m">100</span><span class="p">,</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// sign 代表信号的通道。</span><span class="x">
    </span><span class="n">sign</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="k">struct</span><span class="p">{},</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="o">+</span><span class="n">readingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="p">)</span><span class="x">

    </span><span class="c">// 启用多个goroutine对缓冲区进行多次数据写入。</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">sign</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="k">struct</span><span class="p">{}{}</span><span class="x">
            </span><span class="p">}()</span><span class="x">
            </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">number</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">writingConfig</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span><span class="x">
                </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">handler</span><span class="p">()</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"writer [%d-%d]: error: %s"</span><span class="p">,</span><span class="x">
                        </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x">
                    </span><span class="k">continue</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="n">total</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="x">
                </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"writer [%d-%d]: %s (total: %d)"</span><span class="p">,</span><span class="x">
                    </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">total</span><span class="p">)</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}(</span><span class="n">i</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// 启用多个goroutine对缓冲区进行多次数据读取。</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">i</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">defer</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">sign</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="k">struct</span><span class="p">{}{}</span><span class="x">
            </span><span class="p">}()</span><span class="x">
            </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">1</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">number</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">readingConfig</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span><span class="x">
                </span><span class="k">var</span><span class="x"> </span><span class="n">data</span><span class="x"> </span><span class="kt">string</span><span class="x">
                </span><span class="k">var</span><span class="x"> </span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="x">
                </span><span class="k">var</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="kt">error</span><span class="x">
                </span><span class="k">for</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">n</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">handler</span><span class="p">()</span><span class="x">
                    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="o">||</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="n">io</span><span class="o">.</span><span class="n">EOF</span><span class="x"> </span><span class="p">{</span><span class="x">
                        </span><span class="k">break</span><span class="x">
                    </span><span class="p">}</span><span class="x">
                    </span><span class="c">// 如果读比写快（读时会发生EOF错误），那就等一会儿再读。</span><span class="x">
                    </span><span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">readingConfig</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"reader [%d-%d]: error: %s"</span><span class="p">,</span><span class="x">
                        </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x">
                    </span><span class="k">continue</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="n">total</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="x">
                </span><span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"reader [%d-%d]: %s (total: %d)"</span><span class="p">,</span><span class="x">
                    </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">,</span><span class="x"> </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">total</span><span class="p">)</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}(</span><span class="n">i</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// signNumber 代表需要接收的信号的数量。</span><span class="x">
    </span><span class="n">signNumber</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">writingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">readingConfig</span><span class="o">.</span><span class="n">goNum</span><span class="x">
    </span><span class="c">// 等待上面启用的所有goroutine的运行全部结束。</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">signNumber</span><span class="p">;</span><span class="x"> </span><span class="n">j</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="o">&lt;-</span><span class="n">sign</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 原子操作</title>
      <link href="http://localhost:4000/timegeekbang-go-sync-atomic/"/>
      <pubDate>2019-03-26T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-sync-atomic</guid>
      <content:encoded><![CDATA[<p>在众多的同步工具中，真正能够保证原子性执行的只有原子操作（atomic operation）。原子操作在进行的过程中是不允许中断的。在底层，这会由 CPU 提供芯片级别的支持。</p>

<p><strong>sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？</strong></p>

<p>sync/atomic包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。</p>

<p><strong>第一个衍生问题 ：</strong>我们都知道，传入这些原子操作函数的第一个参数值对应的都应该是那个被操作的值。比如，atomic.AddInt32函数的第一个参数，对应的一定是那个要被增大的整数。可是，这个参数的类型为什么不是int32而是*int32呢？</p>

<p>回答是：因为原子操作函数需要的是被操作值的指针，而不是这个值本身；被传入函数的参数值都会被复制，像这种基本类型的值一旦被.传入函数，就已经与函数外的那个值毫无关系了。</p>

<p>所以，传入值本身没有任何意义。unsafe.Pointer类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向的那个值，所以需要的仍然是指向这个指针值的指针。</p>

<p><strong>第二个衍生问题：</strong> 用于原子加法操作的函数可以做原子减法吗？比如，atomic.AddInt32函数可以用于减小那个被操作的整数值吗？</p>

<p>回答是：当然是可以的。atomic.AddInt32函数的第二个参数代表差量，它的类型是int32，是有符号的。如果我们想做原子减法，那么把这个差量设置为负整数就可以了。</p>

<p>对于atomic.AddUint64函数做原子减法，就不能这么直接了，因为它们的第二个参数的类型分别是uint32和uint64，都是无符号的。所以要做转换 uint32(int32(-3))。如果不这么做的话，可报错。还有一种更加考虑直接的方式可以传入^uint32(-N-1)</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">atomic</span><span class="o">.</span><span class="n">AddUint32</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="kt">uint32</span><span class="p">(</span><span class="kt">int32</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span><span class="x">
</span><span class="c">//或</span><span class="x">
</span><span class="n">atomic</span><span class="o">.</span><span class="n">AddUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="o">^</span><span class="kt">uint32</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

<p><strong>第三个衍生问题：</strong> 比较并交换操作与交换操作相比有什么不同？优势在哪里？</p>

<p>回答是：比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行值的交换。
所谓的交换指的是，把新值赋给变量，并返回变量的旧值。</p>

<p><strong>第四个衍生问题：</strong> 假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，，还有必要使用原子操作吗？</p>

<p>回答是：很有必要。如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。</p>

<p>** 问题：怎样用好sync/atomic.Value?**</p>

<p>atomic.Value类型是开箱即用的，我们声明一个该类型的变量（以下简称原子变量）之后就可以直接使用了。这个类型使用起来很简单，它只有两个指针方法：Store和Load。不过，虽然简单，但还是有一些值得注意的地方的。</p>

<p>1 一旦被真正的使用，就不应该被复制，atomic.Value类型属于结构体类型， 而结构体类型属于值类型。复制时会产生个一完全分离的新值。</p>

<p>2 不能用原子偷走一存储nil</p>

<p>3 向原子值存储的第一个值，决定了它今后能且只能在座哪一个类型的值。即使使用接口类型，然后再存储这个接口的某个实现类型的值，还是不可以的。</p>

<p><strong>使用建议：</strong></p>

<p>1 不要把内部使用的原子值暴露给外界</p>

<p>2 如果不和地不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数让外界间接地信息使用它。注意，这种情况下不要把原子值传递外界，不论是传递原子值本身还是它的指针值。</p>

<p>3 如果通过某个函数可以向内部民的原子值 存储的话，那么就应该在这个函数中先判断被存储值类型的合法性。</p>

<p>4 最好把原子值封装到一个数据类型中，比如结构体类型。</p>

<p>尽量不要向原子值中存储引用类型的值，容易造成安全漏洞。</p>

<p>扩展阅读：https://www.jianshu.com/p/228c119a7d0e</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 程序性能分析基本</title>
      <link href="http://localhost:4000/timegeekbang-go-pprof/"/>
      <pubDate>2019-03-25T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-pprof</guid>
      <content:encoded><![CDATA[<p>Go 语言为程序开发者们提供了丰富的性能分析 API和标准工具。这些主要存在于：</p>

<blockquote>
  <p>1 runtime/pprof</p>

  <p>2 net/http/pprof</p>

  <p>3 runtime/trace</p>
</blockquote>

<p>在 Go 语言中，用于分析程序性能的概要文件有三种，分别是CPU 概要文件（CPU Profile）、内存概要文件（Mem Profile）和阻塞概要文件（Block Profile）。</p>

<p>对于 CPU 概要文件来说，其中的每一段独立的概要信息都记录着，在进行某一次采样的那个时刻，CPU 上正在执行的Go 代码。</p>

<p>而对于内存概要文件，其中的每一段概要信息都记载着，在某个采样时刻，正在执行的 Go 代码以及堆内存的使用情况，这里包含已分配和已释放的字节数量和对象数量。至于阻塞概要文件，其中的每一段概要信息，都代表着 Go 程序中的一个 goroutine 阻塞事件。</p>

<p>这时就可以显现出go tool pprof这个工具的作用了。我们可以通过它进入一个基于命令行的交互式界面，并对指定的概要文件进行查阅。概要文件是protoclo buffer 方式存储的。</p>

<p><strong>怎样设定内存概要信息的采样频率？</strong></p>

<p>只要为<code class="highlighter-rouge">runtime.MemProfileRate</code>变量赋值即可。</p>

<p>这个变量的含义是，平均每分配多少个字节，就对堆内存的使用情况进行一次采样。如果把该变量的值设为0，那么，Go 语言运行时系统就会完全停止对内存概要信息的采样。该变量的缺省值是512 KB，也就是512千字节。</p>

<p>越早设置越好，在main 开始时就设置。之后，需要调用<code class="highlighter-rouge">runtime/pprof</code>包中的<code class="highlighter-rouge">WriteHeapProfile</code>函数。该函数会把收集好的内存概要信息，写到我们指定的写入器中。</p>

<p>注意，我们通过<code class="highlighter-rouge">WriteHeapProfile</code>函数得到的内存概要信息并不是实时的，它是一个快照，是在最近一次的内存垃圾收集工作完成时产生的。如果你想要实时的信息，那么可以调用<code class="highlighter-rouge">runtime.ReadMemStats</code>函数。不过要特别注意，该函数会引起 Go 语言调度器的短暂停顿。</p>

<p><strong>怎样获取到阻塞概要信息？</strong></p>

<p>我们调用runtime包中的<code class="highlighter-rouge">SetBlockProfileRate</code>函数，即可对阻塞概要信息的采样频率进行设定。该函数有一个名叫rate的参数，它是int类型的。</p>

<p>这个参数的含义是，只要发现一个阻塞事件的持续时间达到了多少个纳秒，就可以对其进行采样。如果这个参数的值小于或等于0，那么就意味着 Go 语言运行时系统将会完全停止对阻塞概要信息的采样。</p>

<p>还有一个名叫<code class="highlighter-rouge">blockprofilerate</code>的包级私有变量，它是uint64类型的。这个变量的含义是，只要发现一个阻塞事事件的持续时间跨越了多少个 CPU 时钟周期，就可以对其进行采样。</p>

<p>另一方面，当我们需要获取阻塞概要信息的时候，需要先调用runtime/pprof包中的Lookup函数并传入参数值”block”，从而得到一个*runtime/pprof.Profile类型的值（以下简称Profile值）。在这之后，我们还需要调用这个Profile值的WriteTo方法，以驱使它把概要信息写进我们指定的写入器中。</p>

<p><strong>runtime/pprof.Lookup函数的调用方式是什么？</strong></p>

<p><code class="highlighter-rouge">runtime/pprof.Lookup</code>函数（以下简称Lookup函数）的功能是，提供与给定的名称相对应的概要信息。这个概要信息会由一个Profile值代表。如果该函数返回了一个nil，那么就说明不存在与给定名称对应的概要信息。</p>

<p><code class="highlighter-rouge">runtime/pprof</code>包已经为我们预先定义了 6 个概要名称。它们对应的概要信息收集方法和输出方法也都已经准备好了。我们直接拿来使用就可以了。</p>

<p>它们是：<code class="highlighter-rouge">goroutine、heap、allocs、threadcreate、block和mutex</code>。</p>

<p><strong>问题 4：如何为基于 HTTP 协议的网络服务添加性能分析接口？</strong></p>

<p>这个问题说起来还是很简单的。这是因为我们在一般情况下只要在程序中导入net/http/pprof代码包就可以了，就像这样：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="s">"net/http/pprof"</span><span class="x">
</span></code></pre></div></div>
<p>然后，启动网络服务并开始监听，比如：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">"localhost:8082"</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="p">))</span><span class="x">
</span></code></pre></div></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》go语言核心36讲 sync.WaitGroup和sync.Once</title>
      <link href="http://localhost:4000/timegeekbang-go-synWaitGroup/"/>
      <pubDate>2019-03-25T17:21:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/timegeekbang-go-synWaitGroup</guid>
      <content:encoded><![CDATA[<p>sync.WaitGroup类型（以下简称WaitGroup类型）是开箱即用的，也是并发安全的。同时，它一旦被真正使用就不能被复制了。</p>

<p>WaitGroup类型拥有三个指针方法：Add、Done和Wait。你可以想象该类型中有一个计数器，它的默认值是0。我们可以通过调用该类型值的Add方法来增加，或者减少这个计数器的值。</p>

<p>一般情况下，我会用这个方法来记录需要等待的 goroutine 的数量。相对应的，这个类型的Done方法，用于对其所属值中计数器的值进行减一操作。我们可以在需要等待的 goroutine 中，通过defer语句调用它。</p>

<p>而此类型的Wait方法的功能是，阻塞当前的 goroutine，直到其所属值中的计数器归零。如果在该方法被调用的时候，那个计数器的值就是0，那么它将不会做任何事情。</p>

<p>sync.WaitGroup类型值中计数器的值可以小于0吗？</p>

<p>这里的典型回答是：不可以。</p>

<p>另外，你可能已经知道，WaitGroup值是可以被复用的，但需要保证其计数周期的完整性。这里的计数周期指的是这样一个过程：该值中的计数器值由0变为了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了0。</p>

<p>也就是说，只要计数器的值始于0又归为0，就可以被视为一个计数周期。在一个此类值的生命周期中，它可以经历任意多个计数周期。但是，只有在它走完当前的计数周期之后，才能够开始下一个计数周期。</p>

<p><img src="/assets/timegeekbang/go-sync.png" alt="" /></p>

<p>不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行。换句话说，要杜绝对同一个WaitGroup值的两种操作的并发执行。</p>

<p>问题：sync.Once类型值的Do方法是怎么保证只执行参数函数一次的？
与sync.WaitGroup类型一样，sync.Once类型（以下简称Once类型）也属于结构体类型，同样也是开箱即用和并发安全的。由于这个类型中包含了一个sync.Mutex类型的字段，所以，复制该类型的值也会导致功能的失效。</p>

<p>扩展：https://www.cnblogs.com/linyihai/p/10285437.html</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
