Phil Calçado 详细的介绍了从开发者视角来看，服务开发模式和Service Mesh技术的演化过程。


时代0：开发人员想象中，不同服务间通信的方式，抽象表示如下：

时代1：原始通信时代

现实远比想象的复杂，通信过程中，我们需求自己处理网络中所面临的丢包、乱序、重试等一系列流控问题。

时代2：TCP时代

TCP协议的出现，避免每个服务实现业务逻辑的同时还要实现一套相似的网络传输处理的逻辑。 来解决网络传输中通用的流量控制问题，将技术栈下移，从服务的实现中抽离出来，成为操作系统网络层的一部分。

时代3：第一代微服务

分布式系统的发展带来了新的问题，如熔断策略、负载均衡、服务发现、认证和授权、quota限制、trace和监控等等，于是由回到上面的问题，在业务实现中又大量的实现了这一些基本功能。

时代4：第二代微服务

为了避免每个服务都要实现一套分布式系统通信的语义功能，一些面向微服务架构的开发框架出现了，如Twitter的Finagle、Facebook的Proxygen以及Spring Cloud等等。 
这些框架实现了分布式系统的一些通用功能：如负载均衡和服务发现等，使得开发人员更加专注于业务的开发。

时代5：第一代Service Mesh

第二代微服务模式看似完美，但开发人员很快又发现，它也存在一些本质问题：

其一，虽然框架本身屏蔽了分布式系统通信的一些通用功能实现细节，但开发者却要花更多精力去掌握和管理复杂的框架本身，在实际应用中，去追踪和解决框架出现的问题也绝非易事；
其二，开发框架通常只支持一种或几种特定的语言，回过头来看文章最开始对微服务的定义，一个重要的特性就是语言无关，但那些没有框架支持的语言编写的服务，很难融入面向微服务的架构体系，想因地制宜的用多种语言实现架构体系中的不同模块也很难做到；
其三，框架以lib库的形式和服务联编，复杂项目依赖时的库版本兼容问题非常棘手，同时，框架库的升级也无法对服务透明，服务会因为和业务无关的lib库升级而被迫升级；

因此以Linkerd，Envoy，为代表的代理模式（边车模式）应运而生，这就是第一代Service Mesh。


