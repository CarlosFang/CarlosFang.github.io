---
layout: post
title: linux signal and threads
date: 2017-03-15 21:12:15
categories: Linux
tags: 系统编程  
excerpt: linux signal and threads
---

#### 信号与进程：

信号是向进程异步发送的软件通知，通知进程有事件发生。事件可为硬件异常(如除0)、软件条件(如闹钟超时)、控制终端发出的信号或调用kill()/raise()函数产生的用户逻辑信号。

当信号产生时，内核通常在进程表中设置一个某种形式的标志，即向进程递送一个信号。在信号产生(generation)和递送(delivery)之间(可能相当长)的时间间隔内，该信号处于未决(pending)状态。已经生成但未递送的信号称为挂起(suspending)的信号。[这里涉及了两个状态， 一个*未决*， 一个*挂起*]

进程可选择阻塞(block)某个信号，此时若对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程(a)对此信号解除阻塞，或者(b)将对此信号的动作更改为忽略。

内核为每个进程维护一个未决(未处理的)信号队列，信号产生时无论是否被阻塞，首先放入未决队列里。当时间片调度到当前进程时，内核检查未决队列中是否存在信号。
若有信号且未被阻塞，则执行相应的操作并从队列中删除该信号；否则仍保留该信号。 因此，进程在信号递送给它之前仍可改变对该信号的动作。进程调用sigpending()函数判定哪些信号设置为阻塞并处于未决状态。 [产生信号后还没投递就会被放在未决信号队列中。]

 若在进程解除对某信号的阻塞之前，该信号发生多次，则未决队列仅保留相同不可靠信号中的一个，而可靠信号(实时扩展)会保留并递送多次，称为按顺序排队。[这个把信号分为可靠可靠的两种，那么哪一些是可靠的，那一些是不可靠呢？]

 每个进程都有一个信号屏蔽字(signal mask)，规定当前要阻塞递送到该进程的信号集。对于每个可能的信号，该屏蔽字中都有一位与之对应。对于某种信号，若其对应位已设置，则该信号当前被阻塞。[在一个进程中对一个信号的阻塞就是通过设置这个进程的屏蔽字来完成的]

 #### 信号与线程

 内核也为每个线程维护未决信号队列。当调用sigpending()时，返回整个进程未决信号队列与调用线程未决信号队列的并集。进程内创建线程时，新线程将继承进程(主线程)的信号屏蔽字，但新线程的未决信号集被清空(以防同一信号被多个线程处理)。[新线程的未决信号集,其实就是新的未决信号队列]
 
 线程的信号屏蔽字是私有的(定义当前线程要求阻塞的信号集)，即线程可独立地屏蔽某些信号。这样，应用程序可控制哪些线程响应哪些信号。


 信号处理函数由进程内所有线程共享。这意味着尽管单个线程可阻止某些信号，但当线程修改某信号相关的处理行为后，所有线程都共享该处理行为的改变。这样，若某线程选择忽略某信号，而其他线程可恢复信号的默认处理行为或为信号设置新的处理函数，从而撤销原先的忽略行为。即对某个信号处理函数，以最后一次注册的处理函数为准，从而保证同一信号被任意线程处理时行为相同。此外，若某信号的默认动作是停止或终止，则不管该信号发往哪个线程，整个进程都会停止或终止。

 若信号与硬件故障(如SIGBUS/SIGFPE/SIGILL/SIGSEGV)或定时器超时相关，该信号会发往引起该事件的线程。其它信号除非显式指定目标线程，否则通常发往主线程(哪怕信号处理函数由其他线程注册)，仅当主线程屏蔽该信号时才发往某个具有处理能力的线程。


```c
int main(void)
 {
    sigset_t tBlockSigs;
    sigemptyset(&tBlockSigs);
    sigaddset(&tBlockSigs, SIGINT);
    sigprocmask(SIG_BLOCK, &tBlockSigs, NULL);
  
    signal(SIGQUIT, sighandler);
  
    int dwRet;
#ifdef USE_SIGWAIT
    int dwSigNo;
    dwRet = sigwait(&tBlockSigs, &dwSigNo);
    printf("sigwait returns %d(%s), signo = %d\n", dwRet, strerror(errno), dwSigNo);
#else
    siginfo_t tSigInfo;
    dwRet = sigwaitinfo(&tBlockSigs, &tSigInfo);
    printf("sigwaitinfo returns %d(%s), signo = %d\n", dwRet, strerror(errno), tSigInfo.si_signo);
#endif
    return 0;
}
```